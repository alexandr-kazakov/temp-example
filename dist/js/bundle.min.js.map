{"version":3,"names":[],"mappings":"","sources":["bundle.min.js"],"sourcesContent":["!function(n){var r={};function s(t){if(r[t])return r[t].exports;var e=r[t]={i:t,l:!1,exports:{}};return n[t].call(e.exports,e,e.exports,s),e.l=!0,e.exports}s.m=n,s.c=r,s.d=function(t,e,n){s.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},s.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},s.t=function(e,t){if(1&t&&(e=s(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(s.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var r in e)s.d(n,r,function(t){return e[t]}.bind(null,r));return n},s.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return s.d(e,\"a\",e),e},s.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},s.p=\"\",s(s.s=\"./build/js/main.js\")}({\"./build/js/blocks/alert.js\":function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = alertInit;\\n\\n/* -------------------------------------------------------------------------\\n  begin Alert\\n* ------------------------------------------------------------------------- */\\nfunction closeAlert(target) {\\n  target.parentElement.classList.add('fade-out');\\n  setTimeout(function () {\\n    target.parentElement.classList.add('hidden');\\n  }, 200);\\n}\\n\\nfunction alertInit() {\\n  var alertsCloseButtons = document.querySelectorAll('.alert__close-btn');\\n  alertsCloseButtons.forEach(function (elem) {\\n    elem.addEventListener('click', function (event) {\\n      var target = event.target;\\n      closeAlert(target);\\n    });\\n  });\\n}\\n/* -------------------------------------------------------------------------\\n      end Alert\\n    * ------------------------------------------------------------------------- */\\n\\n//# sourceURL=webpack:///./build/js/blocks/alert.js?\")},\"./build/js/blocks/basket.js\":function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = basketInit;\\n\\n/* -------------------------------------------------------------------------\\n     begin Basket\\n   * ------------------------------------------------------------------------- */\\nfunction basketInit() {\\n  var productCards = document.querySelectorAll('.product-card form');\\n  var basketCounter = 1;\\n\\n  function basketAnimate(event) {\\n    event.preventDefault();\\n    basketCounter += 1;\\n    var baskets = document.querySelectorAll('.cart-box');\\n    baskets.forEach(function (elem) {\\n      var basketQuantity = elem.querySelector('.cart-box__quantity-number');\\n      var basketPrice = elem.querySelector('.cart-box__value');\\n      var basketPriceNumber = elem.querySelector('.cart-box__value-number');\\n      basketQuantity.classList.remove('animate');\\n      basketPrice.classList.remove('animate');\\n      void elem.offsetWidth;\\n      basketQuantity.classList.add('animate');\\n      basketPrice.classList.add('animate');\\n      setTimeout(function () {\\n        basketQuantity.innerHTML = basketCounter;\\n      }, 200);\\n    });\\n  }\\n\\n  productCards.forEach(function (elem) {\\n    elem.addEventListener('submit', basketAnimate);\\n  });\\n}\\n/* -------------------------------------------------------------------------\\n     end Basket\\n   * ------------------------------------------------------------------------- */\\n\\n//# sourceURL=webpack:///./build/js/blocks/basket.js?\")},\"./build/js/blocks/document.js\":function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = documentInit;\\n\\nvar _selectBox = __webpack_require__(/*! ./select-box */ \\\"./build/js/blocks/select-box.js\\\");\\n\\n/* -------------------------------------------------------------------------\\n  begin Document\\n* ------------------------------------------------------------------------- */\\nfunction isClickInside(target, elem) {\\n  var checkResult = elem.contains(target);\\n  return checkResult;\\n}\\n\\nfunction checkOpenDropdownMenu(event) {\\n  var target = event.target;\\n  var openMenuDropdowns = document.querySelectorAll('.dropdown-menu:not(.hidden)');\\n  openMenuDropdowns.forEach(function (elem) {\\n    var menuBox = elem;\\n    var counter = 0;\\n\\n    while (counter < 100) {\\n      if (menuBox.classList.contains('toggle-dropdown')) {\\n        break;\\n      }\\n\\n      menuBox = menuBox.parentElement;\\n      counter += 1;\\n    }\\n\\n    var result = isClickInside(target, menuBox);\\n\\n    if (!result) {\\n      elem.classList.add('hidden');\\n\\n      if (menuBox.querySelector('[data-dropdown-toggle-click]')) {\\n        menuBox.querySelector('[data-dropdown-toggle-click]').classList.remove('active');\\n      }\\n    }\\n  });\\n}\\n\\nfunction documentInit() {\\n  document.addEventListener('click', function (event) {\\n    var target = event.target;\\n\\n    if (document.querySelector('.select-box__dropdown.show')) {\\n      var openSelectDropdowns = document.querySelectorAll('.select-box__dropdown.show');\\n      openSelectDropdowns.forEach(function (elem) {\\n        var selectBox = elem;\\n        var counter = 0;\\n        var selectToggleBtn = elem.previousElementSibling;\\n\\n        while (counter < 100) {\\n          if (selectBox.classList.contains('select-box')) {\\n            break;\\n          }\\n\\n          selectBox = selectBox.parentElement;\\n          counter += 1;\\n        }\\n\\n        var result = isClickInside(target, selectBox);\\n\\n        if (!result) {\\n          (0, _selectBox.switchDropdown)(elem);\\n          (0, _selectBox.switchToggleBtn)(selectToggleBtn);\\n        }\\n      });\\n    }\\n\\n    if (document.querySelector('.dropdown-menu:not(.hidden)')) {\\n      checkOpenDropdownMenu(event);\\n    }\\n  });\\n}\\n/* -------------------------------------------------------------------------\\n    end Document\\n  * ------------------------------------------------------------------------- */\\n\\n//# sourceURL=webpack:///./build/js/blocks/document.js?\")},\"./build/js/blocks/dropdown.js\":function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = dropdownInit;\\n\\n/* -------------------------------------------------------------------------\\n  begin Dropdown\\n* ------------------------------------------------------------------------- */\\nfunction dropdownMenuSwitch(event) {\\n  var target = event.target;\\n  var dropdonw = target.nextElementSibling;\\n  var toggler = target.classList.contains('toggle-dropdown__toggler');\\n\\n  if (dropdonw.classList.contains('hidden')) {\\n    dropdonw.classList.remove('hidden');\\n    if (toggler) target.classList.add('active');\\n  } else {\\n    dropdonw.classList.add('hidden');\\n    if (toggler) target.classList.remove('active');\\n  }\\n}\\n\\nfunction dropdownInit() {\\n  var clickDropdowns = document.querySelectorAll('[data-dropdown-toggle-click]');\\n  clickDropdowns.forEach(function (elem) {\\n    elem.addEventListener('click', dropdownMenuSwitch);\\n  });\\n  if (document.body.classList.contains('mobile')) return;\\n  var hoverDropdowns = document.querySelectorAll('[data-dropdown-toggle-hover]');\\n  hoverDropdowns.forEach(function (elem) {\\n    elem.addEventListener('mouseover', function () {\\n      elem.nextElementSibling.classList.remove('hidden');\\n    });\\n    elem.parentElement.addEventListener('mouseleave', function (event) {\\n      event.target.querySelector('.dropdown').classList.add('hidden');\\n    });\\n  });\\n}\\n/* -------------------------------------------------------------------------\\n        end Dropdown\\n * ------------------------------------------------------------------------- */\\n\\n//# sourceURL=webpack:///./build/js/blocks/dropdown.js?\")},\"./build/js/blocks/header-scroll.js\":function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = headerScrollInit;\\n\\n/* -------------------------------------------------------------------------\\n  begin Header\\n* ------------------------------------------------------------------------- */\\n\\n/* begin Window Resize */\\nfunction actualResizeHandler() {\\n  var header = document.getElementById('header');\\n\\n  if (window.pageYOffset > 0 && window.innerWidth > 767 && !header.classList.contains('scroll-active')) {\\n    header.classList.add('scroll-active');\\n  }\\n\\n  if (window.innerWidth <= 767 && header.classList.contains('scroll-active')) {\\n    header.classList.remove('scroll-active');\\n  }\\n}\\n\\nfunction resizeThrottler() {\\n  var resizeTimeout = void 0;\\n\\n  if (!resizeTimeout) {\\n    resizeTimeout = setTimeout(function () {\\n      resizeTimeout = null;\\n      actualResizeHandler();\\n    }, 66);\\n  }\\n}\\n/* end Window Resize */\\n\\n\\nfunction checkScroll() {\\n  var header = document.getElementById('header');\\n\\n  if (window.pageYOffset > 0 && window.innerWidth > 767 && !header.classList.contains('scroll-active')) {\\n    header.classList.add('scroll-active');\\n  }\\n\\n  if (window.pageYOffset <= 0 && window.innerWidth > 767 && header.classList.contains('scroll-active')) {\\n    header.classList.remove('scroll-active');\\n  }\\n}\\n\\nfunction headerScrollInit() {\\n  checkScroll();\\n  window.addEventListener('scroll', checkScroll);\\n  window.addEventListener('resize', resizeThrottler);\\n}\\n/* -------------------------------------------------------------------------\\n        end Header\\n   * ------------------------------------------------------------------------- */\\n\\n//# sourceURL=webpack:///./build/js/blocks/header-scroll.js?\")},\"./build/js/blocks/inputmask.js\":function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = inputMaskInit;\\n\\nvar _inputmask = __webpack_require__(/*! inputmask */ \\\"./node_modules/inputmask/index.js\\\");\\n\\nvar _inputmask2 = _interopRequireDefault(_inputmask);\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n/* -------------------------------------------------------------------------\\n      begin Mask Phone\\n* ------------------------------------------------------------------------- */\\nfunction inputMaskInit() {\\n  var inputsTel = document.querySelectorAll('input[type=\\\"tel\\\"]');\\n  (0, _inputmask2.default)({\\n    mask: '+7 (999) 999-99-99',\\n    showMaskOnHover: false\\n  }).mask(inputsTel);\\n  var inputsDate = document.querySelectorAll('input[data-mask-type=\\\"date\\\"]');\\n  (0, _inputmask2.default)({\\n    mask: '99.99.9999',\\n    showMaskOnHover: false\\n  }).mask(inputsDate);\\n}\\n/* -------------------------------------------------------------------------\\n        end Mask Phone\\n* ------------------------------------------------------------------------- */\\n\\n//# sourceURL=webpack:///./build/js/blocks/inputmask.js?\")},\"./build/js/blocks/mobile-detect.js\":function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = mobileDetect;\\n\\n/* -------------------------------------------------------------------------\\n  begin mobileDetect\\n* ------------------------------------------------------------------------- */\\nfunction mobileDetect() {\\n  if (/iPad|iPhone|iPod|Android|webOS|BlackBerry|IEMobile|Opera Mini/.test(navigator.userAgent)) {\\n    document.body.classList.add('mobile');\\n  }\\n}\\n/* -------------------------------------------------------------------------\\n  end mobileDetect\\n * ------------------------------------------------------------------------- */\\n\\n//# sourceURL=webpack:///./build/js/blocks/mobile-detect.js?\")},\"./build/js/blocks/mobile-menu.js\":function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = mobileMenunInit;\\n\\n/* -------------------------------------------------------------------------\\n  begin Mobile menu\\n* ------------------------------------------------------------------------- */\\nfunction mobileMenunInit() {\\n  var mobileMenu = document.getElementById('mobile-menu');\\n  var overlay = document.getElementById('overlay');\\n  var mobileMenuOpenBtn = document.getElementById('header-sandwich');\\n  var mobileMenuCloseBtn = document.getElementById('mobile-menu-sandwich');\\n  mobileMenuOpenBtn.addEventListener('click', function () {\\n    mobileMenu.classList.add('open');\\n    overlay.classList.add('show');\\n  });\\n  mobileMenuCloseBtn.addEventListener('click', function () {\\n    mobileMenu.classList.remove('open');\\n    overlay.classList.remove('show');\\n  });\\n  overlay.addEventListener('click', function () {\\n    mobileMenu.classList.remove('open');\\n    overlay.classList.remove('show');\\n  });\\n}\\n/* -------------------------------------------------------------------------\\n          end Mobile menu\\n   * ------------------------------------------------------------------------- */\\n\\n//# sourceURL=webpack:///./build/js/blocks/mobile-menu.js?\")},\"./build/js/blocks/rating.js\":function(module,exports,__webpack_require__){\"use strict\";eval(\"/* WEBPACK VAR INJECTION */(function($) {\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = ratingInit;\\n\\n/* -------------------------------------------------------------------------\\n  begin Rating\\n* ------------------------------------------------------------------------- */\\nfunction ratingInit() {\\n  $('#stars-rating-select').barrating({\\n    theme: 'css-stars'\\n  });\\n}\\n/* -------------------------------------------------------------------------\\n        end Rating\\n      * ------------------------------------------------------------------------- */\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \\\"./node_modules/jquery/dist/jquery.js\\\")))\\n\\n//# sourceURL=webpack:///./build/js/blocks/rating.js?\")},\"./build/js/blocks/select-box.js\":function(module,exports,__webpack_require__){\"use strict\";eval(\"/* WEBPACK VAR INJECTION */(function($) {\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.switchDropdown = switchDropdown;\\nexports.switchToggleBtn = switchToggleBtn;\\nexports.default = selectBoxesInit;\\n\\n/* -------------------------------------------------------------------------\\n  begin Select-Box\\n* ------------------------------------------------------------------------- */\\nfunction switchDropdown(dropdown) {\\n  if (dropdown.classList.contains('show')) {\\n    dropdown.classList.remove('show');\\n  } else {\\n    dropdown.classList.add('show');\\n  }\\n}\\n\\nfunction switchToggleBtn(toggleBtn) {\\n  if (toggleBtn.classList.contains('active')) {\\n    toggleBtn.classList.remove('active');\\n  } else {\\n    toggleBtn.classList.add('active');\\n  }\\n}\\n\\nfunction switchSelectOption(event) {\\n  var target = event.target;\\n  var selectBox = false;\\n  var activeIndex = void 0;\\n\\n  while (!selectBox) {\\n    if (target.classList.contains('select-box')) {\\n      selectBox = target;\\n      target = this;\\n      break;\\n    }\\n\\n    target = target.parentElement;\\n  }\\n\\n  var selectBoxDropdown = selectBox.querySelector('.select-box__dropdown');\\n  var dropdownToggleBtn = selectBox.querySelector('.select-box__dropdown-toggle');\\n\\n  if (target.classList.contains('active')) {\\n    switchDropdown(selectBoxDropdown);\\n    switchToggleBtn(dropdownToggleBtn);\\n    return;\\n  }\\n\\n  selectBoxDropdown.querySelector('.active').classList.remove('active');\\n  target.classList.add('active');\\n  selectBoxDropdown.querySelectorAll('.select-box__dropdown-item').forEach(function (elem, index) {\\n    if (elem.classList.contains('active')) {\\n      activeIndex = index;\\n    }\\n  });\\n  var formSelect = selectBox.querySelector('.select-box__true-select');\\n  formSelect.querySelector('[selected]').removeAttribute('selected');\\n  formSelect.querySelectorAll('.select-box__option')[activeIndex].setAttribute('selected', 'selected');\\n  switchDropdown(selectBoxDropdown);\\n  dropdownToggleBtn.querySelector('.select-box__dropdown-toggle-text').innerHTML = target.innerHTML;\\n  switchToggleBtn(dropdownToggleBtn);\\n}\\n\\nfunction selectClickEventHandler(event) {\\n  var target = event.target;\\n  var dropdown = target.nextElementSibling;\\n  switchDropdown(dropdown);\\n  switchToggleBtn(target);\\n}\\n\\nfunction selectBoxesInit() {\\n  var selectBoxes = document.querySelectorAll('.select-box');\\n  selectBoxes.forEach(function (elem, index) {\\n    var selectBoxItems = selectBoxes[index].querySelectorAll('.select-box__dropdown-item');\\n    selectBoxItems.forEach(function (el, number) {\\n      selectBoxItems[number].addEventListener('click', switchSelectOption);\\n    });\\n    selectBoxes[index].querySelector('.select-box__dropdown-toggle').addEventListener('click', selectClickEventHandler);\\n  });\\n  $('.select-box').trigger('change');\\n}\\n\\nwindow.selectBoxesUpdate = function () {\\n  selectBoxesInit();\\n};\\n/* -------------------------------------------------------------------------\\n    end Select-Box\\n  * ------------------------------------------------------------------------- */\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \\\"./node_modules/jquery/dist/jquery.js\\\")))\\n\\n//# sourceURL=webpack:///./build/js/blocks/select-box.js?\")},\"./build/js/blocks/swiper-carousel.js\":function(module,exports,__webpack_require__){\"use strict\";eval(\"/* WEBPACK VAR INJECTION */(function($) {\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = initSwiper;\\n\\nvar _swiper = __webpack_require__(/*! ../../../node_modules/swiper/dist/js/swiper */ \\\"./node_modules/swiper/dist/js/swiper.js\\\");\\n\\nvar _swiper2 = _interopRequireDefault(_swiper);\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\n/* -------------------------------------------------------------------------\\n  begin Reviews-video-carousel\\n* ------------------------------------------------------------------------- */\\nfunction initSwiper() {\\n  var popularDishesCarousel = new _swiper2.default('#popular-dishes-carousel', {\\n    slidesPerView: 'auto',\\n    spaceBetween: 20,\\n    breakpoints: {\\n      500: {\\n        slidesPerView: 1\\n      },\\n      767: {\\n        spaceBetween: 15,\\n        slidesPerView: 2\\n      },\\n      991: {\\n        slidesPerView: 2\\n      },\\n      1199: {\\n        slidesPerView: 3\\n      },\\n      6000: {\\n        slidesPerView: 4\\n      }\\n    },\\n    navigation: {\\n      nextEl: '#section__popular-dishes-carousel .swiper-button-next',\\n      prevEl: '#section__popular-dishes-carousel .swiper-button-prev'\\n    }\\n  });\\n  var imagesCarousel = new _swiper2.default('#images-carousel', {\\n    slidesPerView: 'auto',\\n    spaceBetween: 20,\\n    breakpoints: {\\n      500: {\\n        slidesPerView: 1\\n      },\\n      767: {\\n        spaceBetween: 15,\\n        slidesPerView: 2\\n      },\\n      991: {\\n        slidesPerView: 2\\n      },\\n      6000: {\\n        slidesPerView: 3\\n      }\\n    },\\n    navigation: {\\n      nextEl: '#tab-content__images-carousel .swiper-button-next',\\n      prevEl: '#tab-content__images-carousel .swiper-button-prev'\\n    }\\n  });\\n}\\n\\n$('#information-tab').on('shown.bs.tab', function (event) {\\n  var openTab = event.target.getAttribute('href');\\n  $(openTab).find('.swiper-container')[0].swiper.update();\\n});\\n/* -------------------------------------------------------------------------\\n  end Reviews-video-carousel\\n* ------------------------------------------------------------------------- */\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \\\"./node_modules/jquery/dist/jquery.js\\\")))\\n\\n//# sourceURL=webpack:///./build/js/blocks/swiper-carousel.js?\")},\"./build/js/blocks/tabs.js\":function(module,exports,__webpack_require__){\"use strict\";eval(\"/* WEBPACK VAR INJECTION */(function($) {\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = tabsInit;\\n\\n/* -------------------------------------------------------------------------\\n  begin Tabs\\n* ------------------------------------------------------------------------- */\\nfunction tabsInit() {\\n  var checkoutFirstStepBtn = document.getElementById('checkout-first-step-btn');\\n\\n  if (checkoutFirstStepBtn) {\\n    checkoutFirstStepBtn.addEventListener('click', function () {\\n      $('#checkout-two-tab').tab('show');\\n    });\\n  }\\n}\\n/* -------------------------------------------------------------------------\\n        end Tabs\\n* ------------------------------------------------------------------------- */\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \\\"./node_modules/jquery/dist/jquery.js\\\")))\\n\\n//# sourceURL=webpack:///./build/js/blocks/tabs.js?\")},\"./build/js/blocks/universal-toggler.js\":function(module,exports,__webpack_require__){\"use strict\";eval(\"/* WEBPACK VAR INJECTION */(function($) {\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = universalTogglerInit;\\n\\n/* -------------------------------------------------------------------------\\n  begin Tabs\\n* ------------------------------------------------------------------------- */\\nfunction universalTogglerInit() {\\n  var universalTogglers = document.querySelectorAll('.universal-toggler');\\n  universalTogglers.forEach(function (elem) {\\n    elem.addEventListener('click', function (event) {\\n      var target = event.target;\\n      $(target).slideUp();\\n      $(target).next('.hidden').slideDown();\\n\\n      if (target.classList.contains('universal-toggler_checkout')) {\\n        document.getElementById('checkout-one').querySelector('input[type=radio]:checked').checked = false;\\n      }\\n    });\\n  });\\n}\\n/* -------------------------------------------------------------------------\\n          end Tabs\\n  * ------------------------------------------------------------------------- */\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \\\"./node_modules/jquery/dist/jquery.js\\\")))\\n\\n//# sourceURL=webpack:///./build/js/blocks/universal-toggler.js?\")},\"./build/js/blocks/yandex-map.js\":function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.default = yandexMapInit;\\n\\n/* -------------------------------------------------------------------------\\n   begin Yandex Map\\n * ------------------------------------------------------------------------- */\\nfunction yandexMapInit() {\\n  var restaurantMapBlock = document.getElementById('restaurant-map');\\n  var x = restaurantMapBlock.getAttribute('data-x');\\n  var y = restaurantMapBlock.getAttribute('data-y');\\n  ymaps.ready(function () {\\n    var restaurantMap = new ymaps.Map(restaurantMapBlock, {\\n      center: [x, y],\\n      zoom: 13,\\n      controls: []\\n    });\\n    var restaurantMapPlacemark = new ymaps.Placemark([x, y], {}, {\\n      preset: 'islands#redDotIcon',\\n      iconColor: '#e8500e'\\n    });\\n    restaurantMap.geoObjects.add(restaurantMapPlacemark);\\n  });\\n}\\n/* -------------------------------------------------------------------------\\n   end Yandex Map\\n * ------------------------------------------------------------------------- */\\n\\n//# sourceURL=webpack:///./build/js/blocks/yandex-map.js?\")},\"./build/js/libraries/polyfills.js\":function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\nif (window.NodeList && !NodeList.prototype.forEach) {\\n  NodeList.prototype.forEach = function (callback, thisArg) {\\n    thisArg = thisArg || window;\\n\\n    for (var i = 0; i < this.length; i++) {\\n      callback.call(thisArg, this[i], i, this);\\n    }\\n  };\\n}\\n/* -------------------------------------------------------------------------\\r\\n  begin Tagify polyfill\\r\\n* ------------------------------------------------------------------------- */\\n\\n\\n(function () {\\n  if (!String.prototype.includes) {\\n    String.prototype.includes = function (search, start) {\\n      if (typeof start !== 'number') start = 0;\\n      if (start + search.length > this.length) return false;\\n      return this.indexOf(search, start) !== -1;\\n    };\\n  } // ////////////////////////////////////////////////////////////////\\n  // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill\\n\\n\\n  if (typeof window.CustomEvent === 'function') return false;\\n\\n  function CustomEvent(event, params) {\\n    params = params || {\\n      bubbles: false,\\n      cancelable: false,\\n      detail: undefined\\n    };\\n    var evt = document.createEvent('CustomEvent');\\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\\n    return evt;\\n  }\\n\\n  CustomEvent.prototype = window.Event.prototype;\\n  window.CustomEvent = CustomEvent; // ////////////////////////////////////////////////////////////////\\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill\\n  //\\n\\n  if (typeof Object.assign !== 'function') {\\n    // Must be writable: true, enumerable: false, configurable: true\\n    Object.defineProperty(Object, 'assign', {\\n      value: function assign(target, varArgs) {\\n        // .length of function is 2\\n        if (target == null) {\\n          // TypeError if undefined or null\\n          throw new TypeError('Cannot convert undefined or null to object');\\n        }\\n\\n        var to = Object(target);\\n\\n        for (var index = 1; index < arguments.length; index++) {\\n          var nextSource = arguments[index];\\n\\n          if (nextSource != null) {\\n            // Skip over if undefined or null\\n            for (var nextKey in nextSource) {\\n              // Avoid bugs when hasOwnProperty is shadowed\\n              if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\\n                to[nextKey] = nextSource[nextKey];\\n              }\\n            }\\n          }\\n        }\\n\\n        return to;\\n      },\\n      writable: true,\\n      configurable: true\\n    });\\n  } // if (window.NodeList && !NodeList.prototype.forEach) {\\n  //   NodeList.prototype.forEach = Array.prototype.forEach;\\n  // }\\n\\n\\n  if (!Array.prototype.findIndex) {\\n    Object.defineProperty(Array.prototype, 'findIndex', {\\n      value: function value(predicate) {\\n        if (this == null) throw new TypeError('\\\"this\\\" is null or not defined');\\n        var o = Object(this);\\n        var len = o.length >>> 0;\\n\\n        if (typeof predicate !== 'function') {\\n          throw new TypeError('predicate must be a function');\\n        }\\n\\n        var thisArg = arguments[1];\\n        var k = 0;\\n\\n        while (k < len) {\\n          var kValue = o[k];\\n\\n          if (predicate.call(thisArg, kValue, k, o)) {\\n            return k;\\n          }\\n\\n          k++;\\n        }\\n\\n        return -1;\\n      },\\n      configurable: true,\\n      writable: true\\n    });\\n  } // Avoid transformation text to link ie contentEditable mode\\n  // https://stackoverflow.com/q/7556007/104380\\n\\n\\n  document.execCommand('AutoUrlDetect', false, false);\\n})();\\n/* -------------------------------------------------------------------------\\r\\n    end Tagify polyfill\\r\\n  * ------------------------------------------------------------------------- */\\n\\n//# sourceURL=webpack:///./build/js/libraries/polyfills.js?\")},\"./build/js/main.js\":function(module,exports,__webpack_require__){\"use strict\";eval(\"\\n\\n__webpack_require__(/*! ./libraries/polyfills */ \\\"./build/js/libraries/polyfills.js\\\");\\n\\nvar _mobileDetect = __webpack_require__(/*! ./blocks/mobile-detect */ \\\"./build/js/blocks/mobile-detect.js\\\");\\n\\nvar _mobileDetect2 = _interopRequireDefault(_mobileDetect);\\n\\n__webpack_require__(/*! ../../node_modules/bootstrap/js/dist/modal */ \\\"./node_modules/bootstrap/js/dist/modal.js\\\");\\n\\n__webpack_require__(/*! ../../node_modules/bootstrap/js/dist/tab */ \\\"./node_modules/bootstrap/js/dist/tab.js\\\");\\n\\n__webpack_require__(/*! ../../node_modules/bootstrap/js/dist/collapse */ \\\"./node_modules/bootstrap/js/dist/collapse.js\\\");\\n\\n__webpack_require__(/*! ../../node_modules/@fancyapps/fancybox/dist/jquery.fancybox */ \\\"./node_modules/@fancyapps/fancybox/dist/jquery.fancybox.js\\\");\\n\\n__webpack_require__(/*! ../../node_modules/jquery-bar-rating/dist/jquery.barrating.min */ \\\"./node_modules/jquery-bar-rating/dist/jquery.barrating.min.js\\\");\\n\\nvar _sweetalert = __webpack_require__(/*! ../../node_modules/sweetalert2/dist/sweetalert2 */ \\\"./node_modules/sweetalert2/dist/sweetalert2.js\\\");\\n\\nvar _sweetalert2 = _interopRequireDefault(_sweetalert);\\n\\nvar _alert = __webpack_require__(/*! ./blocks/alert */ \\\"./build/js/blocks/alert.js\\\");\\n\\nvar _alert2 = _interopRequireDefault(_alert);\\n\\nvar _inputmask = __webpack_require__(/*! ./blocks/inputmask */ \\\"./build/js/blocks/inputmask.js\\\");\\n\\nvar _inputmask2 = _interopRequireDefault(_inputmask);\\n\\nvar _swiperCarousel = __webpack_require__(/*! ./blocks/swiper-carousel */ \\\"./build/js/blocks/swiper-carousel.js\\\");\\n\\nvar _swiperCarousel2 = _interopRequireDefault(_swiperCarousel);\\n\\nvar _headerScroll = __webpack_require__(/*! ./blocks/header-scroll */ \\\"./build/js/blocks/header-scroll.js\\\");\\n\\nvar _headerScroll2 = _interopRequireDefault(_headerScroll);\\n\\nvar _dropdown = __webpack_require__(/*! ./blocks/dropdown */ \\\"./build/js/blocks/dropdown.js\\\");\\n\\nvar _dropdown2 = _interopRequireDefault(_dropdown);\\n\\nvar _mobileMenu = __webpack_require__(/*! ./blocks/mobile-menu */ \\\"./build/js/blocks/mobile-menu.js\\\");\\n\\nvar _mobileMenu2 = _interopRequireDefault(_mobileMenu);\\n\\nvar _selectBox = __webpack_require__(/*! ./blocks/select-box */ \\\"./build/js/blocks/select-box.js\\\");\\n\\nvar _selectBox2 = _interopRequireDefault(_selectBox);\\n\\nvar _yandexMap = __webpack_require__(/*! ./blocks/yandex-map */ \\\"./build/js/blocks/yandex-map.js\\\");\\n\\nvar _yandexMap2 = _interopRequireDefault(_yandexMap);\\n\\nvar _rating = __webpack_require__(/*! ./blocks/rating */ \\\"./build/js/blocks/rating.js\\\");\\n\\nvar _rating2 = _interopRequireDefault(_rating);\\n\\nvar _tabs = __webpack_require__(/*! ./blocks/tabs */ \\\"./build/js/blocks/tabs.js\\\");\\n\\nvar _tabs2 = _interopRequireDefault(_tabs);\\n\\nvar _universalToggler = __webpack_require__(/*! ./blocks/universal-toggler */ \\\"./build/js/blocks/universal-toggler.js\\\");\\n\\nvar _universalToggler2 = _interopRequireDefault(_universalToggler);\\n\\nvar _basket = __webpack_require__(/*! ./blocks/basket */ \\\"./build/js/blocks/basket.js\\\");\\n\\nvar _basket2 = _interopRequireDefault(_basket);\\n\\nvar _document = __webpack_require__(/*! ./blocks/document */ \\\"./build/js/blocks/document.js\\\");\\n\\nvar _document2 = _interopRequireDefault(_document);\\n\\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\\n\\ndocument.addEventListener('DOMContentLoaded', function () {\\n  (0, _mobileDetect2.default)();\\n\\n  if (document.querySelector('.alert__close-btn')) {\\n    console.log('init Alert Success');\\n    (0, _alert2.default)();\\n  }\\n\\n  if (document.querySelector('input[type=\\\"tel\\\"]')) {\\n    console.log('init InputMask  Success');\\n    (0, _inputmask2.default)();\\n  }\\n\\n  if (document.querySelector('.swiper-container')) {\\n    console.log('init Swiper Success');\\n    (0, _swiperCarousel2.default)();\\n  }\\n\\n  if (document.querySelector('.header_theme_white')) {\\n    console.log('init Header Scroll Success');\\n    (0, _headerScroll2.default)();\\n  }\\n\\n  if (document.querySelector('[data-dropdown-toggle-click]') || document.querySelector('[data-dropdown-toggle-hover]')) {\\n    console.log('init Dropdown Success');\\n    (0, _dropdown2.default)();\\n  }\\n\\n  if (document.querySelector('#mobile-menu')) {\\n    console.log('init MobileMenu Success');\\n    (0, _mobileMenu2.default)();\\n  }\\n\\n  if (document.querySelector('.select-box')) {\\n    console.log('init Select-Boxes Success');\\n    (0, _selectBox2.default)();\\n  }\\n\\n  if (document.querySelector('.yandex-map')) {\\n    console.log('init Yandex Map Success');\\n    (0, _yandexMap2.default)();\\n  }\\n\\n  if (document.querySelector('.stars-rating-select')) {\\n    console.log('init Rating Success');\\n    (0, _rating2.default)();\\n  }\\n\\n  if (document.querySelector('.nav-tabs')) {\\n    console.log('init Tabs Success');\\n    (0, _tabs2.default)();\\n  }\\n\\n  if (document.querySelector('.universal-toggler')) {\\n    console.log('init Universal Toggler Success');\\n    (0, _universalToggler2.default)();\\n  }\\n\\n  if (document.querySelector('.product-card')) {\\n    console.log('init Basket Success');\\n    (0, _basket2.default)();\\n  }\\n\\n  (0, _document2.default)();\\n});\\n\\n//# sourceURL=webpack:///./build/js/main.js?\")},\"./node_modules/@fancyapps/fancybox/dist/jquery.fancybox.js\":function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(jQuery) {// ==================================================\\n// fancyBox v3.5.6\\n//\\n// Licensed GPLv3 for open source use\\n// or fancyBox Commercial License for commercial use\\n//\\n// http://fancyapps.com/fancybox/\\n// Copyright 2018 fancyApps\\n//\\n// ==================================================\\n(function(window, document, $, undefined) {\\r\\n  \"use strict\";\\r\\n\\r\\n  window.console = window.console || {\\r\\n    info: function(stuff) {}\\r\\n  };\\r\\n\\r\\n  // If there\\'s no jQuery, fancyBox can\\'t work\\r\\n  // =========================================\\r\\n\\r\\n  if (!$) {\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  // Check if fancyBox is already initialized\\r\\n  // ========================================\\r\\n\\r\\n  if ($.fn.fancybox) {\\r\\n    console.info(\"fancyBox already initialized\");\\r\\n\\r\\n    return;\\r\\n  }\\r\\n\\r\\n  // Private default settings\\r\\n  // ========================\\r\\n\\r\\n  var defaults = {\\r\\n    // Close existing modals\\r\\n    // Set this to false if you do not need to stack multiple instances\\r\\n    closeExisting: false,\\r\\n\\r\\n    // Enable infinite gallery navigation\\r\\n    loop: false,\\r\\n\\r\\n    // Horizontal space between slides\\r\\n    gutter: 50,\\r\\n\\r\\n    // Enable keyboard navigation\\r\\n    keyboard: true,\\r\\n\\r\\n    // Should allow caption to overlap the content\\r\\n    preventCaptionOverlap: true,\\r\\n\\r\\n    // Should display navigation arrows at the screen edges\\r\\n    arrows: true,\\r\\n\\r\\n    // Should display counter at the top left corner\\r\\n    infobar: true,\\r\\n\\r\\n    // Should display close button (using `btnTpl.smallBtn` template) over the content\\r\\n    // Can be true, false, \"auto\"\\r\\n    // If \"auto\" - will be automatically enabled for \"html\", \"inline\" or \"ajax\" items\\r\\n    smallBtn: \"auto\",\\r\\n\\r\\n    // Should display toolbar (buttons at the top)\\r\\n    // Can be true, false, \"auto\"\\r\\n    // If \"auto\" - will be automatically hidden if \"smallBtn\" is enabled\\r\\n    toolbar: \"auto\",\\r\\n\\r\\n    // What buttons should appear in the top right corner.\\r\\n    // Buttons will be created using templates from `btnTpl` option\\r\\n    // and they will be placed into toolbar (class=\"fancybox-toolbar\"` element)\\r\\n    buttons: [\\r\\n      \"zoom\",\\r\\n      //\"share\",\\r\\n      \"slideShow\",\\r\\n      //\"fullScreen\",\\r\\n      //\"download\",\\r\\n      \"thumbs\",\\r\\n      \"close\"\\r\\n    ],\\r\\n\\r\\n    // Detect \"idle\" time in seconds\\r\\n    idleTime: 3,\\r\\n\\r\\n    // Disable right-click and use simple image protection for images\\r\\n    protect: false,\\r\\n\\r\\n    // Shortcut to make content \"modal\" - disable keyboard navigtion, hide buttons, etc\\r\\n    modal: false,\\r\\n\\r\\n    image: {\\r\\n      // Wait for images to load before displaying\\r\\n      //   true  - wait for image to load and then display;\\r\\n      //   false - display thumbnail and load the full-sized image over top,\\r\\n      //           requires predefined image dimensions (`data-width` and `data-height` attributes)\\r\\n      preload: false\\r\\n    },\\r\\n\\r\\n    ajax: {\\r\\n      // Object containing settings for ajax request\\r\\n      settings: {\\r\\n        // This helps to indicate that request comes from the modal\\r\\n        // Feel free to change naming\\r\\n        data: {\\r\\n          fancybox: true\\r\\n        }\\r\\n      }\\r\\n    },\\r\\n\\r\\n    iframe: {\\r\\n      // Iframe template\\r\\n      tpl:\\r\\n        \\'<iframe id=\"fancybox-frame{rnd}\" name=\"fancybox-frame{rnd}\" class=\"fancybox-iframe\" allowfullscreen=\"allowfullscreen\" allow=\"autoplay; fullscreen\" src=\"\"></iframe>\\',\\r\\n\\r\\n      // Preload iframe before displaying it\\r\\n      // This allows to calculate iframe content width and height\\r\\n      // (note: Due to \"Same Origin Policy\", you can\\'t get cross domain data).\\r\\n      preload: true,\\r\\n\\r\\n      // Custom CSS styling for iframe wrapping element\\r\\n      // You can use this to set custom iframe dimensions\\r\\n      css: {},\\r\\n\\r\\n      // Iframe tag attributes\\r\\n      attr: {\\r\\n        scrolling: \"auto\"\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // For HTML5 video only\\r\\n    video: {\\r\\n      tpl:\\r\\n        \\'<video class=\"fancybox-video\" controls controlsList=\"nodownload\" poster=\"{{poster}}\">\\' +\\r\\n        \\'<source src=\"{{src}}\" type=\"{{format}}\" />\\' +\\r\\n        \\'Sorry, your browser doesn\\\\\\'t support embedded videos, <a href=\"{{src}}\">download</a> and watch with your favorite video player!\\' +\\r\\n        \"</video>\",\\r\\n      format: \"\", // custom video format\\r\\n      autoStart: true\\r\\n    },\\r\\n\\r\\n    // Default content type if cannot be detected automatically\\r\\n    defaultType: \"image\",\\r\\n\\r\\n    // Open/close animation type\\r\\n    // Possible values:\\r\\n    //   false            - disable\\r\\n    //   \"zoom\"           - zoom images from/to thumbnail\\r\\n    //   \"fade\"\\r\\n    //   \"zoom-in-out\"\\r\\n    //\\r\\n    animationEffect: \"zoom\",\\r\\n\\r\\n    // Duration in ms for open/close animation\\r\\n    animationDuration: 366,\\r\\n\\r\\n    // Should image change opacity while zooming\\r\\n    // If opacity is \"auto\", then opacity will be changed if image and thumbnail have different aspect ratios\\r\\n    zoomOpacity: \"auto\",\\r\\n\\r\\n    // Transition effect between slides\\r\\n    //\\r\\n    // Possible values:\\r\\n    //   false            - disable\\r\\n    //   \"fade\\'\\r\\n    //   \"slide\\'\\r\\n    //   \"circular\\'\\r\\n    //   \"tube\\'\\r\\n    //   \"zoom-in-out\\'\\r\\n    //   \"rotate\\'\\r\\n    //\\r\\n    transitionEffect: \"fade\",\\r\\n\\r\\n    // Duration in ms for transition animation\\r\\n    transitionDuration: 366,\\r\\n\\r\\n    // Custom CSS class for slide element\\r\\n    slideClass: \"\",\\r\\n\\r\\n    // Custom CSS class for layout\\r\\n    baseClass: \"\",\\r\\n\\r\\n    // Base template for layout\\r\\n    baseTpl:\\r\\n      \\'<div class=\"fancybox-container\" role=\"dialog\" tabindex=\"-1\">\\' +\\r\\n      \\'<div class=\"fancybox-bg\"></div>\\' +\\r\\n      \\'<div class=\"fancybox-inner\">\\' +\\r\\n      \\'<div class=\"fancybox-infobar\"><span data-fancybox-index></span>&nbsp;/&nbsp;<span data-fancybox-count></span></div>\\' +\\r\\n      \\'<div class=\"fancybox-toolbar\">{{buttons}}</div>\\' +\\r\\n      \\'<div class=\"fancybox-navigation\">{{arrows}}</div>\\' +\\r\\n      \\'<div class=\"fancybox-stage\"></div>\\' +\\r\\n      \\'<div class=\"fancybox-caption\"><div class=\"fancybox-caption__body\"></div></div>\\' +\\r\\n      \"</div>\" +\\r\\n      \"</div>\",\\r\\n\\r\\n    // Loading indicator template\\r\\n    spinnerTpl: \\'<div class=\"fancybox-loading\"></div>\\',\\r\\n\\r\\n    // Error message template\\r\\n    errorTpl: \\'<div class=\"fancybox-error\"><p>{{ERROR}}</p></div>\\',\\r\\n\\r\\n    btnTpl: {\\r\\n      download:\\r\\n        \\'<a download data-fancybox-download class=\"fancybox-button fancybox-button--download\" title=\"{{DOWNLOAD}}\" href=\"javascript:;\">\\' +\\r\\n        \\'<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M18.62 17.09V19H5.38v-1.91zm-2.97-6.96L17 11.45l-5 4.87-5-4.87 1.36-1.32 2.68 2.64V5h1.92v7.77z\"/></svg>\\' +\\r\\n        \"</a>\",\\r\\n\\r\\n      zoom:\\r\\n        \\'<button data-fancybox-zoom class=\"fancybox-button fancybox-button--zoom\" title=\"{{ZOOM}}\">\\' +\\r\\n        \\'<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M18.7 17.3l-3-3a5.9 5.9 0 0 0-.6-7.6 5.9 5.9 0 0 0-8.4 0 5.9 5.9 0 0 0 0 8.4 5.9 5.9 0 0 0 7.7.7l3 3a1 1 0 0 0 1.3 0c.4-.5.4-1 0-1.5zM8.1 13.8a4 4 0 0 1 0-5.7 4 4 0 0 1 5.7 0 4 4 0 0 1 0 5.7 4 4 0 0 1-5.7 0z\"/></svg>\\' +\\r\\n        \"</button>\",\\r\\n\\r\\n      close:\\r\\n        \\'<button data-fancybox-close class=\"fancybox-button fancybox-button--close\" title=\"{{CLOSE}}\">\\' +\\r\\n        \\'<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M12 10.6L6.6 5.2 5.2 6.6l5.4 5.4-5.4 5.4 1.4 1.4 5.4-5.4 5.4 5.4 1.4-1.4-5.4-5.4 5.4-5.4-1.4-1.4-5.4 5.4z\"/></svg>\\' +\\r\\n        \"</button>\",\\r\\n\\r\\n      // Arrows\\r\\n      arrowLeft:\\r\\n        \\'<button data-fancybox-prev class=\"fancybox-button fancybox-button--arrow_left\" title=\"{{PREV}}\">\\' +\\r\\n        \\'<div><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M11.28 15.7l-1.34 1.37L5 12l4.94-5.07 1.34 1.38-2.68 2.72H19v1.94H8.6z\"/></svg></div>\\' +\\r\\n        \"</button>\",\\r\\n\\r\\n      arrowRight:\\r\\n        \\'<button data-fancybox-next class=\"fancybox-button fancybox-button--arrow_right\" title=\"{{NEXT}}\">\\' +\\r\\n        \\'<div><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M15.4 12.97l-2.68 2.72 1.34 1.38L19 12l-4.94-5.07-1.34 1.38 2.68 2.72H5v1.94z\"/></svg></div>\\' +\\r\\n        \"</button>\",\\r\\n\\r\\n      // This small close button will be appended to your html/inline/ajax content by default,\\r\\n      // if \"smallBtn\" option is not set to false\\r\\n      smallBtn:\\r\\n        \\'<button type=\"button\" data-fancybox-close class=\"fancybox-button fancybox-close-small\" title=\"{{CLOSE}}\">\\' +\\r\\n        \\'<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1\" viewBox=\"0 0 24 24\"><path d=\"M13 12l5-5-1-1-5 5-5-5-1 1 5 5-5 5 1 1 5-5 5 5 1-1z\"/></svg>\\' +\\r\\n        \"</button>\"\\r\\n    },\\r\\n\\r\\n    // Container is injected into this element\\r\\n    parentEl: \"body\",\\r\\n\\r\\n    // Hide browser vertical scrollbars; use at your own risk\\r\\n    hideScrollbar: true,\\r\\n\\r\\n    // Focus handling\\r\\n    // ==============\\r\\n\\r\\n    // Try to focus on the first focusable element after opening\\r\\n    autoFocus: true,\\r\\n\\r\\n    // Put focus back to active element after closing\\r\\n    backFocus: true,\\r\\n\\r\\n    // Do not let user to focus on element outside modal content\\r\\n    trapFocus: true,\\r\\n\\r\\n    // Module specific options\\r\\n    // =======================\\r\\n\\r\\n    fullScreen: {\\r\\n      autoStart: false\\r\\n    },\\r\\n\\r\\n    // Set `touch: false` to disable panning/swiping\\r\\n    touch: {\\r\\n      vertical: true, // Allow to drag content vertically\\r\\n      momentum: true // Continue movement after releasing mouse/touch when panning\\r\\n    },\\r\\n\\r\\n    // Hash value when initializing manually,\\r\\n    // set `false` to disable hash change\\r\\n    hash: null,\\r\\n\\r\\n    // Customize or add new media types\\r\\n    // Example:\\r\\n    /*\\r\\n      media : {\\r\\n        youtube : {\\r\\n          params : {\\r\\n            autoplay : 0\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    */\\r\\n    media: {},\\r\\n\\r\\n    slideShow: {\\r\\n      autoStart: false,\\r\\n      speed: 3000\\r\\n    },\\r\\n\\r\\n    thumbs: {\\r\\n      autoStart: false, // Display thumbnails on opening\\r\\n      hideOnClose: true, // Hide thumbnail grid when closing animation starts\\r\\n      parentEl: \".fancybox-container\", // Container is injected into this element\\r\\n      axis: \"y\" // Vertical (y) or horizontal (x) scrolling\\r\\n    },\\r\\n\\r\\n    // Use mousewheel to navigate gallery\\r\\n    // If \\'auto\\' - enabled for images only\\r\\n    wheel: \"auto\",\\r\\n\\r\\n    // Callbacks\\r\\n    //==========\\r\\n\\r\\n    // See Documentation/API/Events for more information\\r\\n    // Example:\\r\\n    /*\\r\\n      afterShow: function( instance, current ) {\\r\\n        console.info( \\'Clicked element:\\' );\\r\\n        console.info( current.opts.$orig );\\r\\n      }\\r\\n    */\\r\\n\\r\\n    onInit: $.noop, // When instance has been initialized\\r\\n\\r\\n    beforeLoad: $.noop, // Before the content of a slide is being loaded\\r\\n    afterLoad: $.noop, // When the content of a slide is done loading\\r\\n\\r\\n    beforeShow: $.noop, // Before open animation starts\\r\\n    afterShow: $.noop, // When content is done loading and animating\\r\\n\\r\\n    beforeClose: $.noop, // Before the instance attempts to close. Return false to cancel the close.\\r\\n    afterClose: $.noop, // After instance has been closed\\r\\n\\r\\n    onActivate: $.noop, // When instance is brought to front\\r\\n    onDeactivate: $.noop, // When other instance has been activated\\r\\n\\r\\n    // Interaction\\r\\n    // ===========\\r\\n\\r\\n    // Use options below to customize taken action when user clicks or double clicks on the fancyBox area,\\r\\n    // each option can be string or method that returns value.\\r\\n    //\\r\\n    // Possible values:\\r\\n    //   \"close\"           - close instance\\r\\n    //   \"next\"            - move to next gallery item\\r\\n    //   \"nextOrClose\"     - move to next gallery item or close if gallery has only one item\\r\\n    //   \"toggleControls\"  - show/hide controls\\r\\n    //   \"zoom\"            - zoom image (if loaded)\\r\\n    //   false             - do nothing\\r\\n\\r\\n    // Clicked on the content\\r\\n    clickContent: function(current, event) {\\r\\n      return current.type === \"image\" ? \"zoom\" : false;\\r\\n    },\\r\\n\\r\\n    // Clicked on the slide\\r\\n    clickSlide: \"close\",\\r\\n\\r\\n    // Clicked on the background (backdrop) element;\\r\\n    // if you have not changed the layout, then most likely you need to use `clickSlide` option\\r\\n    clickOutside: \"close\",\\r\\n\\r\\n    // Same as previous two, but for double click\\r\\n    dblclickContent: false,\\r\\n    dblclickSlide: false,\\r\\n    dblclickOutside: false,\\r\\n\\r\\n    // Custom options when mobile device is detected\\r\\n    // =============================================\\r\\n\\r\\n    mobile: {\\r\\n      preventCaptionOverlap: false,\\r\\n      idleTime: false,\\r\\n      clickContent: function(current, event) {\\r\\n        return current.type === \"image\" ? \"toggleControls\" : false;\\r\\n      },\\r\\n      clickSlide: function(current, event) {\\r\\n        return current.type === \"image\" ? \"toggleControls\" : \"close\";\\r\\n      },\\r\\n      dblclickContent: function(current, event) {\\r\\n        return current.type === \"image\" ? \"zoom\" : false;\\r\\n      },\\r\\n      dblclickSlide: function(current, event) {\\r\\n        return current.type === \"image\" ? \"zoom\" : false;\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Internationalization\\r\\n    // ====================\\r\\n\\r\\n    lang: \"en\",\\r\\n    i18n: {\\r\\n      en: {\\r\\n        CLOSE: \"Close\",\\r\\n        NEXT: \"Next\",\\r\\n        PREV: \"Previous\",\\r\\n        ERROR: \"The requested content cannot be loaded. <br/> Please try again later.\",\\r\\n        PLAY_START: \"Start slideshow\",\\r\\n        PLAY_STOP: \"Pause slideshow\",\\r\\n        FULL_SCREEN: \"Full screen\",\\r\\n        THUMBS: \"Thumbnails\",\\r\\n        DOWNLOAD: \"Download\",\\r\\n        SHARE: \"Share\",\\r\\n        ZOOM: \"Zoom\"\\r\\n      },\\r\\n      de: {\\r\\n        CLOSE: \"Schlie&szlig;en\",\\r\\n        NEXT: \"Weiter\",\\r\\n        PREV: \"Zur&uuml;ck\",\\r\\n        ERROR: \"Die angeforderten Daten konnten nicht geladen werden. <br/> Bitte versuchen Sie es sp&auml;ter nochmal.\",\\r\\n        PLAY_START: \"Diaschau starten\",\\r\\n        PLAY_STOP: \"Diaschau beenden\",\\r\\n        FULL_SCREEN: \"Vollbild\",\\r\\n        THUMBS: \"Vorschaubilder\",\\r\\n        DOWNLOAD: \"Herunterladen\",\\r\\n        SHARE: \"Teilen\",\\r\\n        ZOOM: \"Vergr&ouml;&szlig;ern\"\\r\\n      }\\r\\n    }\\r\\n  };\\r\\n\\r\\n  // Few useful variables and methods\\r\\n  // ================================\\r\\n\\r\\n  var $W = $(window);\\r\\n  var $D = $(document);\\r\\n\\r\\n  var called = 0;\\r\\n\\r\\n  // Check if an object is a jQuery object and not a native JavaScript object\\r\\n  // ========================================================================\\r\\n  var isQuery = function(obj) {\\r\\n    return obj && obj.hasOwnProperty && obj instanceof $;\\r\\n  };\\r\\n\\r\\n  // Handle multiple browsers for \"requestAnimationFrame\" and \"cancelAnimationFrame\"\\r\\n  // ===============================================================================\\r\\n  var requestAFrame = (function() {\\r\\n    return (\\r\\n      window.requestAnimationFrame ||\\r\\n      window.webkitRequestAnimationFrame ||\\r\\n      window.mozRequestAnimationFrame ||\\r\\n      window.oRequestAnimationFrame ||\\r\\n      // if all else fails, use setTimeout\\r\\n      function(callback) {\\r\\n        return window.setTimeout(callback, 1000 / 60);\\r\\n      }\\r\\n    );\\r\\n  })();\\r\\n\\r\\n  var cancelAFrame = (function() {\\r\\n    return (\\r\\n      window.cancelAnimationFrame ||\\r\\n      window.webkitCancelAnimationFrame ||\\r\\n      window.mozCancelAnimationFrame ||\\r\\n      window.oCancelAnimationFrame ||\\r\\n      function(id) {\\r\\n        window.clearTimeout(id);\\r\\n      }\\r\\n    );\\r\\n  })();\\r\\n\\r\\n  // Detect the supported transition-end event property name\\r\\n  // =======================================================\\r\\n  var transitionEnd = (function() {\\r\\n    var el = document.createElement(\"fakeelement\"),\\r\\n      t;\\r\\n\\r\\n    var transitions = {\\r\\n      transition: \"transitionend\",\\r\\n      OTransition: \"oTransitionEnd\",\\r\\n      MozTransition: \"transitionend\",\\r\\n      WebkitTransition: \"webkitTransitionEnd\"\\r\\n    };\\r\\n\\r\\n    for (t in transitions) {\\r\\n      if (el.style[t] !== undefined) {\\r\\n        return transitions[t];\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return \"transitionend\";\\r\\n  })();\\r\\n\\r\\n  // Force redraw on an element.\\r\\n  // This helps in cases where the browser doesn\\'t redraw an updated element properly\\r\\n  // ================================================================================\\r\\n  var forceRedraw = function($el) {\\r\\n    return $el && $el.length && $el[0].offsetHeight;\\r\\n  };\\r\\n\\r\\n  // Exclude array (`buttons`) options from deep merging\\r\\n  // ===================================================\\r\\n  var mergeOpts = function(opts1, opts2) {\\r\\n    var rez = $.extend(true, {}, opts1, opts2);\\r\\n\\r\\n    $.each(opts2, function(key, value) {\\r\\n      if ($.isArray(value)) {\\r\\n        rez[key] = value;\\r\\n      }\\r\\n    });\\r\\n\\r\\n    return rez;\\r\\n  };\\r\\n\\r\\n  // How much of an element is visible in viewport\\r\\n  // =============================================\\r\\n\\r\\n  var inViewport = function(elem) {\\r\\n    var elemCenter, rez;\\r\\n\\r\\n    if (!elem || elem.ownerDocument !== document) {\\r\\n      return false;\\r\\n    }\\r\\n\\r\\n    $(\".fancybox-container\").css(\"pointer-events\", \"none\");\\r\\n\\r\\n    elemCenter = {\\r\\n      x: elem.getBoundingClientRect().left + elem.offsetWidth / 2,\\r\\n      y: elem.getBoundingClientRect().top + elem.offsetHeight / 2\\r\\n    };\\r\\n\\r\\n    rez = document.elementFromPoint(elemCenter.x, elemCenter.y) === elem;\\r\\n\\r\\n    $(\".fancybox-container\").css(\"pointer-events\", \"\");\\r\\n\\r\\n    return rez;\\r\\n  };\\r\\n\\r\\n  // Class definition\\r\\n  // ================\\r\\n\\r\\n  var FancyBox = function(content, opts, index) {\\r\\n    var self = this;\\r\\n\\r\\n    self.opts = mergeOpts({index: index}, $.fancybox.defaults);\\r\\n\\r\\n    if ($.isPlainObject(opts)) {\\r\\n      self.opts = mergeOpts(self.opts, opts);\\r\\n    }\\r\\n\\r\\n    if ($.fancybox.isMobile) {\\r\\n      self.opts = mergeOpts(self.opts, self.opts.mobile);\\r\\n    }\\r\\n\\r\\n    self.id = self.opts.id || ++called;\\r\\n\\r\\n    self.currIndex = parseInt(self.opts.index, 10) || 0;\\r\\n    self.prevIndex = null;\\r\\n\\r\\n    self.prevPos = null;\\r\\n    self.currPos = 0;\\r\\n\\r\\n    self.firstRun = true;\\r\\n\\r\\n    // All group items\\r\\n    self.group = [];\\r\\n\\r\\n    // Existing slides (for current, next and previous gallery items)\\r\\n    self.slides = {};\\r\\n\\r\\n    // Create group elements\\r\\n    self.addContent(content);\\r\\n\\r\\n    if (!self.group.length) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    self.init();\\r\\n  };\\r\\n\\r\\n  $.extend(FancyBox.prototype, {\\r\\n    // Create DOM structure\\r\\n    // ====================\\r\\n\\r\\n    init: function() {\\r\\n      var self = this,\\r\\n        firstItem = self.group[self.currIndex],\\r\\n        firstItemOpts = firstItem.opts,\\r\\n        $container,\\r\\n        buttonStr;\\r\\n\\r\\n      if (firstItemOpts.closeExisting) {\\r\\n        $.fancybox.close(true);\\r\\n      }\\r\\n\\r\\n      // Hide scrollbars\\r\\n      // ===============\\r\\n\\r\\n      $(\"body\").addClass(\"fancybox-active\");\\r\\n\\r\\n      if (\\r\\n        !$.fancybox.getInstance() &&\\r\\n        firstItemOpts.hideScrollbar !== false &&\\r\\n        !$.fancybox.isMobile &&\\r\\n        document.body.scrollHeight > window.innerHeight\\r\\n      ) {\\r\\n        $(\"head\").append(\\r\\n          \\'<style id=\"fancybox-style-noscroll\" type=\"text/css\">.compensate-for-scrollbar{margin-right:\\' +\\r\\n            (window.innerWidth - document.documentElement.clientWidth) +\\r\\n            \"px;}</style>\"\\r\\n        );\\r\\n\\r\\n        $(\"body\").addClass(\"compensate-for-scrollbar\");\\r\\n      }\\r\\n\\r\\n      // Build html markup and set references\\r\\n      // ====================================\\r\\n\\r\\n      // Build html code for buttons and insert into main template\\r\\n      buttonStr = \"\";\\r\\n\\r\\n      $.each(firstItemOpts.buttons, function(index, value) {\\r\\n        buttonStr += firstItemOpts.btnTpl[value] || \"\";\\r\\n      });\\r\\n\\r\\n      // Create markup from base template, it will be initially hidden to\\r\\n      // avoid unnecessary work like painting while initializing is not complete\\r\\n      $container = $(\\r\\n        self.translate(\\r\\n          self,\\r\\n          firstItemOpts.baseTpl\\r\\n            .replace(\"{{buttons}}\", buttonStr)\\r\\n            .replace(\"{{arrows}}\", firstItemOpts.btnTpl.arrowLeft + firstItemOpts.btnTpl.arrowRight)\\r\\n        )\\r\\n      )\\r\\n        .attr(\"id\", \"fancybox-container-\" + self.id)\\r\\n        .addClass(firstItemOpts.baseClass)\\r\\n        .data(\"FancyBox\", self)\\r\\n        .appendTo(firstItemOpts.parentEl);\\r\\n\\r\\n      // Create object holding references to jQuery wrapped nodes\\r\\n      self.$refs = {\\r\\n        container: $container\\r\\n      };\\r\\n\\r\\n      [\"bg\", \"inner\", \"infobar\", \"toolbar\", \"stage\", \"caption\", \"navigation\"].forEach(function(item) {\\r\\n        self.$refs[item] = $container.find(\".fancybox-\" + item);\\r\\n      });\\r\\n\\r\\n      self.trigger(\"onInit\");\\r\\n\\r\\n      // Enable events, deactive previous instances\\r\\n      self.activate();\\r\\n\\r\\n      // Build slides, load and reveal content\\r\\n      self.jumpTo(self.currIndex);\\r\\n    },\\r\\n\\r\\n    // Simple i18n support - replaces object keys found in template\\r\\n    // with corresponding values\\r\\n    // ============================================================\\r\\n\\r\\n    translate: function(obj, str) {\\r\\n      var arr = obj.opts.i18n[obj.opts.lang] || obj.opts.i18n.en;\\r\\n\\r\\n      return str.replace(/\\\\{\\\\{(\\\\w+)\\\\}\\\\}/g, function(match, n) {\\r\\n        return arr[n] === undefined ? match : arr[n];\\r\\n      });\\r\\n    },\\r\\n\\r\\n    // Populate current group with fresh content\\r\\n    // Check if each object has valid type and content\\r\\n    // ===============================================\\r\\n\\r\\n    addContent: function(content) {\\r\\n      var self = this,\\r\\n        items = $.makeArray(content),\\r\\n        thumbs;\\r\\n\\r\\n      $.each(items, function(i, item) {\\r\\n        var obj = {},\\r\\n          opts = {},\\r\\n          $item,\\r\\n          type,\\r\\n          found,\\r\\n          src,\\r\\n          srcParts;\\r\\n\\r\\n        // Step 1 - Make sure we have an object\\r\\n        // ====================================\\r\\n\\r\\n        if ($.isPlainObject(item)) {\\r\\n          // We probably have manual usage here, something like\\r\\n          // $.fancybox.open( [ { src : \"image.jpg\", type : \"image\" } ] )\\r\\n\\r\\n          obj = item;\\r\\n          opts = item.opts || item;\\r\\n        } else if ($.type(item) === \"object\" && $(item).length) {\\r\\n          // Here we probably have jQuery collection returned by some selector\\r\\n          $item = $(item);\\r\\n\\r\\n          // Support attributes like `data-options=\\'{\"touch\" : false}\\'` and `data-touch=\\'false\\'`\\r\\n          opts = $item.data() || {};\\r\\n          opts = $.extend(true, {}, opts, opts.options);\\r\\n\\r\\n          // Here we store clicked element\\r\\n          opts.$orig = $item;\\r\\n\\r\\n          obj.src = self.opts.src || opts.src || $item.attr(\"href\");\\r\\n\\r\\n          // Assume that simple syntax is used, for example:\\r\\n          //   `$.fancybox.open( $(\"#test\"), {} );`\\r\\n          if (!obj.type && !obj.src) {\\r\\n            obj.type = \"inline\";\\r\\n            obj.src = item;\\r\\n          }\\r\\n        } else {\\r\\n          // Assume we have a simple html code, for example:\\r\\n          //   $.fancybox.open( \\'<div><h1>Hi!</h1></div>\\' );\\r\\n          obj = {\\r\\n            type: \"html\",\\r\\n            src: item + \"\"\\r\\n          };\\r\\n        }\\r\\n\\r\\n        // Each gallery object has full collection of options\\r\\n        obj.opts = $.extend(true, {}, self.opts, opts);\\r\\n\\r\\n        // Do not merge buttons array\\r\\n        if ($.isArray(opts.buttons)) {\\r\\n          obj.opts.buttons = opts.buttons;\\r\\n        }\\r\\n\\r\\n        if ($.fancybox.isMobile && obj.opts.mobile) {\\r\\n          obj.opts = mergeOpts(obj.opts, obj.opts.mobile);\\r\\n        }\\r\\n\\r\\n        // Step 2 - Make sure we have content type, if not - try to guess\\r\\n        // ==============================================================\\r\\n\\r\\n        type = obj.type || obj.opts.type;\\r\\n        src = obj.src || \"\";\\r\\n\\r\\n        if (!type && src) {\\r\\n          if ((found = src.match(/\\\\.(mp4|mov|ogv|webm)((\\\\?|#).*)?$/i))) {\\r\\n            type = \"video\";\\r\\n\\r\\n            if (!obj.opts.video.format) {\\r\\n              obj.opts.video.format = \"video/\" + (found[1] === \"ogv\" ? \"ogg\" : found[1]);\\r\\n            }\\r\\n          } else if (src.match(/(^data:image\\\\/[a-z0-9+\\\\/=]*,)|(\\\\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\\\\?|#).*)?$)/i)) {\\r\\n            type = \"image\";\\r\\n          } else if (src.match(/\\\\.(pdf)((\\\\?|#).*)?$/i)) {\\r\\n            type = \"iframe\";\\r\\n            obj = $.extend(true, obj, {contentType: \"pdf\", opts: {iframe: {preload: false}}});\\r\\n          } else if (src.charAt(0) === \"#\") {\\r\\n            type = \"inline\";\\r\\n          }\\r\\n        }\\r\\n\\r\\n        if (type) {\\r\\n          obj.type = type;\\r\\n        } else {\\r\\n          self.trigger(\"objectNeedsType\", obj);\\r\\n        }\\r\\n\\r\\n        if (!obj.contentType) {\\r\\n          obj.contentType = $.inArray(obj.type, [\"html\", \"inline\", \"ajax\"]) > -1 ? \"html\" : obj.type;\\r\\n        }\\r\\n\\r\\n        // Step 3 - Some adjustments\\r\\n        // =========================\\r\\n\\r\\n        obj.index = self.group.length;\\r\\n\\r\\n        if (obj.opts.smallBtn == \"auto\") {\\r\\n          obj.opts.smallBtn = $.inArray(obj.type, [\"html\", \"inline\", \"ajax\"]) > -1;\\r\\n        }\\r\\n\\r\\n        if (obj.opts.toolbar === \"auto\") {\\r\\n          obj.opts.toolbar = !obj.opts.smallBtn;\\r\\n        }\\r\\n\\r\\n        // Find thumbnail image, check if exists and if is in the viewport\\r\\n        obj.$thumb = obj.opts.$thumb || null;\\r\\n\\r\\n        if (obj.opts.$trigger && obj.index === self.opts.index) {\\r\\n          obj.$thumb = obj.opts.$trigger.find(\"img:first\");\\r\\n\\r\\n          if (obj.$thumb.length) {\\r\\n            obj.opts.$orig = obj.opts.$trigger;\\r\\n          }\\r\\n        }\\r\\n\\r\\n        if (!(obj.$thumb && obj.$thumb.length) && obj.opts.$orig) {\\r\\n          obj.$thumb = obj.opts.$orig.find(\"img:first\");\\r\\n        }\\r\\n\\r\\n        if (obj.$thumb && !obj.$thumb.length) {\\r\\n          obj.$thumb = null;\\r\\n        }\\r\\n\\r\\n        obj.thumb = obj.opts.thumb || (obj.$thumb ? obj.$thumb[0].src : null);\\r\\n\\r\\n        // \"caption\" is a \"special\" option, it can be used to customize caption per gallery item\\r\\n        if ($.type(obj.opts.caption) === \"function\") {\\r\\n          obj.opts.caption = obj.opts.caption.apply(item, [self, obj]);\\r\\n        }\\r\\n\\r\\n        if ($.type(self.opts.caption) === \"function\") {\\r\\n          obj.opts.caption = self.opts.caption.apply(item, [self, obj]);\\r\\n        }\\r\\n\\r\\n        // Make sure we have caption as a string or jQuery object\\r\\n        if (!(obj.opts.caption instanceof $)) {\\r\\n          obj.opts.caption = obj.opts.caption === undefined ? \"\" : obj.opts.caption + \"\";\\r\\n        }\\r\\n\\r\\n        // Check if url contains \"filter\" used to filter the content\\r\\n        // Example: \"ajax.html #something\"\\r\\n        if (obj.type === \"ajax\") {\\r\\n          srcParts = src.split(/\\\\s+/, 2);\\r\\n\\r\\n          if (srcParts.length > 1) {\\r\\n            obj.src = srcParts.shift();\\r\\n\\r\\n            obj.opts.filter = srcParts.shift();\\r\\n          }\\r\\n        }\\r\\n\\r\\n        // Hide all buttons and disable interactivity for modal items\\r\\n        if (obj.opts.modal) {\\r\\n          obj.opts = $.extend(true, obj.opts, {\\r\\n            trapFocus: true,\\r\\n            // Remove buttons\\r\\n            infobar: 0,\\r\\n            toolbar: 0,\\r\\n\\r\\n            smallBtn: 0,\\r\\n\\r\\n            // Disable keyboard navigation\\r\\n            keyboard: 0,\\r\\n\\r\\n            // Disable some modules\\r\\n            slideShow: 0,\\r\\n            fullScreen: 0,\\r\\n            thumbs: 0,\\r\\n            touch: 0,\\r\\n\\r\\n            // Disable click event handlers\\r\\n            clickContent: false,\\r\\n            clickSlide: false,\\r\\n            clickOutside: false,\\r\\n            dblclickContent: false,\\r\\n            dblclickSlide: false,\\r\\n            dblclickOutside: false\\r\\n          });\\r\\n        }\\r\\n\\r\\n        // Step 4 - Add processed object to group\\r\\n        // ======================================\\r\\n\\r\\n        self.group.push(obj);\\r\\n      });\\r\\n\\r\\n      // Update controls if gallery is already opened\\r\\n      if (Object.keys(self.slides).length) {\\r\\n        self.updateControls();\\r\\n\\r\\n        // Update thumbnails, if needed\\r\\n        thumbs = self.Thumbs;\\r\\n\\r\\n        if (thumbs && thumbs.isActive) {\\r\\n          thumbs.create();\\r\\n\\r\\n          thumbs.focus();\\r\\n        }\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Attach an event handler functions for:\\r\\n    //   - navigation buttons\\r\\n    //   - browser scrolling, resizing;\\r\\n    //   - focusing\\r\\n    //   - keyboard\\r\\n    //   - detecting inactivity\\r\\n    // ======================================\\r\\n\\r\\n    addEvents: function() {\\r\\n      var self = this;\\r\\n\\r\\n      self.removeEvents();\\r\\n\\r\\n      // Make navigation elements clickable\\r\\n      // ==================================\\r\\n\\r\\n      self.$refs.container\\r\\n        .on(\"click.fb-close\", \"[data-fancybox-close]\", function(e) {\\r\\n          e.stopPropagation();\\r\\n          e.preventDefault();\\r\\n\\r\\n          self.close(e);\\r\\n        })\\r\\n        .on(\"touchstart.fb-prev click.fb-prev\", \"[data-fancybox-prev]\", function(e) {\\r\\n          e.stopPropagation();\\r\\n          e.preventDefault();\\r\\n\\r\\n          self.previous();\\r\\n        })\\r\\n        .on(\"touchstart.fb-next click.fb-next\", \"[data-fancybox-next]\", function(e) {\\r\\n          e.stopPropagation();\\r\\n          e.preventDefault();\\r\\n\\r\\n          self.next();\\r\\n        })\\r\\n        .on(\"click.fb\", \"[data-fancybox-zoom]\", function(e) {\\r\\n          // Click handler for zoom button\\r\\n          self[self.isScaledDown() ? \"scaleToActual\" : \"scaleToFit\"]();\\r\\n        });\\r\\n\\r\\n      // Handle page scrolling and browser resizing\\r\\n      // ==========================================\\r\\n\\r\\n      $W.on(\"orientationchange.fb resize.fb\", function(e) {\\r\\n        if (e && e.originalEvent && e.originalEvent.type === \"resize\") {\\r\\n          if (self.requestId) {\\r\\n            cancelAFrame(self.requestId);\\r\\n          }\\r\\n\\r\\n          self.requestId = requestAFrame(function() {\\r\\n            self.update(e);\\r\\n          });\\r\\n        } else {\\r\\n          if (self.current && self.current.type === \"iframe\") {\\r\\n            self.$refs.stage.hide();\\r\\n          }\\r\\n\\r\\n          setTimeout(\\r\\n            function() {\\r\\n              self.$refs.stage.show();\\r\\n\\r\\n              self.update(e);\\r\\n            },\\r\\n            $.fancybox.isMobile ? 600 : 250\\r\\n          );\\r\\n        }\\r\\n      });\\r\\n\\r\\n      $D.on(\"keydown.fb\", function(e) {\\r\\n        var instance = $.fancybox ? $.fancybox.getInstance() : null,\\r\\n          current = instance.current,\\r\\n          keycode = e.keyCode || e.which;\\r\\n\\r\\n        // Trap keyboard focus inside of the modal\\r\\n        // =======================================\\r\\n\\r\\n        if (keycode == 9) {\\r\\n          if (current.opts.trapFocus) {\\r\\n            self.focus(e);\\r\\n          }\\r\\n\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        // Enable keyboard navigation\\r\\n        // ==========================\\r\\n\\r\\n        if (!current.opts.keyboard || e.ctrlKey || e.altKey || e.shiftKey || $(e.target).is(\"input,textarea,video,audio\")) {\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        // Backspace and Esc keys\\r\\n        if (keycode === 8 || keycode === 27) {\\r\\n          e.preventDefault();\\r\\n\\r\\n          self.close(e);\\r\\n\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        // Left arrow and Up arrow\\r\\n        if (keycode === 37 || keycode === 38) {\\r\\n          e.preventDefault();\\r\\n\\r\\n          self.previous();\\r\\n\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        // Righ arrow and Down arrow\\r\\n        if (keycode === 39 || keycode === 40) {\\r\\n          e.preventDefault();\\r\\n\\r\\n          self.next();\\r\\n\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        self.trigger(\"afterKeydown\", e, keycode);\\r\\n      });\\r\\n\\r\\n      // Hide controls after some inactivity period\\r\\n      if (self.group[self.currIndex].opts.idleTime) {\\r\\n        self.idleSecondsCounter = 0;\\r\\n\\r\\n        $D.on(\\r\\n          \"mousemove.fb-idle mouseleave.fb-idle mousedown.fb-idle touchstart.fb-idle touchmove.fb-idle scroll.fb-idle keydown.fb-idle\",\\r\\n          function(e) {\\r\\n            self.idleSecondsCounter = 0;\\r\\n\\r\\n            if (self.isIdle) {\\r\\n              self.showControls();\\r\\n            }\\r\\n\\r\\n            self.isIdle = false;\\r\\n          }\\r\\n        );\\r\\n\\r\\n        self.idleInterval = window.setInterval(function() {\\r\\n          self.idleSecondsCounter++;\\r\\n\\r\\n          if (self.idleSecondsCounter >= self.group[self.currIndex].opts.idleTime && !self.isDragging) {\\r\\n            self.isIdle = true;\\r\\n            self.idleSecondsCounter = 0;\\r\\n\\r\\n            self.hideControls();\\r\\n          }\\r\\n        }, 1000);\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Remove events added by the core\\r\\n    // ===============================\\r\\n\\r\\n    removeEvents: function() {\\r\\n      var self = this;\\r\\n\\r\\n      $W.off(\"orientationchange.fb resize.fb\");\\r\\n      $D.off(\"keydown.fb .fb-idle\");\\r\\n\\r\\n      this.$refs.container.off(\".fb-close .fb-prev .fb-next\");\\r\\n\\r\\n      if (self.idleInterval) {\\r\\n        window.clearInterval(self.idleInterval);\\r\\n\\r\\n        self.idleInterval = null;\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Change to previous gallery item\\r\\n    // ===============================\\r\\n\\r\\n    previous: function(duration) {\\r\\n      return this.jumpTo(this.currPos - 1, duration);\\r\\n    },\\r\\n\\r\\n    // Change to next gallery item\\r\\n    // ===========================\\r\\n\\r\\n    next: function(duration) {\\r\\n      return this.jumpTo(this.currPos + 1, duration);\\r\\n    },\\r\\n\\r\\n    // Switch to selected gallery item\\r\\n    // ===============================\\r\\n\\r\\n    jumpTo: function(pos, duration) {\\r\\n      var self = this,\\r\\n        groupLen = self.group.length,\\r\\n        firstRun,\\r\\n        isMoved,\\r\\n        loop,\\r\\n        current,\\r\\n        previous,\\r\\n        slidePos,\\r\\n        stagePos,\\r\\n        prop,\\r\\n        diff;\\r\\n\\r\\n      if (self.isDragging || self.isClosing || (self.isAnimating && self.firstRun)) {\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      // Should loop?\\r\\n      pos = parseInt(pos, 10);\\r\\n      loop = self.current ? self.current.opts.loop : self.opts.loop;\\r\\n\\r\\n      if (!loop && (pos < 0 || pos >= groupLen)) {\\r\\n        return false;\\r\\n      }\\r\\n\\r\\n      // Check if opening for the first time; this helps to speed things up\\r\\n      firstRun = self.firstRun = !Object.keys(self.slides).length;\\r\\n\\r\\n      // Create slides\\r\\n      previous = self.current;\\r\\n\\r\\n      self.prevIndex = self.currIndex;\\r\\n      self.prevPos = self.currPos;\\r\\n\\r\\n      current = self.createSlide(pos);\\r\\n\\r\\n      if (groupLen > 1) {\\r\\n        if (loop || current.index < groupLen - 1) {\\r\\n          self.createSlide(pos + 1);\\r\\n        }\\r\\n\\r\\n        if (loop || current.index > 0) {\\r\\n          self.createSlide(pos - 1);\\r\\n        }\\r\\n      }\\r\\n\\r\\n      self.current = current;\\r\\n      self.currIndex = current.index;\\r\\n      self.currPos = current.pos;\\r\\n\\r\\n      self.trigger(\"beforeShow\", firstRun);\\r\\n\\r\\n      self.updateControls();\\r\\n\\r\\n      // Validate duration length\\r\\n      current.forcedDuration = undefined;\\r\\n\\r\\n      if ($.isNumeric(duration)) {\\r\\n        current.forcedDuration = duration;\\r\\n      } else {\\r\\n        duration = current.opts[firstRun ? \"animationDuration\" : \"transitionDuration\"];\\r\\n      }\\r\\n\\r\\n      duration = parseInt(duration, 10);\\r\\n\\r\\n      // Check if user has swiped the slides or if still animating\\r\\n      isMoved = self.isMoved(current);\\r\\n\\r\\n      // Make sure current slide is visible\\r\\n      current.$slide.addClass(\"fancybox-slide--current\");\\r\\n\\r\\n      // Fresh start - reveal container, current slide and start loading content\\r\\n      if (firstRun) {\\r\\n        if (current.opts.animationEffect && duration) {\\r\\n          self.$refs.container.css(\"transition-duration\", duration + \"ms\");\\r\\n        }\\r\\n\\r\\n        self.$refs.container.addClass(\"fancybox-is-open\").trigger(\"focus\");\\r\\n\\r\\n        // Attempt to load content into slide\\r\\n        // This will later call `afterLoad` -> `revealContent`\\r\\n        self.loadSlide(current);\\r\\n\\r\\n        self.preload(\"image\");\\r\\n\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      // Get actual slide/stage positions (before cleaning up)\\r\\n      slidePos = $.fancybox.getTranslate(previous.$slide);\\r\\n      stagePos = $.fancybox.getTranslate(self.$refs.stage);\\r\\n\\r\\n      // Clean up all slides\\r\\n      $.each(self.slides, function(index, slide) {\\r\\n        $.fancybox.stop(slide.$slide, true);\\r\\n      });\\r\\n\\r\\n      if (previous.pos !== current.pos) {\\r\\n        previous.isComplete = false;\\r\\n      }\\r\\n\\r\\n      previous.$slide.removeClass(\"fancybox-slide--complete fancybox-slide--current\");\\r\\n\\r\\n      // If slides are out of place, then animate them to correct position\\r\\n      if (isMoved) {\\r\\n        // Calculate horizontal swipe distance\\r\\n        diff = slidePos.left - (previous.pos * slidePos.width + previous.pos * previous.opts.gutter);\\r\\n\\r\\n        $.each(self.slides, function(index, slide) {\\r\\n          slide.$slide.removeClass(\"fancybox-animated\").removeClass(function(index, className) {\\r\\n            return (className.match(/(^|\\\\s)fancybox-fx-\\\\S+/g) || []).join(\" \");\\r\\n          });\\r\\n\\r\\n          // Make sure that each slide is in equal distance\\r\\n          // This is mostly needed for freshly added slides, because they are not yet positioned\\r\\n          var leftPos = slide.pos * slidePos.width + slide.pos * slide.opts.gutter;\\r\\n\\r\\n          $.fancybox.setTranslate(slide.$slide, {top: 0, left: leftPos - stagePos.left + diff});\\r\\n\\r\\n          if (slide.pos !== current.pos) {\\r\\n            slide.$slide.addClass(\"fancybox-slide--\" + (slide.pos > current.pos ? \"next\" : \"previous\"));\\r\\n          }\\r\\n\\r\\n          // Redraw to make sure that transition will start\\r\\n          forceRedraw(slide.$slide);\\r\\n\\r\\n          // Animate the slide\\r\\n          $.fancybox.animate(\\r\\n            slide.$slide,\\r\\n            {\\r\\n              top: 0,\\r\\n              left: (slide.pos - current.pos) * slidePos.width + (slide.pos - current.pos) * slide.opts.gutter\\r\\n            },\\r\\n            duration,\\r\\n            function() {\\r\\n              slide.$slide\\r\\n                .css({\\r\\n                  transform: \"\",\\r\\n                  opacity: \"\"\\r\\n                })\\r\\n                .removeClass(\"fancybox-slide--next fancybox-slide--previous\");\\r\\n\\r\\n              if (slide.pos === self.currPos) {\\r\\n                self.complete();\\r\\n              }\\r\\n            }\\r\\n          );\\r\\n        });\\r\\n      } else if (duration && current.opts.transitionEffect) {\\r\\n        // Set transition effect for previously active slide\\r\\n        prop = \"fancybox-animated fancybox-fx-\" + current.opts.transitionEffect;\\r\\n\\r\\n        previous.$slide.addClass(\"fancybox-slide--\" + (previous.pos > current.pos ? \"next\" : \"previous\"));\\r\\n\\r\\n        $.fancybox.animate(\\r\\n          previous.$slide,\\r\\n          prop,\\r\\n          duration,\\r\\n          function() {\\r\\n            previous.$slide.removeClass(prop).removeClass(\"fancybox-slide--next fancybox-slide--previous\");\\r\\n          },\\r\\n          false\\r\\n        );\\r\\n      }\\r\\n\\r\\n      if (current.isLoaded) {\\r\\n        self.revealContent(current);\\r\\n      } else {\\r\\n        self.loadSlide(current);\\r\\n      }\\r\\n\\r\\n      self.preload(\"image\");\\r\\n    },\\r\\n\\r\\n    // Create new \"slide\" element\\r\\n    // These are gallery items  that are actually added to DOM\\r\\n    // =======================================================\\r\\n\\r\\n    createSlide: function(pos) {\\r\\n      var self = this,\\r\\n        $slide,\\r\\n        index;\\r\\n\\r\\n      index = pos % self.group.length;\\r\\n      index = index < 0 ? self.group.length + index : index;\\r\\n\\r\\n      if (!self.slides[pos] && self.group[index]) {\\r\\n        $slide = $(\\'<div class=\"fancybox-slide\"></div>\\').appendTo(self.$refs.stage);\\r\\n\\r\\n        self.slides[pos] = $.extend(true, {}, self.group[index], {\\r\\n          pos: pos,\\r\\n          $slide: $slide,\\r\\n          isLoaded: false\\r\\n        });\\r\\n\\r\\n        self.updateSlide(self.slides[pos]);\\r\\n      }\\r\\n\\r\\n      return self.slides[pos];\\r\\n    },\\r\\n\\r\\n    // Scale image to the actual size of the image;\\r\\n    // x and y values should be relative to the slide\\r\\n    // ==============================================\\r\\n\\r\\n    scaleToActual: function(x, y, duration) {\\r\\n      var self = this,\\r\\n        current = self.current,\\r\\n        $content = current.$content,\\r\\n        canvasWidth = $.fancybox.getTranslate(current.$slide).width,\\r\\n        canvasHeight = $.fancybox.getTranslate(current.$slide).height,\\r\\n        newImgWidth = current.width,\\r\\n        newImgHeight = current.height,\\r\\n        imgPos,\\r\\n        posX,\\r\\n        posY,\\r\\n        scaleX,\\r\\n        scaleY;\\r\\n\\r\\n      if (self.isAnimating || self.isMoved() || !$content || !(current.type == \"image\" && current.isLoaded && !current.hasError)) {\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      self.isAnimating = true;\\r\\n\\r\\n      $.fancybox.stop($content);\\r\\n\\r\\n      x = x === undefined ? canvasWidth * 0.5 : x;\\r\\n      y = y === undefined ? canvasHeight * 0.5 : y;\\r\\n\\r\\n      imgPos = $.fancybox.getTranslate($content);\\r\\n\\r\\n      imgPos.top -= $.fancybox.getTranslate(current.$slide).top;\\r\\n      imgPos.left -= $.fancybox.getTranslate(current.$slide).left;\\r\\n\\r\\n      scaleX = newImgWidth / imgPos.width;\\r\\n      scaleY = newImgHeight / imgPos.height;\\r\\n\\r\\n      // Get center position for original image\\r\\n      posX = canvasWidth * 0.5 - newImgWidth * 0.5;\\r\\n      posY = canvasHeight * 0.5 - newImgHeight * 0.5;\\r\\n\\r\\n      // Make sure image does not move away from edges\\r\\n      if (newImgWidth > canvasWidth) {\\r\\n        posX = imgPos.left * scaleX - (x * scaleX - x);\\r\\n\\r\\n        if (posX > 0) {\\r\\n          posX = 0;\\r\\n        }\\r\\n\\r\\n        if (posX < canvasWidth - newImgWidth) {\\r\\n          posX = canvasWidth - newImgWidth;\\r\\n        }\\r\\n      }\\r\\n\\r\\n      if (newImgHeight > canvasHeight) {\\r\\n        posY = imgPos.top * scaleY - (y * scaleY - y);\\r\\n\\r\\n        if (posY > 0) {\\r\\n          posY = 0;\\r\\n        }\\r\\n\\r\\n        if (posY < canvasHeight - newImgHeight) {\\r\\n          posY = canvasHeight - newImgHeight;\\r\\n        }\\r\\n      }\\r\\n\\r\\n      self.updateCursor(newImgWidth, newImgHeight);\\r\\n\\r\\n      $.fancybox.animate(\\r\\n        $content,\\r\\n        {\\r\\n          top: posY,\\r\\n          left: posX,\\r\\n          scaleX: scaleX,\\r\\n          scaleY: scaleY\\r\\n        },\\r\\n        duration || 366,\\r\\n        function() {\\r\\n          self.isAnimating = false;\\r\\n        }\\r\\n      );\\r\\n\\r\\n      // Stop slideshow\\r\\n      if (self.SlideShow && self.SlideShow.isActive) {\\r\\n        self.SlideShow.stop();\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Scale image to fit inside parent element\\r\\n    // ========================================\\r\\n\\r\\n    scaleToFit: function(duration) {\\r\\n      var self = this,\\r\\n        current = self.current,\\r\\n        $content = current.$content,\\r\\n        end;\\r\\n\\r\\n      if (self.isAnimating || self.isMoved() || !$content || !(current.type == \"image\" && current.isLoaded && !current.hasError)) {\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      self.isAnimating = true;\\r\\n\\r\\n      $.fancybox.stop($content);\\r\\n\\r\\n      end = self.getFitPos(current);\\r\\n\\r\\n      self.updateCursor(end.width, end.height);\\r\\n\\r\\n      $.fancybox.animate(\\r\\n        $content,\\r\\n        {\\r\\n          top: end.top,\\r\\n          left: end.left,\\r\\n          scaleX: end.width / $content.width(),\\r\\n          scaleY: end.height / $content.height()\\r\\n        },\\r\\n        duration || 366,\\r\\n        function() {\\r\\n          self.isAnimating = false;\\r\\n        }\\r\\n      );\\r\\n    },\\r\\n\\r\\n    // Calculate image size to fit inside viewport\\r\\n    // ===========================================\\r\\n\\r\\n    getFitPos: function(slide) {\\r\\n      var self = this,\\r\\n        $content = slide.$content,\\r\\n        $slide = slide.$slide,\\r\\n        width = slide.width || slide.opts.width,\\r\\n        height = slide.height || slide.opts.height,\\r\\n        maxWidth,\\r\\n        maxHeight,\\r\\n        minRatio,\\r\\n        aspectRatio,\\r\\n        rez = {};\\r\\n\\r\\n      if (!slide.isLoaded || !$content || !$content.length) {\\r\\n        return false;\\r\\n      }\\r\\n\\r\\n      maxWidth = $.fancybox.getTranslate(self.$refs.stage).width;\\r\\n      maxHeight = $.fancybox.getTranslate(self.$refs.stage).height;\\r\\n\\r\\n      maxWidth -=\\r\\n        parseFloat($slide.css(\"paddingLeft\")) +\\r\\n        parseFloat($slide.css(\"paddingRight\")) +\\r\\n        parseFloat($content.css(\"marginLeft\")) +\\r\\n        parseFloat($content.css(\"marginRight\"));\\r\\n\\r\\n      maxHeight -=\\r\\n        parseFloat($slide.css(\"paddingTop\")) +\\r\\n        parseFloat($slide.css(\"paddingBottom\")) +\\r\\n        parseFloat($content.css(\"marginTop\")) +\\r\\n        parseFloat($content.css(\"marginBottom\"));\\r\\n\\r\\n      if (!width || !height) {\\r\\n        width = maxWidth;\\r\\n        height = maxHeight;\\r\\n      }\\r\\n\\r\\n      minRatio = Math.min(1, maxWidth / width, maxHeight / height);\\r\\n\\r\\n      width = minRatio * width;\\r\\n      height = minRatio * height;\\r\\n\\r\\n      // Adjust width/height to precisely fit into container\\r\\n      if (width > maxWidth - 0.5) {\\r\\n        width = maxWidth;\\r\\n      }\\r\\n\\r\\n      if (height > maxHeight - 0.5) {\\r\\n        height = maxHeight;\\r\\n      }\\r\\n\\r\\n      if (slide.type === \"image\") {\\r\\n        rez.top = Math.floor((maxHeight - height) * 0.5) + parseFloat($slide.css(\"paddingTop\"));\\r\\n        rez.left = Math.floor((maxWidth - width) * 0.5) + parseFloat($slide.css(\"paddingLeft\"));\\r\\n      } else if (slide.contentType === \"video\") {\\r\\n        // Force aspect ratio for the video\\r\\n        // \"I say the whole world must learn of our peaceful ways by force!\"\\r\\n        aspectRatio = slide.opts.width && slide.opts.height ? width / height : slide.opts.ratio || 16 / 9;\\r\\n\\r\\n        if (height > width / aspectRatio) {\\r\\n          height = width / aspectRatio;\\r\\n        } else if (width > height * aspectRatio) {\\r\\n          width = height * aspectRatio;\\r\\n        }\\r\\n      }\\r\\n\\r\\n      rez.width = width;\\r\\n      rez.height = height;\\r\\n\\r\\n      return rez;\\r\\n    },\\r\\n\\r\\n    // Update content size and position for all slides\\r\\n    // ==============================================\\r\\n\\r\\n    update: function(e) {\\r\\n      var self = this;\\r\\n\\r\\n      $.each(self.slides, function(key, slide) {\\r\\n        self.updateSlide(slide, e);\\r\\n      });\\r\\n    },\\r\\n\\r\\n    // Update slide content position and size\\r\\n    // ======================================\\r\\n\\r\\n    updateSlide: function(slide, e) {\\r\\n      var self = this,\\r\\n        $content = slide && slide.$content,\\r\\n        width = slide.width || slide.opts.width,\\r\\n        height = slide.height || slide.opts.height,\\r\\n        $slide = slide.$slide;\\r\\n\\r\\n      // First, prevent caption overlap, if needed\\r\\n      self.adjustCaption(slide);\\r\\n\\r\\n      // Then resize content to fit inside the slide\\r\\n      if ($content && (width || height || slide.contentType === \"video\") && !slide.hasError) {\\r\\n        $.fancybox.stop($content);\\r\\n\\r\\n        $.fancybox.setTranslate($content, self.getFitPos(slide));\\r\\n\\r\\n        if (slide.pos === self.currPos) {\\r\\n          self.isAnimating = false;\\r\\n\\r\\n          self.updateCursor();\\r\\n        }\\r\\n      }\\r\\n\\r\\n      // Then some adjustments\\r\\n      self.adjustLayout(slide);\\r\\n\\r\\n      if ($slide.length) {\\r\\n        $slide.trigger(\"refresh\");\\r\\n\\r\\n        if (slide.pos === self.currPos) {\\r\\n          self.$refs.toolbar\\r\\n            .add(self.$refs.navigation.find(\".fancybox-button--arrow_right\"))\\r\\n            .toggleClass(\"compensate-for-scrollbar\", $slide.get(0).scrollHeight > $slide.get(0).clientHeight);\\r\\n        }\\r\\n      }\\r\\n\\r\\n      self.trigger(\"onUpdate\", slide, e);\\r\\n    },\\r\\n\\r\\n    // Horizontally center slide\\r\\n    // =========================\\r\\n\\r\\n    centerSlide: function(duration) {\\r\\n      var self = this,\\r\\n        current = self.current,\\r\\n        $slide = current.$slide;\\r\\n\\r\\n      if (self.isClosing || !current) {\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      $slide.siblings().css({\\r\\n        transform: \"\",\\r\\n        opacity: \"\"\\r\\n      });\\r\\n\\r\\n      $slide\\r\\n        .parent()\\r\\n        .children()\\r\\n        .removeClass(\"fancybox-slide--previous fancybox-slide--next\");\\r\\n\\r\\n      $.fancybox.animate(\\r\\n        $slide,\\r\\n        {\\r\\n          top: 0,\\r\\n          left: 0,\\r\\n          opacity: 1\\r\\n        },\\r\\n        duration === undefined ? 0 : duration,\\r\\n        function() {\\r\\n          // Clean up\\r\\n          $slide.css({\\r\\n            transform: \"\",\\r\\n            opacity: \"\"\\r\\n          });\\r\\n\\r\\n          if (!current.isComplete) {\\r\\n            self.complete();\\r\\n          }\\r\\n        },\\r\\n        false\\r\\n      );\\r\\n    },\\r\\n\\r\\n    // Check if current slide is moved (swiped)\\r\\n    // ========================================\\r\\n\\r\\n    isMoved: function(slide) {\\r\\n      var current = slide || this.current,\\r\\n        slidePos,\\r\\n        stagePos;\\r\\n\\r\\n      if (!current) {\\r\\n        return false;\\r\\n      }\\r\\n\\r\\n      stagePos = $.fancybox.getTranslate(this.$refs.stage);\\r\\n      slidePos = $.fancybox.getTranslate(current.$slide);\\r\\n\\r\\n      return (\\r\\n        !current.$slide.hasClass(\"fancybox-animated\") &&\\r\\n        (Math.abs(slidePos.top - stagePos.top) > 0.5 || Math.abs(slidePos.left - stagePos.left) > 0.5)\\r\\n      );\\r\\n    },\\r\\n\\r\\n    // Update cursor style depending if content can be zoomed\\r\\n    // ======================================================\\r\\n\\r\\n    updateCursor: function(nextWidth, nextHeight) {\\r\\n      var self = this,\\r\\n        current = self.current,\\r\\n        $container = self.$refs.container,\\r\\n        canPan,\\r\\n        isZoomable;\\r\\n\\r\\n      if (!current || self.isClosing || !self.Guestures) {\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      $container.removeClass(\"fancybox-is-zoomable fancybox-can-zoomIn fancybox-can-zoomOut fancybox-can-swipe fancybox-can-pan\");\\r\\n\\r\\n      canPan = self.canPan(nextWidth, nextHeight);\\r\\n\\r\\n      isZoomable = canPan ? true : self.isZoomable();\\r\\n\\r\\n      $container.toggleClass(\"fancybox-is-zoomable\", isZoomable);\\r\\n\\r\\n      $(\"[data-fancybox-zoom]\").prop(\"disabled\", !isZoomable);\\r\\n\\r\\n      if (canPan) {\\r\\n        $container.addClass(\"fancybox-can-pan\");\\r\\n      } else if (\\r\\n        isZoomable &&\\r\\n        (current.opts.clickContent === \"zoom\" || ($.isFunction(current.opts.clickContent) && current.opts.clickContent(current) == \"zoom\"))\\r\\n      ) {\\r\\n        $container.addClass(\"fancybox-can-zoomIn\");\\r\\n      } else if (current.opts.touch && (current.opts.touch.vertical || self.group.length > 1) && current.contentType !== \"video\") {\\r\\n        $container.addClass(\"fancybox-can-swipe\");\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Check if current slide is zoomable\\r\\n    // ==================================\\r\\n\\r\\n    isZoomable: function() {\\r\\n      var self = this,\\r\\n        current = self.current,\\r\\n        fitPos;\\r\\n\\r\\n      // Assume that slide is zoomable if:\\r\\n      //   - image is still loading\\r\\n      //   - actual size of the image is smaller than available area\\r\\n      if (current && !self.isClosing && current.type === \"image\" && !current.hasError) {\\r\\n        if (!current.isLoaded) {\\r\\n          return true;\\r\\n        }\\r\\n\\r\\n        fitPos = self.getFitPos(current);\\r\\n\\r\\n        if (fitPos && (current.width > fitPos.width || current.height > fitPos.height)) {\\r\\n          return true;\\r\\n        }\\r\\n      }\\r\\n\\r\\n      return false;\\r\\n    },\\r\\n\\r\\n    // Check if current image dimensions are smaller than actual\\r\\n    // =========================================================\\r\\n\\r\\n    isScaledDown: function(nextWidth, nextHeight) {\\r\\n      var self = this,\\r\\n        rez = false,\\r\\n        current = self.current,\\r\\n        $content = current.$content;\\r\\n\\r\\n      if (nextWidth !== undefined && nextHeight !== undefined) {\\r\\n        rez = nextWidth < current.width && nextHeight < current.height;\\r\\n      } else if ($content) {\\r\\n        rez = $.fancybox.getTranslate($content);\\r\\n        rez = rez.width < current.width && rez.height < current.height;\\r\\n      }\\r\\n\\r\\n      return rez;\\r\\n    },\\r\\n\\r\\n    // Check if image dimensions exceed parent element\\r\\n    // ===============================================\\r\\n\\r\\n    canPan: function(nextWidth, nextHeight) {\\r\\n      var self = this,\\r\\n        current = self.current,\\r\\n        pos = null,\\r\\n        rez = false;\\r\\n\\r\\n      if (current.type === \"image\" && (current.isComplete || (nextWidth && nextHeight)) && !current.hasError) {\\r\\n        rez = self.getFitPos(current);\\r\\n\\r\\n        if (nextWidth !== undefined && nextHeight !== undefined) {\\r\\n          pos = {width: nextWidth, height: nextHeight};\\r\\n        } else if (current.isComplete) {\\r\\n          pos = $.fancybox.getTranslate(current.$content);\\r\\n        }\\r\\n\\r\\n        if (pos && rez) {\\r\\n          rez = Math.abs(pos.width - rez.width) > 1.5 || Math.abs(pos.height - rez.height) > 1.5;\\r\\n        }\\r\\n      }\\r\\n\\r\\n      return rez;\\r\\n    },\\r\\n\\r\\n    // Load content into the slide\\r\\n    // ===========================\\r\\n\\r\\n    loadSlide: function(slide) {\\r\\n      var self = this,\\r\\n        type,\\r\\n        $slide,\\r\\n        ajaxLoad;\\r\\n\\r\\n      if (slide.isLoading || slide.isLoaded) {\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      slide.isLoading = true;\\r\\n\\r\\n      if (self.trigger(\"beforeLoad\", slide) === false) {\\r\\n        slide.isLoading = false;\\r\\n\\r\\n        return false;\\r\\n      }\\r\\n\\r\\n      type = slide.type;\\r\\n      $slide = slide.$slide;\\r\\n\\r\\n      $slide\\r\\n        .off(\"refresh\")\\r\\n        .trigger(\"onReset\")\\r\\n        .addClass(slide.opts.slideClass);\\r\\n\\r\\n      // Create content depending on the type\\r\\n      switch (type) {\\r\\n        case \"image\":\\r\\n          self.setImage(slide);\\r\\n\\r\\n          break;\\r\\n\\r\\n        case \"iframe\":\\r\\n          self.setIframe(slide);\\r\\n\\r\\n          break;\\r\\n\\r\\n        case \"html\":\\r\\n          self.setContent(slide, slide.src || slide.content);\\r\\n\\r\\n          break;\\r\\n\\r\\n        case \"video\":\\r\\n          self.setContent(\\r\\n            slide,\\r\\n            slide.opts.video.tpl\\r\\n              .replace(/\\\\{\\\\{src\\\\}\\\\}/gi, slide.src)\\r\\n              .replace(\"{{format}}\", slide.opts.videoFormat || slide.opts.video.format || \"\")\\r\\n              .replace(\"{{poster}}\", slide.thumb || \"\")\\r\\n          );\\r\\n\\r\\n          break;\\r\\n\\r\\n        case \"inline\":\\r\\n          if ($(slide.src).length) {\\r\\n            self.setContent(slide, $(slide.src));\\r\\n          } else {\\r\\n            self.setError(slide);\\r\\n          }\\r\\n\\r\\n          break;\\r\\n\\r\\n        case \"ajax\":\\r\\n          self.showLoading(slide);\\r\\n\\r\\n          ajaxLoad = $.ajax(\\r\\n            $.extend({}, slide.opts.ajax.settings, {\\r\\n              url: slide.src,\\r\\n              success: function(data, textStatus) {\\r\\n                if (textStatus === \"success\") {\\r\\n                  self.setContent(slide, data);\\r\\n                }\\r\\n              },\\r\\n              error: function(jqXHR, textStatus) {\\r\\n                if (jqXHR && textStatus !== \"abort\") {\\r\\n                  self.setError(slide);\\r\\n                }\\r\\n              }\\r\\n            })\\r\\n          );\\r\\n\\r\\n          $slide.one(\"onReset\", function() {\\r\\n            ajaxLoad.abort();\\r\\n          });\\r\\n\\r\\n          break;\\r\\n\\r\\n        default:\\r\\n          self.setError(slide);\\r\\n\\r\\n          break;\\r\\n      }\\r\\n\\r\\n      return true;\\r\\n    },\\r\\n\\r\\n    // Use thumbnail image, if possible\\r\\n    // ================================\\r\\n\\r\\n    setImage: function(slide) {\\r\\n      var self = this,\\r\\n        ghost;\\r\\n\\r\\n      // Check if need to show loading icon\\r\\n      setTimeout(function() {\\r\\n        var $img = slide.$image;\\r\\n\\r\\n        if (!self.isClosing && slide.isLoading && (!$img || !$img.length || !$img[0].complete) && !slide.hasError) {\\r\\n          self.showLoading(slide);\\r\\n        }\\r\\n      }, 50);\\r\\n\\r\\n      //Check if image has srcset\\r\\n      self.checkSrcset(slide);\\r\\n\\r\\n      // This will be wrapper containing both ghost and actual image\\r\\n      slide.$content = $(\\'<div class=\"fancybox-content\"></div>\\')\\r\\n        .addClass(\"fancybox-is-hidden\")\\r\\n        .appendTo(slide.$slide.addClass(\"fancybox-slide--image\"));\\r\\n\\r\\n      // If we have a thumbnail, we can display it while actual image is loading\\r\\n      // Users will not stare at black screen and actual image will appear gradually\\r\\n      if (slide.opts.preload !== false && slide.opts.width && slide.opts.height && slide.thumb) {\\r\\n        slide.width = slide.opts.width;\\r\\n        slide.height = slide.opts.height;\\r\\n\\r\\n        ghost = document.createElement(\"img\");\\r\\n\\r\\n        ghost.onerror = function() {\\r\\n          $(this).remove();\\r\\n\\r\\n          slide.$ghost = null;\\r\\n        };\\r\\n\\r\\n        ghost.onload = function() {\\r\\n          self.afterLoad(slide);\\r\\n        };\\r\\n\\r\\n        slide.$ghost = $(ghost)\\r\\n          .addClass(\"fancybox-image\")\\r\\n          .appendTo(slide.$content)\\r\\n          .attr(\"src\", slide.thumb);\\r\\n      }\\r\\n\\r\\n      // Start loading actual image\\r\\n      self.setBigImage(slide);\\r\\n    },\\r\\n\\r\\n    // Check if image has srcset and get the source\\r\\n    // ============================================\\r\\n    checkSrcset: function(slide) {\\r\\n      var srcset = slide.opts.srcset || slide.opts.image.srcset,\\r\\n        found,\\r\\n        temp,\\r\\n        pxRatio,\\r\\n        windowWidth;\\r\\n\\r\\n      // If we have \"srcset\", then we need to find first matching \"src\" value.\\r\\n      // This is necessary, because when you set an src attribute, the browser will preload the image\\r\\n      // before any javascript or even CSS is applied.\\r\\n      if (srcset) {\\r\\n        pxRatio = window.devicePixelRatio || 1;\\r\\n        windowWidth = window.innerWidth * pxRatio;\\r\\n\\r\\n        temp = srcset.split(\",\").map(function(el) {\\r\\n          var ret = {};\\r\\n\\r\\n          el.trim()\\r\\n            .split(/\\\\s+/)\\r\\n            .forEach(function(el, i) {\\r\\n              var value = parseInt(el.substring(0, el.length - 1), 10);\\r\\n\\r\\n              if (i === 0) {\\r\\n                return (ret.url = el);\\r\\n              }\\r\\n\\r\\n              if (value) {\\r\\n                ret.value = value;\\r\\n                ret.postfix = el[el.length - 1];\\r\\n              }\\r\\n            });\\r\\n\\r\\n          return ret;\\r\\n        });\\r\\n\\r\\n        // Sort by value\\r\\n        temp.sort(function(a, b) {\\r\\n          return a.value - b.value;\\r\\n        });\\r\\n\\r\\n        // Ok, now we have an array of all srcset values\\r\\n        for (var j = 0; j < temp.length; j++) {\\r\\n          var el = temp[j];\\r\\n\\r\\n          if ((el.postfix === \"w\" && el.value >= windowWidth) || (el.postfix === \"x\" && el.value >= pxRatio)) {\\r\\n            found = el;\\r\\n            break;\\r\\n          }\\r\\n        }\\r\\n\\r\\n        // If not found, take the last one\\r\\n        if (!found && temp.length) {\\r\\n          found = temp[temp.length - 1];\\r\\n        }\\r\\n\\r\\n        if (found) {\\r\\n          slide.src = found.url;\\r\\n\\r\\n          // If we have default width/height values, we can calculate height for matching source\\r\\n          if (slide.width && slide.height && found.postfix == \"w\") {\\r\\n            slide.height = (slide.width / slide.height) * found.value;\\r\\n            slide.width = found.value;\\r\\n          }\\r\\n\\r\\n          slide.opts.srcset = srcset;\\r\\n        }\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Create full-size image\\r\\n    // ======================\\r\\n\\r\\n    setBigImage: function(slide) {\\r\\n      var self = this,\\r\\n        img = document.createElement(\"img\"),\\r\\n        $img = $(img);\\r\\n\\r\\n      slide.$image = $img\\r\\n        .one(\"error\", function() {\\r\\n          self.setError(slide);\\r\\n        })\\r\\n        .one(\"load\", function() {\\r\\n          var sizes;\\r\\n\\r\\n          if (!slide.$ghost) {\\r\\n            self.resolveImageSlideSize(slide, this.naturalWidth, this.naturalHeight);\\r\\n\\r\\n            self.afterLoad(slide);\\r\\n          }\\r\\n\\r\\n          if (self.isClosing) {\\r\\n            return;\\r\\n          }\\r\\n\\r\\n          if (slide.opts.srcset) {\\r\\n            sizes = slide.opts.sizes;\\r\\n\\r\\n            if (!sizes || sizes === \"auto\") {\\r\\n              sizes =\\r\\n                (slide.width / slide.height > 1 && $W.width() / $W.height() > 1 ? \"100\" : Math.round((slide.width / slide.height) * 100)) +\\r\\n                \"vw\";\\r\\n            }\\r\\n\\r\\n            $img.attr(\"sizes\", sizes).attr(\"srcset\", slide.opts.srcset);\\r\\n          }\\r\\n\\r\\n          // Hide temporary image after some delay\\r\\n          if (slide.$ghost) {\\r\\n            setTimeout(function() {\\r\\n              if (slide.$ghost && !self.isClosing) {\\r\\n                slide.$ghost.hide();\\r\\n              }\\r\\n            }, Math.min(300, Math.max(1000, slide.height / 1600)));\\r\\n          }\\r\\n\\r\\n          self.hideLoading(slide);\\r\\n        })\\r\\n        .addClass(\"fancybox-image\")\\r\\n        .attr(\"src\", slide.src)\\r\\n        .appendTo(slide.$content);\\r\\n\\r\\n      if ((img.complete || img.readyState == \"complete\") && $img.naturalWidth && $img.naturalHeight) {\\r\\n        $img.trigger(\"load\");\\r\\n      } else if (img.error) {\\r\\n        $img.trigger(\"error\");\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Computes the slide size from image size and maxWidth/maxHeight\\r\\n    // ==============================================================\\r\\n\\r\\n    resolveImageSlideSize: function(slide, imgWidth, imgHeight) {\\r\\n      var maxWidth = parseInt(slide.opts.width, 10),\\r\\n        maxHeight = parseInt(slide.opts.height, 10);\\r\\n\\r\\n      // Sets the default values from the image\\r\\n      slide.width = imgWidth;\\r\\n      slide.height = imgHeight;\\r\\n\\r\\n      if (maxWidth > 0) {\\r\\n        slide.width = maxWidth;\\r\\n        slide.height = Math.floor((maxWidth * imgHeight) / imgWidth);\\r\\n      }\\r\\n\\r\\n      if (maxHeight > 0) {\\r\\n        slide.width = Math.floor((maxHeight * imgWidth) / imgHeight);\\r\\n        slide.height = maxHeight;\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Create iframe wrapper, iframe and bindings\\r\\n    // ==========================================\\r\\n\\r\\n    setIframe: function(slide) {\\r\\n      var self = this,\\r\\n        opts = slide.opts.iframe,\\r\\n        $slide = slide.$slide,\\r\\n        $iframe;\\r\\n\\r\\n      slide.$content = $(\\'<div class=\"fancybox-content\\' + (opts.preload ? \" fancybox-is-hidden\" : \"\") + \\'\"></div>\\')\\r\\n        .css(opts.css)\\r\\n        .appendTo($slide);\\r\\n\\r\\n      $slide.addClass(\"fancybox-slide--\" + slide.contentType);\\r\\n\\r\\n      slide.$iframe = $iframe = $(opts.tpl.replace(/\\\\{rnd\\\\}/g, new Date().getTime()))\\r\\n        .attr(opts.attr)\\r\\n        .appendTo(slide.$content);\\r\\n\\r\\n      if (opts.preload) {\\r\\n        self.showLoading(slide);\\r\\n\\r\\n        // Unfortunately, it is not always possible to determine if iframe is successfully loaded\\r\\n        // (due to browser security policy)\\r\\n\\r\\n        $iframe.on(\"load.fb error.fb\", function(e) {\\r\\n          this.isReady = 1;\\r\\n\\r\\n          slide.$slide.trigger(\"refresh\");\\r\\n\\r\\n          self.afterLoad(slide);\\r\\n        });\\r\\n\\r\\n        // Recalculate iframe content size\\r\\n        // ===============================\\r\\n\\r\\n        $slide.on(\"refresh.fb\", function() {\\r\\n          var $content = slide.$content,\\r\\n            frameWidth = opts.css.width,\\r\\n            frameHeight = opts.css.height,\\r\\n            $contents,\\r\\n            $body;\\r\\n\\r\\n          if ($iframe[0].isReady !== 1) {\\r\\n            return;\\r\\n          }\\r\\n\\r\\n          try {\\r\\n            $contents = $iframe.contents();\\r\\n            $body = $contents.find(\"body\");\\r\\n          } catch (ignore) {}\\r\\n\\r\\n          // Calculate content dimensions, if it is accessible\\r\\n          if ($body && $body.length && $body.children().length) {\\r\\n            // Avoid scrolling to top (if multiple instances)\\r\\n            $slide.css(\"overflow\", \"visible\");\\r\\n\\r\\n            $content.css({\\r\\n              width: \"100%\",\\r\\n              \"max-width\": \"100%\",\\r\\n              height: \"9999px\"\\r\\n            });\\r\\n\\r\\n            if (frameWidth === undefined) {\\r\\n              frameWidth = Math.ceil(Math.max($body[0].clientWidth, $body.outerWidth(true)));\\r\\n            }\\r\\n\\r\\n            $content.css(\"width\", frameWidth ? frameWidth : \"\").css(\"max-width\", \"\");\\r\\n\\r\\n            if (frameHeight === undefined) {\\r\\n              frameHeight = Math.ceil(Math.max($body[0].clientHeight, $body.outerHeight(true)));\\r\\n            }\\r\\n\\r\\n            $content.css(\"height\", frameHeight ? frameHeight : \"\");\\r\\n\\r\\n            $slide.css(\"overflow\", \"auto\");\\r\\n          }\\r\\n\\r\\n          $content.removeClass(\"fancybox-is-hidden\");\\r\\n        });\\r\\n      } else {\\r\\n        self.afterLoad(slide);\\r\\n      }\\r\\n\\r\\n      $iframe.attr(\"src\", slide.src);\\r\\n\\r\\n      // Remove iframe if closing or changing gallery item\\r\\n      $slide.one(\"onReset\", function() {\\r\\n        // This helps IE not to throw errors when closing\\r\\n        try {\\r\\n          $(this)\\r\\n            .find(\"iframe\")\\r\\n            .hide()\\r\\n            .unbind()\\r\\n            .attr(\"src\", \"//about:blank\");\\r\\n        } catch (ignore) {}\\r\\n\\r\\n        $(this)\\r\\n          .off(\"refresh.fb\")\\r\\n          .empty();\\r\\n\\r\\n        slide.isLoaded = false;\\r\\n        slide.isRevealed = false;\\r\\n      });\\r\\n    },\\r\\n\\r\\n    // Wrap and append content to the slide\\r\\n    // ======================================\\r\\n\\r\\n    setContent: function(slide, content) {\\r\\n      var self = this;\\r\\n\\r\\n      if (self.isClosing) {\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      self.hideLoading(slide);\\r\\n\\r\\n      if (slide.$content) {\\r\\n        $.fancybox.stop(slide.$content);\\r\\n      }\\r\\n\\r\\n      slide.$slide.empty();\\r\\n\\r\\n      // If content is a jQuery object, then it will be moved to the slide.\\r\\n      // The placeholder is created so we will know where to put it back.\\r\\n      if (isQuery(content) && content.parent().length) {\\r\\n        // Make sure content is not already moved to fancyBox\\r\\n        if (content.hasClass(\"fancybox-content\") || content.parent().hasClass(\"fancybox-content\")) {\\r\\n          content.parents(\".fancybox-slide\").trigger(\"onReset\");\\r\\n        }\\r\\n\\r\\n        // Create temporary element marking original place of the content\\r\\n        slide.$placeholder = $(\"<div>\")\\r\\n          .hide()\\r\\n          .insertAfter(content);\\r\\n\\r\\n        // Make sure content is visible\\r\\n        content.css(\"display\", \"inline-block\");\\r\\n      } else if (!slide.hasError) {\\r\\n        // If content is just a plain text, try to convert it to html\\r\\n        if ($.type(content) === \"string\") {\\r\\n          content = $(\"<div>\")\\r\\n            .append($.trim(content))\\r\\n            .contents();\\r\\n        }\\r\\n\\r\\n        // If \"filter\" option is provided, then filter content\\r\\n        if (slide.opts.filter) {\\r\\n          content = $(\"<div>\")\\r\\n            .html(content)\\r\\n            .find(slide.opts.filter);\\r\\n        }\\r\\n      }\\r\\n\\r\\n      slide.$slide.one(\"onReset\", function() {\\r\\n        // Pause all html5 video/audio\\r\\n        $(this)\\r\\n          .find(\"video,audio\")\\r\\n          .trigger(\"pause\");\\r\\n\\r\\n        // Put content back\\r\\n        if (slide.$placeholder) {\\r\\n          slide.$placeholder.after(content.removeClass(\"fancybox-content\").hide()).remove();\\r\\n\\r\\n          slide.$placeholder = null;\\r\\n        }\\r\\n\\r\\n        // Remove custom close button\\r\\n        if (slide.$smallBtn) {\\r\\n          slide.$smallBtn.remove();\\r\\n\\r\\n          slide.$smallBtn = null;\\r\\n        }\\r\\n\\r\\n        // Remove content and mark slide as not loaded\\r\\n        if (!slide.hasError) {\\r\\n          $(this).empty();\\r\\n\\r\\n          slide.isLoaded = false;\\r\\n          slide.isRevealed = false;\\r\\n        }\\r\\n      });\\r\\n\\r\\n      $(content).appendTo(slide.$slide);\\r\\n\\r\\n      if ($(content).is(\"video,audio\")) {\\r\\n        $(content).addClass(\"fancybox-video\");\\r\\n\\r\\n        $(content).wrap(\"<div></div>\");\\r\\n\\r\\n        slide.contentType = \"video\";\\r\\n\\r\\n        slide.opts.width = slide.opts.width || $(content).attr(\"width\");\\r\\n        slide.opts.height = slide.opts.height || $(content).attr(\"height\");\\r\\n      }\\r\\n\\r\\n      slide.$content = slide.$slide\\r\\n        .children()\\r\\n        .filter(\"div,form,main,video,audio,article,.fancybox-content\")\\r\\n        .first();\\r\\n\\r\\n      slide.$content.siblings().hide();\\r\\n\\r\\n      // Re-check if there is a valid content\\r\\n      // (in some cases, ajax response can contain various elements or plain text)\\r\\n      if (!slide.$content.length) {\\r\\n        slide.$content = slide.$slide\\r\\n          .wrapInner(\"<div></div>\")\\r\\n          .children()\\r\\n          .first();\\r\\n      }\\r\\n\\r\\n      slide.$content.addClass(\"fancybox-content\");\\r\\n\\r\\n      slide.$slide.addClass(\"fancybox-slide--\" + slide.contentType);\\r\\n\\r\\n      self.afterLoad(slide);\\r\\n    },\\r\\n\\r\\n    // Display error message\\r\\n    // =====================\\r\\n\\r\\n    setError: function(slide) {\\r\\n      slide.hasError = true;\\r\\n\\r\\n      slide.$slide\\r\\n        .trigger(\"onReset\")\\r\\n        .removeClass(\"fancybox-slide--\" + slide.contentType)\\r\\n        .addClass(\"fancybox-slide--error\");\\r\\n\\r\\n      slide.contentType = \"html\";\\r\\n\\r\\n      this.setContent(slide, this.translate(slide, slide.opts.errorTpl));\\r\\n\\r\\n      if (slide.pos === this.currPos) {\\r\\n        this.isAnimating = false;\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Show loading icon inside the slide\\r\\n    // ==================================\\r\\n\\r\\n    showLoading: function(slide) {\\r\\n      var self = this;\\r\\n\\r\\n      slide = slide || self.current;\\r\\n\\r\\n      if (slide && !slide.$spinner) {\\r\\n        slide.$spinner = $(self.translate(self, self.opts.spinnerTpl))\\r\\n          .appendTo(slide.$slide)\\r\\n          .hide()\\r\\n          .fadeIn(\"fast\");\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Remove loading icon from the slide\\r\\n    // ==================================\\r\\n\\r\\n    hideLoading: function(slide) {\\r\\n      var self = this;\\r\\n\\r\\n      slide = slide || self.current;\\r\\n\\r\\n      if (slide && slide.$spinner) {\\r\\n        slide.$spinner.stop().remove();\\r\\n\\r\\n        delete slide.$spinner;\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Adjustments after slide content has been loaded\\r\\n    // ===============================================\\r\\n\\r\\n    afterLoad: function(slide) {\\r\\n      var self = this;\\r\\n\\r\\n      if (self.isClosing) {\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      slide.isLoading = false;\\r\\n      slide.isLoaded = true;\\r\\n\\r\\n      self.trigger(\"afterLoad\", slide);\\r\\n\\r\\n      self.hideLoading(slide);\\r\\n\\r\\n      // Add small close button\\r\\n      if (slide.opts.smallBtn && (!slide.$smallBtn || !slide.$smallBtn.length)) {\\r\\n        slide.$smallBtn = $(self.translate(slide, slide.opts.btnTpl.smallBtn)).appendTo(slide.$content);\\r\\n      }\\r\\n\\r\\n      // Disable right click\\r\\n      if (slide.opts.protect && slide.$content && !slide.hasError) {\\r\\n        slide.$content.on(\"contextmenu.fb\", function(e) {\\r\\n          if (e.button == 2) {\\r\\n            e.preventDefault();\\r\\n          }\\r\\n\\r\\n          return true;\\r\\n        });\\r\\n\\r\\n        // Add fake element on top of the image\\r\\n        // This makes a bit harder for user to select image\\r\\n        if (slide.type === \"image\") {\\r\\n          $(\\'<div class=\"fancybox-spaceball\"></div>\\').appendTo(slide.$content);\\r\\n        }\\r\\n      }\\r\\n\\r\\n      self.adjustCaption(slide);\\r\\n\\r\\n      self.adjustLayout(slide);\\r\\n\\r\\n      if (slide.pos === self.currPos) {\\r\\n        self.updateCursor();\\r\\n      }\\r\\n\\r\\n      self.revealContent(slide);\\r\\n    },\\r\\n\\r\\n    // Prevent caption overlap,\\r\\n    // fix css inconsistency across browsers\\r\\n    // =====================================\\r\\n\\r\\n    adjustCaption: function(slide) {\\r\\n      var self = this,\\r\\n        current = slide || self.current,\\r\\n        caption = current.opts.caption,\\r\\n        preventOverlap = current.opts.preventCaptionOverlap,\\r\\n        $caption = self.$refs.caption,\\r\\n        $clone,\\r\\n        captionH = false;\\r\\n\\r\\n      $caption.toggleClass(\"fancybox-caption--separate\", preventOverlap);\\r\\n\\r\\n      if (preventOverlap && caption && caption.length) {\\r\\n        if (current.pos !== self.currPos) {\\r\\n          $clone = $caption.clone().appendTo($caption.parent());\\r\\n\\r\\n          $clone\\r\\n            .children()\\r\\n            .eq(0)\\r\\n            .empty()\\r\\n            .html(caption);\\r\\n\\r\\n          captionH = $clone.outerHeight(true);\\r\\n\\r\\n          $clone.empty().remove();\\r\\n        } else if (self.$caption) {\\r\\n          captionH = self.$caption.outerHeight(true);\\r\\n        }\\r\\n\\r\\n        current.$slide.css(\"padding-bottom\", captionH || \"\");\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Simple hack to fix inconsistency across browsers, described here (affects Edge, too):\\r\\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=748518\\r\\n    // ====================================================================================\\r\\n\\r\\n    adjustLayout: function(slide) {\\r\\n      var self = this,\\r\\n        current = slide || self.current,\\r\\n        scrollHeight,\\r\\n        marginBottom,\\r\\n        inlinePadding,\\r\\n        actualPadding;\\r\\n\\r\\n      if (current.isLoaded && current.opts.disableLayoutFix !== true) {\\r\\n        current.$content.css(\"margin-bottom\", \"\");\\r\\n\\r\\n        // If we would always set margin-bottom for the content,\\r\\n        // then it would potentially break vertical align\\r\\n        if (current.$content.outerHeight() > current.$slide.height() + 0.5) {\\r\\n          inlinePadding = current.$slide[0].style[\"padding-bottom\"];\\r\\n          actualPadding = current.$slide.css(\"padding-bottom\");\\r\\n\\r\\n          if (parseFloat(actualPadding) > 0) {\\r\\n            scrollHeight = current.$slide[0].scrollHeight;\\r\\n\\r\\n            current.$slide.css(\"padding-bottom\", 0);\\r\\n\\r\\n            if (Math.abs(scrollHeight - current.$slide[0].scrollHeight) < 1) {\\r\\n              marginBottom = actualPadding;\\r\\n            }\\r\\n\\r\\n            current.$slide.css(\"padding-bottom\", inlinePadding);\\r\\n          }\\r\\n        }\\r\\n\\r\\n        current.$content.css(\"margin-bottom\", marginBottom);\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Make content visible\\r\\n    // This method is called right after content has been loaded or\\r\\n    // user navigates gallery and transition should start\\r\\n    // ============================================================\\r\\n\\r\\n    revealContent: function(slide) {\\r\\n      var self = this,\\r\\n        $slide = slide.$slide,\\r\\n        end = false,\\r\\n        start = false,\\r\\n        isMoved = self.isMoved(slide),\\r\\n        isRevealed = slide.isRevealed,\\r\\n        effect,\\r\\n        effectClassName,\\r\\n        duration,\\r\\n        opacity;\\r\\n\\r\\n      slide.isRevealed = true;\\r\\n\\r\\n      effect = slide.opts[self.firstRun ? \"animationEffect\" : \"transitionEffect\"];\\r\\n      duration = slide.opts[self.firstRun ? \"animationDuration\" : \"transitionDuration\"];\\r\\n\\r\\n      duration = parseInt(slide.forcedDuration === undefined ? duration : slide.forcedDuration, 10);\\r\\n\\r\\n      if (isMoved || slide.pos !== self.currPos || !duration) {\\r\\n        effect = false;\\r\\n      }\\r\\n\\r\\n      // Check if can zoom\\r\\n      if (effect === \"zoom\") {\\r\\n        if (slide.pos === self.currPos && duration && slide.type === \"image\" && !slide.hasError && (start = self.getThumbPos(slide))) {\\r\\n          end = self.getFitPos(slide);\\r\\n        } else {\\r\\n          effect = \"fade\";\\r\\n        }\\r\\n      }\\r\\n\\r\\n      // Zoom animation\\r\\n      // ==============\\r\\n      if (effect === \"zoom\") {\\r\\n        self.isAnimating = true;\\r\\n\\r\\n        end.scaleX = end.width / start.width;\\r\\n        end.scaleY = end.height / start.height;\\r\\n\\r\\n        // Check if we need to animate opacity\\r\\n        opacity = slide.opts.zoomOpacity;\\r\\n\\r\\n        if (opacity == \"auto\") {\\r\\n          opacity = Math.abs(slide.width / slide.height - start.width / start.height) > 0.1;\\r\\n        }\\r\\n\\r\\n        if (opacity) {\\r\\n          start.opacity = 0.1;\\r\\n          end.opacity = 1;\\r\\n        }\\r\\n\\r\\n        // Draw image at start position\\r\\n        $.fancybox.setTranslate(slide.$content.removeClass(\"fancybox-is-hidden\"), start);\\r\\n\\r\\n        forceRedraw(slide.$content);\\r\\n\\r\\n        // Start animation\\r\\n        $.fancybox.animate(slide.$content, end, duration, function() {\\r\\n          self.isAnimating = false;\\r\\n\\r\\n          self.complete();\\r\\n        });\\r\\n\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      self.updateSlide(slide);\\r\\n\\r\\n      // Simply show content if no effect\\r\\n      // ================================\\r\\n      if (!effect) {\\r\\n        slide.$content.removeClass(\"fancybox-is-hidden\");\\r\\n\\r\\n        if (!isRevealed && isMoved && slide.type === \"image\" && !slide.hasError) {\\r\\n          slide.$content.hide().fadeIn(\"fast\");\\r\\n        }\\r\\n\\r\\n        if (slide.pos === self.currPos) {\\r\\n          self.complete();\\r\\n        }\\r\\n\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      // Prepare for CSS transiton\\r\\n      // =========================\\r\\n      $.fancybox.stop($slide);\\r\\n\\r\\n      //effectClassName = \"fancybox-animated fancybox-slide--\" + (slide.pos >= self.prevPos ? \"next\" : \"previous\") + \" fancybox-fx-\" + effect;\\r\\n      effectClassName = \"fancybox-slide--\" + (slide.pos >= self.prevPos ? \"next\" : \"previous\") + \" fancybox-animated fancybox-fx-\" + effect;\\r\\n\\r\\n      $slide.addClass(effectClassName).removeClass(\"fancybox-slide--current\"); //.addClass(effectClassName);\\r\\n\\r\\n      slide.$content.removeClass(\"fancybox-is-hidden\");\\r\\n\\r\\n      // Force reflow\\r\\n      forceRedraw($slide);\\r\\n\\r\\n      if (slide.type !== \"image\") {\\r\\n        slide.$content.hide().show(0);\\r\\n      }\\r\\n\\r\\n      $.fancybox.animate(\\r\\n        $slide,\\r\\n        \"fancybox-slide--current\",\\r\\n        duration,\\r\\n        function() {\\r\\n          $slide.removeClass(effectClassName).css({\\r\\n            transform: \"\",\\r\\n            opacity: \"\"\\r\\n          });\\r\\n\\r\\n          if (slide.pos === self.currPos) {\\r\\n            self.complete();\\r\\n          }\\r\\n        },\\r\\n        true\\r\\n      );\\r\\n    },\\r\\n\\r\\n    // Check if we can and have to zoom from thumbnail\\r\\n    //================================================\\r\\n\\r\\n    getThumbPos: function(slide) {\\r\\n      var rez = false,\\r\\n        $thumb = slide.$thumb,\\r\\n        thumbPos,\\r\\n        btw,\\r\\n        brw,\\r\\n        bbw,\\r\\n        blw;\\r\\n\\r\\n      if (!$thumb || !inViewport($thumb[0])) {\\r\\n        return false;\\r\\n      }\\r\\n\\r\\n      thumbPos = $.fancybox.getTranslate($thumb);\\r\\n\\r\\n      btw = parseFloat($thumb.css(\"border-top-width\") || 0);\\r\\n      brw = parseFloat($thumb.css(\"border-right-width\") || 0);\\r\\n      bbw = parseFloat($thumb.css(\"border-bottom-width\") || 0);\\r\\n      blw = parseFloat($thumb.css(\"border-left-width\") || 0);\\r\\n\\r\\n      rez = {\\r\\n        top: thumbPos.top + btw,\\r\\n        left: thumbPos.left + blw,\\r\\n        width: thumbPos.width - brw - blw,\\r\\n        height: thumbPos.height - btw - bbw,\\r\\n        scaleX: 1,\\r\\n        scaleY: 1\\r\\n      };\\r\\n\\r\\n      return thumbPos.width > 0 && thumbPos.height > 0 ? rez : false;\\r\\n    },\\r\\n\\r\\n    // Final adjustments after current gallery item is moved to position\\r\\n    // and it`s content is loaded\\r\\n    // ==================================================================\\r\\n\\r\\n    complete: function() {\\r\\n      var self = this,\\r\\n        current = self.current,\\r\\n        slides = {},\\r\\n        $el;\\r\\n\\r\\n      if (self.isMoved() || !current.isLoaded) {\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      if (!current.isComplete) {\\r\\n        current.isComplete = true;\\r\\n\\r\\n        current.$slide.siblings().trigger(\"onReset\");\\r\\n\\r\\n        self.preload(\"inline\");\\r\\n\\r\\n        // Trigger any CSS transiton inside the slide\\r\\n        forceRedraw(current.$slide);\\r\\n\\r\\n        current.$slide.addClass(\"fancybox-slide--complete\");\\r\\n\\r\\n        // Remove unnecessary slides\\r\\n        $.each(self.slides, function(key, slide) {\\r\\n          if (slide.pos >= self.currPos - 1 && slide.pos <= self.currPos + 1) {\\r\\n            slides[slide.pos] = slide;\\r\\n          } else if (slide) {\\r\\n            $.fancybox.stop(slide.$slide);\\r\\n\\r\\n            slide.$slide.off().remove();\\r\\n          }\\r\\n        });\\r\\n\\r\\n        self.slides = slides;\\r\\n      }\\r\\n\\r\\n      self.isAnimating = false;\\r\\n\\r\\n      self.updateCursor();\\r\\n\\r\\n      self.trigger(\"afterShow\");\\r\\n\\r\\n      // Autoplay first html5 video/audio\\r\\n      if (!!current.opts.video.autoStart) {\\r\\n        current.$slide\\r\\n          .find(\"video,audio\")\\r\\n          .filter(\":visible:first\")\\r\\n          .trigger(\"play\")\\r\\n          .one(\"ended\", function() {\\r\\n            if (this.webkitExitFullscreen) {\\r\\n              this.webkitExitFullscreen();\\r\\n            }\\r\\n\\r\\n            self.next();\\r\\n          });\\r\\n      }\\r\\n\\r\\n      // Try to focus on the first focusable element\\r\\n      if (current.opts.autoFocus && current.contentType === \"html\") {\\r\\n        // Look for the first input with autofocus attribute\\r\\n        $el = current.$content.find(\"input[autofocus]:enabled:visible:first\");\\r\\n\\r\\n        if ($el.length) {\\r\\n          $el.trigger(\"focus\");\\r\\n        } else {\\r\\n          self.focus(null, true);\\r\\n        }\\r\\n      }\\r\\n\\r\\n      // Avoid jumping\\r\\n      current.$slide.scrollTop(0).scrollLeft(0);\\r\\n    },\\r\\n\\r\\n    // Preload next and previous slides\\r\\n    // ================================\\r\\n\\r\\n    preload: function(type) {\\r\\n      var self = this,\\r\\n        prev,\\r\\n        next;\\r\\n\\r\\n      if (self.group.length < 2) {\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      next = self.slides[self.currPos + 1];\\r\\n      prev = self.slides[self.currPos - 1];\\r\\n\\r\\n      if (prev && prev.type === type) {\\r\\n        self.loadSlide(prev);\\r\\n      }\\r\\n\\r\\n      if (next && next.type === type) {\\r\\n        self.loadSlide(next);\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Try to find and focus on the first focusable element\\r\\n    // ====================================================\\r\\n\\r\\n    focus: function(e, firstRun) {\\r\\n      var self = this,\\r\\n        focusableStr = [\\r\\n          \"a[href]\",\\r\\n          \"area[href]\",\\r\\n          \\'input:not([disabled]):not([type=\"hidden\"]):not([aria-hidden])\\',\\r\\n          \"select:not([disabled]):not([aria-hidden])\",\\r\\n          \"textarea:not([disabled]):not([aria-hidden])\",\\r\\n          \"button:not([disabled]):not([aria-hidden])\",\\r\\n          \"iframe\",\\r\\n          \"object\",\\r\\n          \"embed\",\\r\\n          \"video\",\\r\\n          \"audio\",\\r\\n          \"[contenteditable]\",\\r\\n          \\'[tabindex]:not([tabindex^=\"-\"])\\'\\r\\n        ].join(\",\"),\\r\\n        focusableItems,\\r\\n        focusedItemIndex;\\r\\n\\r\\n      if (self.isClosing) {\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      if (e || !self.current || !self.current.isComplete) {\\r\\n        // Focus on any element inside fancybox\\r\\n        focusableItems = self.$refs.container.find(\"*:visible\");\\r\\n      } else {\\r\\n        // Focus inside current slide\\r\\n        focusableItems = self.current.$slide.find(\"*:visible\" + (firstRun ? \":not(.fancybox-close-small)\" : \"\"));\\r\\n      }\\r\\n\\r\\n      focusableItems = focusableItems.filter(focusableStr).filter(function() {\\r\\n        return $(this).css(\"visibility\") !== \"hidden\" && !$(this).hasClass(\"disabled\");\\r\\n      });\\r\\n\\r\\n      if (focusableItems.length) {\\r\\n        focusedItemIndex = focusableItems.index(document.activeElement);\\r\\n\\r\\n        if (e && e.shiftKey) {\\r\\n          // Back tab\\r\\n          if (focusedItemIndex < 0 || focusedItemIndex == 0) {\\r\\n            e.preventDefault();\\r\\n\\r\\n            focusableItems.eq(focusableItems.length - 1).trigger(\"focus\");\\r\\n          }\\r\\n        } else {\\r\\n          // Outside or Forward tab\\r\\n          if (focusedItemIndex < 0 || focusedItemIndex == focusableItems.length - 1) {\\r\\n            if (e) {\\r\\n              e.preventDefault();\\r\\n            }\\r\\n\\r\\n            focusableItems.eq(0).trigger(\"focus\");\\r\\n          }\\r\\n        }\\r\\n      } else {\\r\\n        self.$refs.container.trigger(\"focus\");\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Activates current instance - brings container to the front and enables keyboard,\\r\\n    // notifies other instances about deactivating\\r\\n    // =================================================================================\\r\\n\\r\\n    activate: function() {\\r\\n      var self = this;\\r\\n\\r\\n      // Deactivate all instances\\r\\n      $(\".fancybox-container\").each(function() {\\r\\n        var instance = $(this).data(\"FancyBox\");\\r\\n\\r\\n        // Skip self and closing instances\\r\\n        if (instance && instance.id !== self.id && !instance.isClosing) {\\r\\n          instance.trigger(\"onDeactivate\");\\r\\n\\r\\n          instance.removeEvents();\\r\\n\\r\\n          instance.isVisible = false;\\r\\n        }\\r\\n      });\\r\\n\\r\\n      self.isVisible = true;\\r\\n\\r\\n      if (self.current || self.isIdle) {\\r\\n        self.update();\\r\\n\\r\\n        self.updateControls();\\r\\n      }\\r\\n\\r\\n      self.trigger(\"onActivate\");\\r\\n\\r\\n      self.addEvents();\\r\\n    },\\r\\n\\r\\n    // Start closing procedure\\r\\n    // This will start \"zoom-out\" animation if needed and clean everything up afterwards\\r\\n    // =================================================================================\\r\\n\\r\\n    close: function(e, d) {\\r\\n      var self = this,\\r\\n        current = self.current,\\r\\n        effect,\\r\\n        duration,\\r\\n        $content,\\r\\n        domRect,\\r\\n        opacity,\\r\\n        start,\\r\\n        end;\\r\\n\\r\\n      var done = function() {\\r\\n        self.cleanUp(e);\\r\\n      };\\r\\n\\r\\n      if (self.isClosing) {\\r\\n        return false;\\r\\n      }\\r\\n\\r\\n      self.isClosing = true;\\r\\n\\r\\n      // If beforeClose callback prevents closing, make sure content is centered\\r\\n      if (self.trigger(\"beforeClose\", e) === false) {\\r\\n        self.isClosing = false;\\r\\n\\r\\n        requestAFrame(function() {\\r\\n          self.update();\\r\\n        });\\r\\n\\r\\n        return false;\\r\\n      }\\r\\n\\r\\n      // Remove all events\\r\\n      // If there are multiple instances, they will be set again by \"activate\" method\\r\\n      self.removeEvents();\\r\\n\\r\\n      $content = current.$content;\\r\\n      effect = current.opts.animationEffect;\\r\\n      duration = $.isNumeric(d) ? d : effect ? current.opts.animationDuration : 0;\\r\\n\\r\\n      current.$slide.removeClass(\"fancybox-slide--complete fancybox-slide--next fancybox-slide--previous fancybox-animated\");\\r\\n\\r\\n      if (e !== true) {\\r\\n        $.fancybox.stop(current.$slide);\\r\\n      } else {\\r\\n        effect = false;\\r\\n      }\\r\\n\\r\\n      // Remove other slides\\r\\n      current.$slide\\r\\n        .siblings()\\r\\n        .trigger(\"onReset\")\\r\\n        .remove();\\r\\n\\r\\n      // Trigger animations\\r\\n      if (duration) {\\r\\n        self.$refs.container\\r\\n          .removeClass(\"fancybox-is-open\")\\r\\n          .addClass(\"fancybox-is-closing\")\\r\\n          .css(\"transition-duration\", duration + \"ms\");\\r\\n      }\\r\\n\\r\\n      // Clean up\\r\\n      self.hideLoading(current);\\r\\n\\r\\n      self.hideControls(true);\\r\\n\\r\\n      self.updateCursor();\\r\\n\\r\\n      // Check if possible to zoom-out\\r\\n      if (\\r\\n        effect === \"zoom\" &&\\r\\n        !($content && duration && current.type === \"image\" && !self.isMoved() && !current.hasError && (end = self.getThumbPos(current)))\\r\\n      ) {\\r\\n        effect = \"fade\";\\r\\n      }\\r\\n\\r\\n      if (effect === \"zoom\") {\\r\\n        $.fancybox.stop($content);\\r\\n\\r\\n        domRect = $.fancybox.getTranslate($content);\\r\\n\\r\\n        start = {\\r\\n          top: domRect.top,\\r\\n          left: domRect.left,\\r\\n          scaleX: domRect.width / end.width,\\r\\n          scaleY: domRect.height / end.height,\\r\\n          width: end.width,\\r\\n          height: end.height\\r\\n        };\\r\\n\\r\\n        // Check if we need to animate opacity\\r\\n        opacity = current.opts.zoomOpacity;\\r\\n\\r\\n        if (opacity == \"auto\") {\\r\\n          opacity = Math.abs(current.width / current.height - end.width / end.height) > 0.1;\\r\\n        }\\r\\n\\r\\n        if (opacity) {\\r\\n          end.opacity = 0;\\r\\n        }\\r\\n\\r\\n        $.fancybox.setTranslate($content, start);\\r\\n\\r\\n        forceRedraw($content);\\r\\n\\r\\n        $.fancybox.animate($content, end, duration, done);\\r\\n\\r\\n        return true;\\r\\n      }\\r\\n\\r\\n      if (effect && duration) {\\r\\n        $.fancybox.animate(\\r\\n          current.$slide.addClass(\"fancybox-slide--previous\").removeClass(\"fancybox-slide--current\"),\\r\\n          \"fancybox-animated fancybox-fx-\" + effect,\\r\\n          duration,\\r\\n          done\\r\\n        );\\r\\n      } else {\\r\\n        // If skip animation\\r\\n        if (e === true) {\\r\\n          setTimeout(done, duration);\\r\\n        } else {\\r\\n          done();\\r\\n        }\\r\\n      }\\r\\n\\r\\n      return true;\\r\\n    },\\r\\n\\r\\n    // Final adjustments after removing the instance\\r\\n    // =============================================\\r\\n\\r\\n    cleanUp: function(e) {\\r\\n      var self = this,\\r\\n        instance,\\r\\n        $focus = self.current.opts.$orig,\\r\\n        x,\\r\\n        y;\\r\\n\\r\\n      self.current.$slide.trigger(\"onReset\");\\r\\n\\r\\n      self.$refs.container.empty().remove();\\r\\n\\r\\n      self.trigger(\"afterClose\", e);\\r\\n\\r\\n      // Place back focus\\r\\n      if (!!self.current.opts.backFocus) {\\r\\n        if (!$focus || !$focus.length || !$focus.is(\":visible\")) {\\r\\n          $focus = self.$trigger;\\r\\n        }\\r\\n\\r\\n        if ($focus && $focus.length) {\\r\\n          x = window.scrollX;\\r\\n          y = window.scrollY;\\r\\n\\r\\n          $focus.trigger(\"focus\");\\r\\n\\r\\n          $(\"html, body\")\\r\\n            .scrollTop(y)\\r\\n            .scrollLeft(x);\\r\\n        }\\r\\n      }\\r\\n\\r\\n      self.current = null;\\r\\n\\r\\n      // Check if there are other instances\\r\\n      instance = $.fancybox.getInstance();\\r\\n\\r\\n      if (instance) {\\r\\n        instance.activate();\\r\\n      } else {\\r\\n        $(\"body\").removeClass(\"fancybox-active compensate-for-scrollbar\");\\r\\n\\r\\n        $(\"#fancybox-style-noscroll\").remove();\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Call callback and trigger an event\\r\\n    // ==================================\\r\\n\\r\\n    trigger: function(name, slide) {\\r\\n      var args = Array.prototype.slice.call(arguments, 1),\\r\\n        self = this,\\r\\n        obj = slide && slide.opts ? slide : self.current,\\r\\n        rez;\\r\\n\\r\\n      if (obj) {\\r\\n        args.unshift(obj);\\r\\n      } else {\\r\\n        obj = self;\\r\\n      }\\r\\n\\r\\n      args.unshift(self);\\r\\n\\r\\n      if ($.isFunction(obj.opts[name])) {\\r\\n        rez = obj.opts[name].apply(obj, args);\\r\\n      }\\r\\n\\r\\n      if (rez === false) {\\r\\n        return rez;\\r\\n      }\\r\\n\\r\\n      if (name === \"afterClose\" || !self.$refs) {\\r\\n        $D.trigger(name + \".fb\", args);\\r\\n      } else {\\r\\n        self.$refs.container.trigger(name + \".fb\", args);\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Update infobar values, navigation button states and reveal caption\\r\\n    // ==================================================================\\r\\n\\r\\n    updateControls: function() {\\r\\n      var self = this,\\r\\n        current = self.current,\\r\\n        index = current.index,\\r\\n        $container = self.$refs.container,\\r\\n        $caption = self.$refs.caption,\\r\\n        caption = current.opts.caption;\\r\\n\\r\\n      // Recalculate content dimensions\\r\\n      current.$slide.trigger(\"refresh\");\\r\\n\\r\\n      // Set caption\\r\\n      if (caption && caption.length) {\\r\\n        self.$caption = $caption;\\r\\n\\r\\n        $caption\\r\\n          .children()\\r\\n          .eq(0)\\r\\n          .html(caption);\\r\\n      } else {\\r\\n        self.$caption = null;\\r\\n      }\\r\\n\\r\\n      if (!self.hasHiddenControls && !self.isIdle) {\\r\\n        self.showControls();\\r\\n      }\\r\\n\\r\\n      // Update info and navigation elements\\r\\n      $container.find(\"[data-fancybox-count]\").html(self.group.length);\\r\\n      $container.find(\"[data-fancybox-index]\").html(index + 1);\\r\\n\\r\\n      $container.find(\"[data-fancybox-prev]\").prop(\"disabled\", !current.opts.loop && index <= 0);\\r\\n      $container.find(\"[data-fancybox-next]\").prop(\"disabled\", !current.opts.loop && index >= self.group.length - 1);\\r\\n\\r\\n      if (current.type === \"image\") {\\r\\n        // Re-enable buttons; update download button source\\r\\n        $container\\r\\n          .find(\"[data-fancybox-zoom]\")\\r\\n          .show()\\r\\n          .end()\\r\\n          .find(\"[data-fancybox-download]\")\\r\\n          .attr(\"href\", current.opts.image.src || current.src)\\r\\n          .show();\\r\\n      } else if (current.opts.toolbar) {\\r\\n        $container.find(\"[data-fancybox-download],[data-fancybox-zoom]\").hide();\\r\\n      }\\r\\n\\r\\n      // Make sure focus is not on disabled button/element\\r\\n      if ($(document.activeElement).is(\":hidden,[disabled]\")) {\\r\\n        self.$refs.container.trigger(\"focus\");\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Hide toolbar and caption\\r\\n    // ========================\\r\\n\\r\\n    hideControls: function(andCaption) {\\r\\n      var self = this,\\r\\n        arr = [\"infobar\", \"toolbar\", \"nav\"];\\r\\n\\r\\n      if (andCaption || !self.current.opts.preventCaptionOverlap) {\\r\\n        arr.push(\"caption\");\\r\\n      }\\r\\n\\r\\n      this.$refs.container.removeClass(\\r\\n        arr\\r\\n          .map(function(i) {\\r\\n            return \"fancybox-show-\" + i;\\r\\n          })\\r\\n          .join(\" \")\\r\\n      );\\r\\n\\r\\n      this.hasHiddenControls = true;\\r\\n    },\\r\\n\\r\\n    showControls: function() {\\r\\n      var self = this,\\r\\n        opts = self.current ? self.current.opts : self.opts,\\r\\n        $container = self.$refs.container;\\r\\n\\r\\n      self.hasHiddenControls = false;\\r\\n      self.idleSecondsCounter = 0;\\r\\n\\r\\n      $container\\r\\n        .toggleClass(\"fancybox-show-toolbar\", !!(opts.toolbar && opts.buttons))\\r\\n        .toggleClass(\"fancybox-show-infobar\", !!(opts.infobar && self.group.length > 1))\\r\\n        .toggleClass(\"fancybox-show-caption\", !!self.$caption)\\r\\n        .toggleClass(\"fancybox-show-nav\", !!(opts.arrows && self.group.length > 1))\\r\\n        .toggleClass(\"fancybox-is-modal\", !!opts.modal);\\r\\n    },\\r\\n\\r\\n    // Toggle toolbar and caption\\r\\n    // ==========================\\r\\n\\r\\n    toggleControls: function() {\\r\\n      if (this.hasHiddenControls) {\\r\\n        this.showControls();\\r\\n      } else {\\r\\n        this.hideControls();\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n\\r\\n  $.fancybox = {\\r\\n    version: \"3.5.6\",\\r\\n    defaults: defaults,\\r\\n\\r\\n    // Get current instance and execute a command.\\r\\n    //\\r\\n    // Examples of usage:\\r\\n    //\\r\\n    //   $instance = $.fancybox.getInstance();\\r\\n    //   $.fancybox.getInstance().jumpTo( 1 );\\r\\n    //   $.fancybox.getInstance( \\'jumpTo\\', 1 );\\r\\n    //   $.fancybox.getInstance( function() {\\r\\n    //       console.info( this.currIndex );\\r\\n    //   });\\r\\n    // ======================================================\\r\\n\\r\\n    getInstance: function(command) {\\r\\n      var instance = $(\\'.fancybox-container:not(\".fancybox-is-closing\"):last\\').data(\"FancyBox\"),\\r\\n        args = Array.prototype.slice.call(arguments, 1);\\r\\n\\r\\n      if (instance instanceof FancyBox) {\\r\\n        if ($.type(command) === \"string\") {\\r\\n          instance[command].apply(instance, args);\\r\\n        } else if ($.type(command) === \"function\") {\\r\\n          command.apply(instance, args);\\r\\n        }\\r\\n\\r\\n        return instance;\\r\\n      }\\r\\n\\r\\n      return false;\\r\\n    },\\r\\n\\r\\n    // Create new instance\\r\\n    // ===================\\r\\n\\r\\n    open: function(items, opts, index) {\\r\\n      return new FancyBox(items, opts, index);\\r\\n    },\\r\\n\\r\\n    // Close current or all instances\\r\\n    // ==============================\\r\\n\\r\\n    close: function(all) {\\r\\n      var instance = this.getInstance();\\r\\n\\r\\n      if (instance) {\\r\\n        instance.close();\\r\\n\\r\\n        // Try to find and close next instance\\r\\n        if (all === true) {\\r\\n          this.close(all);\\r\\n        }\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Close all instances and unbind all events\\r\\n    // =========================================\\r\\n\\r\\n    destroy: function() {\\r\\n      this.close(true);\\r\\n\\r\\n      $D.add(\"body\").off(\"click.fb-start\", \"**\");\\r\\n    },\\r\\n\\r\\n    // Try to detect mobile devices\\r\\n    // ============================\\r\\n\\r\\n    isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),\\r\\n\\r\\n    // Detect if \\'translate3d\\' support is available\\r\\n    // ============================================\\r\\n\\r\\n    use3d: (function() {\\r\\n      var div = document.createElement(\"div\");\\r\\n\\r\\n      return (\\r\\n        window.getComputedStyle &&\\r\\n        window.getComputedStyle(div) &&\\r\\n        window.getComputedStyle(div).getPropertyValue(\"transform\") &&\\r\\n        !(document.documentMode && document.documentMode < 11)\\r\\n      );\\r\\n    })(),\\r\\n\\r\\n    // Helper function to get current visual state of an element\\r\\n    // returns array[ top, left, horizontal-scale, vertical-scale, opacity ]\\r\\n    // =====================================================================\\r\\n\\r\\n    getTranslate: function($el) {\\r\\n      var domRect;\\r\\n\\r\\n      if (!$el || !$el.length) {\\r\\n        return false;\\r\\n      }\\r\\n\\r\\n      domRect = $el[0].getBoundingClientRect();\\r\\n\\r\\n      return {\\r\\n        top: domRect.top || 0,\\r\\n        left: domRect.left || 0,\\r\\n        width: domRect.width,\\r\\n        height: domRect.height,\\r\\n        opacity: parseFloat($el.css(\"opacity\"))\\r\\n      };\\r\\n    },\\r\\n\\r\\n    // Shortcut for setting \"translate3d\" properties for element\\r\\n    // Can set be used to set opacity, too\\r\\n    // ========================================================\\r\\n\\r\\n    setTranslate: function($el, props) {\\r\\n      var str = \"\",\\r\\n        css = {};\\r\\n\\r\\n      if (!$el || !props) {\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      if (props.left !== undefined || props.top !== undefined) {\\r\\n        str =\\r\\n          (props.left === undefined ? $el.position().left : props.left) +\\r\\n          \"px, \" +\\r\\n          (props.top === undefined ? $el.position().top : props.top) +\\r\\n          \"px\";\\r\\n\\r\\n        if (this.use3d) {\\r\\n          str = \"translate3d(\" + str + \", 0px)\";\\r\\n        } else {\\r\\n          str = \"translate(\" + str + \")\";\\r\\n        }\\r\\n      }\\r\\n\\r\\n      if (props.scaleX !== undefined && props.scaleY !== undefined) {\\r\\n        str += \" scale(\" + props.scaleX + \", \" + props.scaleY + \")\";\\r\\n      } else if (props.scaleX !== undefined) {\\r\\n        str += \" scaleX(\" + props.scaleX + \")\";\\r\\n      }\\r\\n\\r\\n      if (str.length) {\\r\\n        css.transform = str;\\r\\n      }\\r\\n\\r\\n      if (props.opacity !== undefined) {\\r\\n        css.opacity = props.opacity;\\r\\n      }\\r\\n\\r\\n      if (props.width !== undefined) {\\r\\n        css.width = props.width;\\r\\n      }\\r\\n\\r\\n      if (props.height !== undefined) {\\r\\n        css.height = props.height;\\r\\n      }\\r\\n\\r\\n      return $el.css(css);\\r\\n    },\\r\\n\\r\\n    // Simple CSS transition handler\\r\\n    // =============================\\r\\n\\r\\n    animate: function($el, to, duration, callback, leaveAnimationName) {\\r\\n      var self = this,\\r\\n        from;\\r\\n\\r\\n      if ($.isFunction(duration)) {\\r\\n        callback = duration;\\r\\n        duration = null;\\r\\n      }\\r\\n\\r\\n      self.stop($el);\\r\\n\\r\\n      from = self.getTranslate($el);\\r\\n\\r\\n      $el.on(transitionEnd, function(e) {\\r\\n        // Skip events from child elements and z-index change\\r\\n        if (e && e.originalEvent && (!$el.is(e.originalEvent.target) || e.originalEvent.propertyName == \"z-index\")) {\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        self.stop($el);\\r\\n\\r\\n        if ($.isNumeric(duration)) {\\r\\n          $el.css(\"transition-duration\", \"\");\\r\\n        }\\r\\n\\r\\n        if ($.isPlainObject(to)) {\\r\\n          if (to.scaleX !== undefined && to.scaleY !== undefined) {\\r\\n            self.setTranslate($el, {\\r\\n              top: to.top,\\r\\n              left: to.left,\\r\\n              width: from.width * to.scaleX,\\r\\n              height: from.height * to.scaleY,\\r\\n              scaleX: 1,\\r\\n              scaleY: 1\\r\\n            });\\r\\n          }\\r\\n        } else if (leaveAnimationName !== true) {\\r\\n          $el.removeClass(to);\\r\\n        }\\r\\n\\r\\n        if ($.isFunction(callback)) {\\r\\n          callback(e);\\r\\n        }\\r\\n      });\\r\\n\\r\\n      if ($.isNumeric(duration)) {\\r\\n        $el.css(\"transition-duration\", duration + \"ms\");\\r\\n      }\\r\\n\\r\\n      // Start animation by changing CSS properties or class name\\r\\n      if ($.isPlainObject(to)) {\\r\\n        if (to.scaleX !== undefined && to.scaleY !== undefined) {\\r\\n          delete to.width;\\r\\n          delete to.height;\\r\\n\\r\\n          if ($el.parent().hasClass(\"fancybox-slide--image\")) {\\r\\n            $el.parent().addClass(\"fancybox-is-scaling\");\\r\\n          }\\r\\n        }\\r\\n\\r\\n        $.fancybox.setTranslate($el, to);\\r\\n      } else {\\r\\n        $el.addClass(to);\\r\\n      }\\r\\n\\r\\n      // Make sure that `transitionend` callback gets fired\\r\\n      $el.data(\\r\\n        \"timer\",\\r\\n        setTimeout(function() {\\r\\n          $el.trigger(transitionEnd);\\r\\n        }, duration + 33)\\r\\n      );\\r\\n    },\\r\\n\\r\\n    stop: function($el, callCallback) {\\r\\n      if ($el && $el.length) {\\r\\n        clearTimeout($el.data(\"timer\"));\\r\\n\\r\\n        if (callCallback) {\\r\\n          $el.trigger(transitionEnd);\\r\\n        }\\r\\n\\r\\n        $el.off(transitionEnd).css(\"transition-duration\", \"\");\\r\\n\\r\\n        $el.parent().removeClass(\"fancybox-is-scaling\");\\r\\n      }\\r\\n    }\\r\\n  };\\r\\n\\r\\n  // Default click handler for \"fancyboxed\" links\\r\\n  // ============================================\\r\\n\\r\\n  function _run(e, opts) {\\r\\n    var items = [],\\r\\n      index = 0,\\r\\n      $target,\\r\\n      value,\\r\\n      instance;\\r\\n\\r\\n    // Avoid opening multiple times\\r\\n    if (e && e.isDefaultPrevented()) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    e.preventDefault();\\r\\n\\r\\n    opts = opts || {};\\r\\n\\r\\n    if (e && e.data) {\\r\\n      opts = mergeOpts(e.data.options, opts);\\r\\n    }\\r\\n\\r\\n    $target = opts.$target || $(e.currentTarget).trigger(\"blur\");\\r\\n    instance = $.fancybox.getInstance();\\r\\n\\r\\n    if (instance && instance.$trigger && instance.$trigger.is($target)) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    if (opts.selector) {\\r\\n      items = $(opts.selector);\\r\\n    } else {\\r\\n      // Get all related items and find index for clicked one\\r\\n      value = $target.attr(\"data-fancybox\") || \"\";\\r\\n\\r\\n      if (value) {\\r\\n        items = e.data ? e.data.items : [];\\r\\n        items = items.length ? items.filter(\\'[data-fancybox=\"\\' + value + \\'\"]\\') : $(\\'[data-fancybox=\"\\' + value + \\'\"]\\');\\r\\n      } else {\\r\\n        items = [$target];\\r\\n      }\\r\\n    }\\r\\n\\r\\n    index = $(items).index($target);\\r\\n\\r\\n    // Sometimes current item can not be found\\r\\n    if (index < 0) {\\r\\n      index = 0;\\r\\n    }\\r\\n\\r\\n    instance = $.fancybox.open(items, opts, index);\\r\\n\\r\\n    // Save last active element\\r\\n    instance.$trigger = $target;\\r\\n  }\\r\\n\\r\\n  // Create a jQuery plugin\\r\\n  // ======================\\r\\n\\r\\n  $.fn.fancybox = function(options) {\\r\\n    var selector;\\r\\n\\r\\n    options = options || {};\\r\\n    selector = options.selector || false;\\r\\n\\r\\n    if (selector) {\\r\\n      // Use body element instead of document so it executes first\\r\\n      $(\"body\")\\r\\n        .off(\"click.fb-start\", selector)\\r\\n        .on(\"click.fb-start\", selector, {options: options}, _run);\\r\\n    } else {\\r\\n      this.off(\"click.fb-start\").on(\\r\\n        \"click.fb-start\",\\r\\n        {\\r\\n          items: this,\\r\\n          options: options\\r\\n        },\\r\\n        _run\\r\\n      );\\r\\n    }\\r\\n\\r\\n    return this;\\r\\n  };\\r\\n\\r\\n  // Self initializing plugin for all elements having `data-fancybox` attribute\\r\\n  // ==========================================================================\\r\\n\\r\\n  $D.on(\"click.fb-start\", \"[data-fancybox]\", _run);\\r\\n\\r\\n  // Enable \"trigger elements\"\\r\\n  // =========================\\r\\n\\r\\n  $D.on(\"click.fb-start\", \"[data-fancybox-trigger]\", function(e) {\\r\\n    $(\\'[data-fancybox=\"\\' + $(this).attr(\"data-fancybox-trigger\") + \\'\"]\\')\\r\\n      .eq($(this).attr(\"data-fancybox-index\") || 0)\\r\\n      .trigger(\"click.fb-start\", {\\r\\n        $trigger: $(this)\\r\\n      });\\r\\n  });\\r\\n\\r\\n  // Track focus event for better accessibility styling\\r\\n  // ==================================================\\r\\n  (function() {\\r\\n    var buttonStr = \".fancybox-button\",\\r\\n      focusStr = \"fancybox-focus\",\\r\\n      $pressed = null;\\r\\n\\r\\n    $D.on(\"mousedown mouseup focus blur\", buttonStr, function(e) {\\r\\n      switch (e.type) {\\r\\n        case \"mousedown\":\\r\\n          $pressed = $(this);\\r\\n          break;\\r\\n        case \"mouseup\":\\r\\n          $pressed = null;\\r\\n          break;\\r\\n        case \"focusin\":\\r\\n          $(buttonStr).removeClass(focusStr);\\r\\n\\r\\n          if (!$(this).is($pressed) && !$(this).is(\"[disabled]\")) {\\r\\n            $(this).addClass(focusStr);\\r\\n          }\\r\\n          break;\\r\\n        case \"focusout\":\\r\\n          $(buttonStr).removeClass(focusStr);\\r\\n          break;\\r\\n      }\\r\\n    });\\r\\n  })();\\r\\n})(window, document, jQuery);\\r\\n\\n// ==========================================================================\\r\\n//\\r\\n// Media\\r\\n// Adds additional media type support\\r\\n//\\r\\n// ==========================================================================\\r\\n(function($) {\\r\\n  \"use strict\";\\r\\n\\r\\n  // Object containing properties for each media type\\r\\n  var defaults = {\\r\\n    youtube: {\\r\\n      matcher: /(youtube\\\\.com|youtu\\\\.be|youtube\\\\-nocookie\\\\.com)\\\\/(watch\\\\?(.*&)?v=|v\\\\/|u\\\\/|embed\\\\/?)?(videoseries\\\\?list=(.*)|[\\\\w-]{11}|\\\\?listType=(.*)&list=(.*))(.*)/i,\\r\\n      params: {\\r\\n        autoplay: 1,\\r\\n        autohide: 1,\\r\\n        fs: 1,\\r\\n        rel: 0,\\r\\n        hd: 1,\\r\\n        wmode: \"transparent\",\\r\\n        enablejsapi: 1,\\r\\n        html5: 1\\r\\n      },\\r\\n      paramPlace: 8,\\r\\n      type: \"iframe\",\\r\\n      url: \"https://www.youtube-nocookie.com/embed/$4\",\\r\\n      thumb: \"https://img.youtube.com/vi/$4/hqdefault.jpg\"\\r\\n    },\\r\\n\\r\\n    vimeo: {\\r\\n      matcher: /^.+vimeo.com\\\\/(.*\\\\/)?([\\\\d]+)(.*)?/,\\r\\n      params: {\\r\\n        autoplay: 1,\\r\\n        hd: 1,\\r\\n        show_title: 1,\\r\\n        show_byline: 1,\\r\\n        show_portrait: 0,\\r\\n        fullscreen: 1\\r\\n      },\\r\\n      paramPlace: 3,\\r\\n      type: \"iframe\",\\r\\n      url: \"//player.vimeo.com/video/$2\"\\r\\n    },\\r\\n\\r\\n    instagram: {\\r\\n      matcher: /(instagr\\\\.am|instagram\\\\.com)\\\\/p\\\\/([a-zA-Z0-9_\\\\-]+)\\\\/?/i,\\r\\n      type: \"image\",\\r\\n      url: \"//$1/p/$2/media/?size=l\"\\r\\n    },\\r\\n\\r\\n    // Examples:\\r\\n    // http://maps.google.com/?ll=48.857995,2.294297&spn=0.007666,0.021136&t=m&z=16\\r\\n    // https://www.google.com/maps/@37.7852006,-122.4146355,14.65z\\r\\n    // https://www.google.com/maps/@52.2111123,2.9237542,6.61z?hl=en\\r\\n    // https://www.google.com/maps/place/Googleplex/@37.4220041,-122.0833494,17z/data=!4m5!3m4!1s0x0:0x6c296c66619367e0!8m2!3d37.4219998!4d-122.0840572\\r\\n    gmap_place: {\\r\\n      matcher: /(maps\\\\.)?google\\\\.([a-z]{2,3}(\\\\.[a-z]{2})?)\\\\/(((maps\\\\/(place\\\\/(.*)\\\\/)?\\\\@(.*),(\\\\d+.?\\\\d+?)z))|(\\\\?ll=))(.*)?/i,\\r\\n      type: \"iframe\",\\r\\n      url: function(rez) {\\r\\n        return (\\r\\n          \"//maps.google.\" +\\r\\n          rez[2] +\\r\\n          \"/?ll=\" +\\r\\n          (rez[9] ? rez[9] + \"&z=\" + Math.floor(rez[10]) + (rez[12] ? rez[12].replace(/^\\\\//, \"&\") : \"\") : rez[12] + \"\").replace(/\\\\?/, \"&\") +\\r\\n          \"&output=\" +\\r\\n          (rez[12] && rez[12].indexOf(\"layer=c\") > 0 ? \"svembed\" : \"embed\")\\r\\n        );\\r\\n      }\\r\\n    },\\r\\n\\r\\n    // Examples:\\r\\n    // https://www.google.com/maps/search/Empire+State+Building/\\r\\n    // https://www.google.com/maps/search/?api=1&query=centurylink+field\\r\\n    // https://www.google.com/maps/search/?api=1&query=47.5951518,-122.3316393\\r\\n    gmap_search: {\\r\\n      matcher: /(maps\\\\.)?google\\\\.([a-z]{2,3}(\\\\.[a-z]{2})?)\\\\/(maps\\\\/search\\\\/)(.*)/i,\\r\\n      type: \"iframe\",\\r\\n      url: function(rez) {\\r\\n        return \"//maps.google.\" + rez[2] + \"/maps?q=\" + rez[5].replace(\"query=\", \"q=\").replace(\"api=1\", \"\") + \"&output=embed\";\\r\\n      }\\r\\n    }\\r\\n  };\\r\\n\\r\\n  // Formats matching url to final form\\r\\n  var format = function(url, rez, params) {\\r\\n    if (!url) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    params = params || \"\";\\r\\n\\r\\n    if ($.type(params) === \"object\") {\\r\\n      params = $.param(params, true);\\r\\n    }\\r\\n\\r\\n    $.each(rez, function(key, value) {\\r\\n      url = url.replace(\"$\" + key, value || \"\");\\r\\n    });\\r\\n\\r\\n    if (params.length) {\\r\\n      url += (url.indexOf(\"?\") > 0 ? \"&\" : \"?\") + params;\\r\\n    }\\r\\n\\r\\n    return url;\\r\\n  };\\r\\n\\r\\n  $(document).on(\"objectNeedsType.fb\", function(e, instance, item) {\\r\\n    var url = item.src || \"\",\\r\\n      type = false,\\r\\n      media,\\r\\n      thumb,\\r\\n      rez,\\r\\n      params,\\r\\n      urlParams,\\r\\n      paramObj,\\r\\n      provider;\\r\\n\\r\\n    media = $.extend(true, {}, defaults, item.opts.media);\\r\\n\\r\\n    // Look for any matching media type\\r\\n    $.each(media, function(providerName, providerOpts) {\\r\\n      rez = url.match(providerOpts.matcher);\\r\\n\\r\\n      if (!rez) {\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      type = providerOpts.type;\\r\\n      provider = providerName;\\r\\n      paramObj = {};\\r\\n\\r\\n      if (providerOpts.paramPlace && rez[providerOpts.paramPlace]) {\\r\\n        urlParams = rez[providerOpts.paramPlace];\\r\\n\\r\\n        if (urlParams[0] == \"?\") {\\r\\n          urlParams = urlParams.substring(1);\\r\\n        }\\r\\n\\r\\n        urlParams = urlParams.split(\"&\");\\r\\n\\r\\n        for (var m = 0; m < urlParams.length; ++m) {\\r\\n          var p = urlParams[m].split(\"=\", 2);\\r\\n\\r\\n          if (p.length == 2) {\\r\\n            paramObj[p[0]] = decodeURIComponent(p[1].replace(/\\\\+/g, \" \"));\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n\\r\\n      params = $.extend(true, {}, providerOpts.params, item.opts[providerName], paramObj);\\r\\n\\r\\n      url =\\r\\n        $.type(providerOpts.url) === \"function\" ? providerOpts.url.call(this, rez, params, item) : format(providerOpts.url, rez, params);\\r\\n\\r\\n      thumb =\\r\\n        $.type(providerOpts.thumb) === \"function\" ? providerOpts.thumb.call(this, rez, params, item) : format(providerOpts.thumb, rez);\\r\\n\\r\\n      if (providerName === \"youtube\") {\\r\\n        url = url.replace(/&t=((\\\\d+)m)?(\\\\d+)s/, function(match, p1, m, s) {\\r\\n          return \"&start=\" + ((m ? parseInt(m, 10) * 60 : 0) + parseInt(s, 10));\\r\\n        });\\r\\n      } else if (providerName === \"vimeo\") {\\r\\n        url = url.replace(\"&%23\", \"#\");\\r\\n      }\\r\\n\\r\\n      return false;\\r\\n    });\\r\\n\\r\\n    // If it is found, then change content type and update the url\\r\\n\\r\\n    if (type) {\\r\\n      if (!item.opts.thumb && !(item.opts.$thumb && item.opts.$thumb.length)) {\\r\\n        item.opts.thumb = thumb;\\r\\n      }\\r\\n\\r\\n      if (type === \"iframe\") {\\r\\n        item.opts = $.extend(true, item.opts, {\\r\\n          iframe: {\\r\\n            preload: false,\\r\\n            attr: {\\r\\n              scrolling: \"no\"\\r\\n            }\\r\\n          }\\r\\n        });\\r\\n      }\\r\\n\\r\\n      $.extend(item, {\\r\\n        type: type,\\r\\n        src: url,\\r\\n        origSrc: item.src,\\r\\n        contentSource: provider,\\r\\n        contentType: type === \"image\" ? \"image\" : provider == \"gmap_place\" || provider == \"gmap_search\" ? \"map\" : \"video\"\\r\\n      });\\r\\n    } else if (url) {\\r\\n      item.type = item.opts.defaultType;\\r\\n    }\\r\\n  });\\r\\n\\r\\n  // Load YouTube/Video API on request to detect when video finished playing\\r\\n  var VideoAPILoader = {\\r\\n    youtube: {\\r\\n      src: \"https://www.youtube.com/iframe_api\",\\r\\n      class: \"YT\",\\r\\n      loading: false,\\r\\n      loaded: false\\r\\n    },\\r\\n\\r\\n    vimeo: {\\r\\n      src: \"https://player.vimeo.com/api/player.js\",\\r\\n      class: \"Vimeo\",\\r\\n      loading: false,\\r\\n      loaded: false\\r\\n    },\\r\\n\\r\\n    load: function(vendor) {\\r\\n      var _this = this,\\r\\n        script;\\r\\n\\r\\n      if (this[vendor].loaded) {\\r\\n        setTimeout(function() {\\r\\n          _this.done(vendor);\\r\\n        });\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      if (this[vendor].loading) {\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      this[vendor].loading = true;\\r\\n\\r\\n      script = document.createElement(\"script\");\\r\\n      script.type = \"text/javascript\";\\r\\n      script.src = this[vendor].src;\\r\\n\\r\\n      if (vendor === \"youtube\") {\\r\\n        window.onYouTubeIframeAPIReady = function() {\\r\\n          _this[vendor].loaded = true;\\r\\n          _this.done(vendor);\\r\\n        };\\r\\n      } else {\\r\\n        script.onload = function() {\\r\\n          _this[vendor].loaded = true;\\r\\n          _this.done(vendor);\\r\\n        };\\r\\n      }\\r\\n\\r\\n      document.body.appendChild(script);\\r\\n    },\\r\\n    done: function(vendor) {\\r\\n      var instance, $el, player;\\r\\n\\r\\n      if (vendor === \"youtube\") {\\r\\n        delete window.onYouTubeIframeAPIReady;\\r\\n      }\\r\\n\\r\\n      instance = $.fancybox.getInstance();\\r\\n\\r\\n      if (instance) {\\r\\n        $el = instance.current.$content.find(\"iframe\");\\r\\n\\r\\n        if (vendor === \"youtube\" && YT !== undefined && YT) {\\r\\n          player = new YT.Player($el.attr(\"id\"), {\\r\\n            events: {\\r\\n              onStateChange: function(e) {\\r\\n                if (e.data == 0) {\\r\\n                  instance.next();\\r\\n                }\\r\\n              }\\r\\n            }\\r\\n          });\\r\\n        } else if (vendor === \"vimeo\" && Vimeo !== undefined && Vimeo) {\\r\\n          player = new Vimeo.Player($el);\\r\\n\\r\\n          player.on(\"ended\", function() {\\r\\n            instance.next();\\r\\n          });\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  };\\r\\n\\r\\n  $(document).on({\\r\\n    \"afterShow.fb\": function(e, instance, current) {\\r\\n      if (instance.group.length > 1 && (current.contentSource === \"youtube\" || current.contentSource === \"vimeo\")) {\\r\\n        VideoAPILoader.load(current.contentSource);\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n})(jQuery);\\r\\n\\n// ==========================================================================\\r\\n//\\r\\n// Guestures\\r\\n// Adds touch guestures, handles click and tap events\\r\\n//\\r\\n// ==========================================================================\\r\\n(function(window, document, $) {\\r\\n  \"use strict\";\\r\\n\\r\\n  var requestAFrame = (function() {\\r\\n    return (\\r\\n      window.requestAnimationFrame ||\\r\\n      window.webkitRequestAnimationFrame ||\\r\\n      window.mozRequestAnimationFrame ||\\r\\n      window.oRequestAnimationFrame ||\\r\\n      // if all else fails, use setTimeout\\r\\n      function(callback) {\\r\\n        return window.setTimeout(callback, 1000 / 60);\\r\\n      }\\r\\n    );\\r\\n  })();\\r\\n\\r\\n  var cancelAFrame = (function() {\\r\\n    return (\\r\\n      window.cancelAnimationFrame ||\\r\\n      window.webkitCancelAnimationFrame ||\\r\\n      window.mozCancelAnimationFrame ||\\r\\n      window.oCancelAnimationFrame ||\\r\\n      function(id) {\\r\\n        window.clearTimeout(id);\\r\\n      }\\r\\n    );\\r\\n  })();\\r\\n\\r\\n  var getPointerXY = function(e) {\\r\\n    var result = [];\\r\\n\\r\\n    e = e.originalEvent || e || window.e;\\r\\n    e = e.touches && e.touches.length ? e.touches : e.changedTouches && e.changedTouches.length ? e.changedTouches : [e];\\r\\n\\r\\n    for (var key in e) {\\r\\n      if (e[key].pageX) {\\r\\n        result.push({\\r\\n          x: e[key].pageX,\\r\\n          y: e[key].pageY\\r\\n        });\\r\\n      } else if (e[key].clientX) {\\r\\n        result.push({\\r\\n          x: e[key].clientX,\\r\\n          y: e[key].clientY\\r\\n        });\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return result;\\r\\n  };\\r\\n\\r\\n  var distance = function(point2, point1, what) {\\r\\n    if (!point1 || !point2) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    if (what === \"x\") {\\r\\n      return point2.x - point1.x;\\r\\n    } else if (what === \"y\") {\\r\\n      return point2.y - point1.y;\\r\\n    }\\r\\n\\r\\n    return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\\r\\n  };\\r\\n\\r\\n  var isClickable = function($el) {\\r\\n    if (\\r\\n      $el.is(\\'a,area,button,[role=\"button\"],input,label,select,summary,textarea,video,audio,iframe\\') ||\\r\\n      $.isFunction($el.get(0).onclick) ||\\r\\n      $el.data(\"selectable\")\\r\\n    ) {\\r\\n      return true;\\r\\n    }\\r\\n\\r\\n    // Check for attributes like data-fancybox-next or data-fancybox-close\\r\\n    for (var i = 0, atts = $el[0].attributes, n = atts.length; i < n; i++) {\\r\\n      if (atts[i].nodeName.substr(0, 14) === \"data-fancybox-\") {\\r\\n        return true;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return false;\\r\\n  };\\r\\n\\r\\n  var hasScrollbars = function(el) {\\r\\n    var overflowY = window.getComputedStyle(el)[\"overflow-y\"],\\r\\n      overflowX = window.getComputedStyle(el)[\"overflow-x\"],\\r\\n      vertical = (overflowY === \"scroll\" || overflowY === \"auto\") && el.scrollHeight > el.clientHeight,\\r\\n      horizontal = (overflowX === \"scroll\" || overflowX === \"auto\") && el.scrollWidth > el.clientWidth;\\r\\n\\r\\n    return vertical || horizontal;\\r\\n  };\\r\\n\\r\\n  var isScrollable = function($el) {\\r\\n    var rez = false;\\r\\n\\r\\n    while (true) {\\r\\n      rez = hasScrollbars($el.get(0));\\r\\n\\r\\n      if (rez) {\\r\\n        break;\\r\\n      }\\r\\n\\r\\n      $el = $el.parent();\\r\\n\\r\\n      if (!$el.length || $el.hasClass(\"fancybox-stage\") || $el.is(\"body\")) {\\r\\n        break;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return rez;\\r\\n  };\\r\\n\\r\\n  var Guestures = function(instance) {\\r\\n    var self = this;\\r\\n\\r\\n    self.instance = instance;\\r\\n\\r\\n    self.$bg = instance.$refs.bg;\\r\\n    self.$stage = instance.$refs.stage;\\r\\n    self.$container = instance.$refs.container;\\r\\n\\r\\n    self.destroy();\\r\\n\\r\\n    self.$container.on(\"touchstart.fb.touch mousedown.fb.touch\", $.proxy(self, \"ontouchstart\"));\\r\\n  };\\r\\n\\r\\n  Guestures.prototype.destroy = function() {\\r\\n    var self = this;\\r\\n\\r\\n    self.$container.off(\".fb.touch\");\\r\\n\\r\\n    $(document).off(\".fb.touch\");\\r\\n\\r\\n    if (self.requestId) {\\r\\n      cancelAFrame(self.requestId);\\r\\n      self.requestId = null;\\r\\n    }\\r\\n\\r\\n    if (self.tapped) {\\r\\n      clearTimeout(self.tapped);\\r\\n      self.tapped = null;\\r\\n    }\\r\\n  };\\r\\n\\r\\n  Guestures.prototype.ontouchstart = function(e) {\\r\\n    var self = this,\\r\\n      $target = $(e.target),\\r\\n      instance = self.instance,\\r\\n      current = instance.current,\\r\\n      $slide = current.$slide,\\r\\n      $content = current.$content,\\r\\n      isTouchDevice = e.type == \"touchstart\";\\r\\n\\r\\n    // Do not respond to both (touch and mouse) events\\r\\n    if (isTouchDevice) {\\r\\n      self.$container.off(\"mousedown.fb.touch\");\\r\\n    }\\r\\n\\r\\n    // Ignore right click\\r\\n    if (e.originalEvent && e.originalEvent.button == 2) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    // Ignore taping on links, buttons, input elements\\r\\n    if (!$slide.length || !$target.length || isClickable($target) || isClickable($target.parent())) {\\r\\n      return;\\r\\n    }\\r\\n    // Ignore clicks on the scrollbar\\r\\n    if (!$target.is(\"img\") && e.originalEvent.clientX > $target[0].clientWidth + $target.offset().left) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    // Ignore clicks while zooming or closing\\r\\n    if (!current || instance.isAnimating || current.$slide.hasClass(\"fancybox-animated\")) {\\r\\n      e.stopPropagation();\\r\\n      e.preventDefault();\\r\\n\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    self.realPoints = self.startPoints = getPointerXY(e);\\r\\n\\r\\n    if (!self.startPoints.length) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    // Allow other scripts to catch touch event if \"touch\" is set to false\\r\\n    if (current.touch) {\\r\\n      e.stopPropagation();\\r\\n    }\\r\\n\\r\\n    self.startEvent = e;\\r\\n\\r\\n    self.canTap = true;\\r\\n    self.$target = $target;\\r\\n    self.$content = $content;\\r\\n    self.opts = current.opts.touch;\\r\\n\\r\\n    self.isPanning = false;\\r\\n    self.isSwiping = false;\\r\\n    self.isZooming = false;\\r\\n    self.isScrolling = false;\\r\\n    self.canPan = instance.canPan();\\r\\n\\r\\n    self.startTime = new Date().getTime();\\r\\n    self.distanceX = self.distanceY = self.distance = 0;\\r\\n\\r\\n    self.canvasWidth = Math.round($slide[0].clientWidth);\\r\\n    self.canvasHeight = Math.round($slide[0].clientHeight);\\r\\n\\r\\n    self.contentLastPos = null;\\r\\n    self.contentStartPos = $.fancybox.getTranslate(self.$content) || {top: 0, left: 0};\\r\\n    self.sliderStartPos = $.fancybox.getTranslate($slide);\\r\\n\\r\\n    // Since position will be absolute, but we need to make it relative to the stage\\r\\n    self.stagePos = $.fancybox.getTranslate(instance.$refs.stage);\\r\\n\\r\\n    self.sliderStartPos.top -= self.stagePos.top;\\r\\n    self.sliderStartPos.left -= self.stagePos.left;\\r\\n\\r\\n    self.contentStartPos.top -= self.stagePos.top;\\r\\n    self.contentStartPos.left -= self.stagePos.left;\\r\\n\\r\\n    $(document)\\r\\n      .off(\".fb.touch\")\\r\\n      .on(isTouchDevice ? \"touchend.fb.touch touchcancel.fb.touch\" : \"mouseup.fb.touch mouseleave.fb.touch\", $.proxy(self, \"ontouchend\"))\\r\\n      .on(isTouchDevice ? \"touchmove.fb.touch\" : \"mousemove.fb.touch\", $.proxy(self, \"ontouchmove\"));\\r\\n\\r\\n    if ($.fancybox.isMobile) {\\r\\n      document.addEventListener(\"scroll\", self.onscroll, true);\\r\\n    }\\r\\n\\r\\n    // Skip if clicked outside the sliding area\\r\\n    if (!(self.opts || self.canPan) || !($target.is(self.$stage) || self.$stage.find($target).length)) {\\r\\n      if ($target.is(\".fancybox-image\")) {\\r\\n        e.preventDefault();\\r\\n      }\\r\\n\\r\\n      if (!($.fancybox.isMobile && $target.parents(\".fancybox-caption\").length)) {\\r\\n        return;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    self.isScrollable = isScrollable($target) || isScrollable($target.parent());\\r\\n\\r\\n    // Check if element is scrollable and try to prevent default behavior (scrolling)\\r\\n    if (!($.fancybox.isMobile && self.isScrollable)) {\\r\\n      e.preventDefault();\\r\\n    }\\r\\n\\r\\n    // One finger or mouse click - swipe or pan an image\\r\\n    if (self.startPoints.length === 1 || current.hasError) {\\r\\n      if (self.canPan) {\\r\\n        $.fancybox.stop(self.$content);\\r\\n\\r\\n        self.isPanning = true;\\r\\n      } else {\\r\\n        self.isSwiping = true;\\r\\n      }\\r\\n\\r\\n      self.$container.addClass(\"fancybox-is-grabbing\");\\r\\n    }\\r\\n\\r\\n    // Two fingers - zoom image\\r\\n    if (self.startPoints.length === 2 && current.type === \"image\" && (current.isLoaded || current.$ghost)) {\\r\\n      self.canTap = false;\\r\\n      self.isSwiping = false;\\r\\n      self.isPanning = false;\\r\\n\\r\\n      self.isZooming = true;\\r\\n\\r\\n      $.fancybox.stop(self.$content);\\r\\n\\r\\n      self.centerPointStartX = (self.startPoints[0].x + self.startPoints[1].x) * 0.5 - $(window).scrollLeft();\\r\\n      self.centerPointStartY = (self.startPoints[0].y + self.startPoints[1].y) * 0.5 - $(window).scrollTop();\\r\\n\\r\\n      self.percentageOfImageAtPinchPointX = (self.centerPointStartX - self.contentStartPos.left) / self.contentStartPos.width;\\r\\n      self.percentageOfImageAtPinchPointY = (self.centerPointStartY - self.contentStartPos.top) / self.contentStartPos.height;\\r\\n\\r\\n      self.startDistanceBetweenFingers = distance(self.startPoints[0], self.startPoints[1]);\\r\\n    }\\r\\n  };\\r\\n\\r\\n  Guestures.prototype.onscroll = function(e) {\\r\\n    var self = this;\\r\\n\\r\\n    self.isScrolling = true;\\r\\n\\r\\n    document.removeEventListener(\"scroll\", self.onscroll, true);\\r\\n  };\\r\\n\\r\\n  Guestures.prototype.ontouchmove = function(e) {\\r\\n    var self = this;\\r\\n\\r\\n    // Make sure user has not released over iframe or disabled element\\r\\n    if (e.originalEvent.buttons !== undefined && e.originalEvent.buttons === 0) {\\r\\n      self.ontouchend(e);\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    if (self.isScrolling) {\\r\\n      self.canTap = false;\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    self.newPoints = getPointerXY(e);\\r\\n\\r\\n    if (!(self.opts || self.canPan) || !self.newPoints.length || !self.newPoints.length) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    if (!(self.isSwiping && self.isSwiping === true)) {\\r\\n      e.preventDefault();\\r\\n    }\\r\\n\\r\\n    self.distanceX = distance(self.newPoints[0], self.startPoints[0], \"x\");\\r\\n    self.distanceY = distance(self.newPoints[0], self.startPoints[0], \"y\");\\r\\n\\r\\n    self.distance = distance(self.newPoints[0], self.startPoints[0]);\\r\\n\\r\\n    // Skip false ontouchmove events (Chrome)\\r\\n    if (self.distance > 0) {\\r\\n      if (self.isSwiping) {\\r\\n        self.onSwipe(e);\\r\\n      } else if (self.isPanning) {\\r\\n        self.onPan();\\r\\n      } else if (self.isZooming) {\\r\\n        self.onZoom();\\r\\n      }\\r\\n    }\\r\\n  };\\r\\n\\r\\n  Guestures.prototype.onSwipe = function(e) {\\r\\n    var self = this,\\r\\n      instance = self.instance,\\r\\n      swiping = self.isSwiping,\\r\\n      left = self.sliderStartPos.left || 0,\\r\\n      angle;\\r\\n\\r\\n    // If direction is not yet determined\\r\\n    if (swiping === true) {\\r\\n      // We need at least 10px distance to correctly calculate an angle\\r\\n      if (Math.abs(self.distance) > 10) {\\r\\n        self.canTap = false;\\r\\n\\r\\n        if (instance.group.length < 2 && self.opts.vertical) {\\r\\n          self.isSwiping = \"y\";\\r\\n        } else if (instance.isDragging || self.opts.vertical === false || (self.opts.vertical === \"auto\" && $(window).width() > 800)) {\\r\\n          self.isSwiping = \"x\";\\r\\n        } else {\\r\\n          angle = Math.abs((Math.atan2(self.distanceY, self.distanceX) * 180) / Math.PI);\\r\\n\\r\\n          self.isSwiping = angle > 45 && angle < 135 ? \"y\" : \"x\";\\r\\n        }\\r\\n\\r\\n        if (self.isSwiping === \"y\" && $.fancybox.isMobile && self.isScrollable) {\\r\\n          self.isScrolling = true;\\r\\n\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        instance.isDragging = self.isSwiping;\\r\\n\\r\\n        // Reset points to avoid jumping, because we dropped first swipes to calculate the angle\\r\\n        self.startPoints = self.newPoints;\\r\\n\\r\\n        $.each(instance.slides, function(index, slide) {\\r\\n          var slidePos, stagePos;\\r\\n\\r\\n          $.fancybox.stop(slide.$slide);\\r\\n\\r\\n          slidePos = $.fancybox.getTranslate(slide.$slide);\\r\\n          stagePos = $.fancybox.getTranslate(instance.$refs.stage);\\r\\n\\r\\n          slide.$slide\\r\\n            .css({\\r\\n              transform: \"\",\\r\\n              opacity: \"\",\\r\\n              \"transition-duration\": \"\"\\r\\n            })\\r\\n            .removeClass(\"fancybox-animated\")\\r\\n            .removeClass(function(index, className) {\\r\\n              return (className.match(/(^|\\\\s)fancybox-fx-\\\\S+/g) || []).join(\" \");\\r\\n            });\\r\\n\\r\\n          if (slide.pos === instance.current.pos) {\\r\\n            self.sliderStartPos.top = slidePos.top - stagePos.top;\\r\\n            self.sliderStartPos.left = slidePos.left - stagePos.left;\\r\\n          }\\r\\n\\r\\n          $.fancybox.setTranslate(slide.$slide, {\\r\\n            top: slidePos.top - stagePos.top,\\r\\n            left: slidePos.left - stagePos.left\\r\\n          });\\r\\n        });\\r\\n\\r\\n        // Stop slideshow\\r\\n        if (instance.SlideShow && instance.SlideShow.isActive) {\\r\\n          instance.SlideShow.stop();\\r\\n        }\\r\\n      }\\r\\n\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    // Sticky edges\\r\\n    if (swiping == \"x\") {\\r\\n      if (\\r\\n        self.distanceX > 0 &&\\r\\n        (self.instance.group.length < 2 || (self.instance.current.index === 0 && !self.instance.current.opts.loop))\\r\\n      ) {\\r\\n        left = left + Math.pow(self.distanceX, 0.8);\\r\\n      } else if (\\r\\n        self.distanceX < 0 &&\\r\\n        (self.instance.group.length < 2 ||\\r\\n          (self.instance.current.index === self.instance.group.length - 1 && !self.instance.current.opts.loop))\\r\\n      ) {\\r\\n        left = left - Math.pow(-self.distanceX, 0.8);\\r\\n      } else {\\r\\n        left = left + self.distanceX;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    self.sliderLastPos = {\\r\\n      top: swiping == \"x\" ? 0 : self.sliderStartPos.top + self.distanceY,\\r\\n      left: left\\r\\n    };\\r\\n\\r\\n    if (self.requestId) {\\r\\n      cancelAFrame(self.requestId);\\r\\n\\r\\n      self.requestId = null;\\r\\n    }\\r\\n\\r\\n    self.requestId = requestAFrame(function() {\\r\\n      if (self.sliderLastPos) {\\r\\n        $.each(self.instance.slides, function(index, slide) {\\r\\n          var pos = slide.pos - self.instance.currPos;\\r\\n\\r\\n          $.fancybox.setTranslate(slide.$slide, {\\r\\n            top: self.sliderLastPos.top,\\r\\n            left: self.sliderLastPos.left + pos * self.canvasWidth + pos * slide.opts.gutter\\r\\n          });\\r\\n        });\\r\\n\\r\\n        self.$container.addClass(\"fancybox-is-sliding\");\\r\\n      }\\r\\n    });\\r\\n  };\\r\\n\\r\\n  Guestures.prototype.onPan = function() {\\r\\n    var self = this;\\r\\n\\r\\n    // Prevent accidental movement (sometimes, when tapping casually, finger can move a bit)\\r\\n    if (distance(self.newPoints[0], self.realPoints[0]) < ($.fancybox.isMobile ? 10 : 5)) {\\r\\n      self.startPoints = self.newPoints;\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    self.canTap = false;\\r\\n\\r\\n    self.contentLastPos = self.limitMovement();\\r\\n\\r\\n    if (self.requestId) {\\r\\n      cancelAFrame(self.requestId);\\r\\n    }\\r\\n\\r\\n    self.requestId = requestAFrame(function() {\\r\\n      $.fancybox.setTranslate(self.$content, self.contentLastPos);\\r\\n    });\\r\\n  };\\r\\n\\r\\n  // Make panning sticky to the edges\\r\\n  Guestures.prototype.limitMovement = function() {\\r\\n    var self = this;\\r\\n\\r\\n    var canvasWidth = self.canvasWidth;\\r\\n    var canvasHeight = self.canvasHeight;\\r\\n\\r\\n    var distanceX = self.distanceX;\\r\\n    var distanceY = self.distanceY;\\r\\n\\r\\n    var contentStartPos = self.contentStartPos;\\r\\n\\r\\n    var currentOffsetX = contentStartPos.left;\\r\\n    var currentOffsetY = contentStartPos.top;\\r\\n\\r\\n    var currentWidth = contentStartPos.width;\\r\\n    var currentHeight = contentStartPos.height;\\r\\n\\r\\n    var minTranslateX, minTranslateY, maxTranslateX, maxTranslateY, newOffsetX, newOffsetY;\\r\\n\\r\\n    if (currentWidth > canvasWidth) {\\r\\n      newOffsetX = currentOffsetX + distanceX;\\r\\n    } else {\\r\\n      newOffsetX = currentOffsetX;\\r\\n    }\\r\\n\\r\\n    newOffsetY = currentOffsetY + distanceY;\\r\\n\\r\\n    // Slow down proportionally to traveled distance\\r\\n    minTranslateX = Math.max(0, canvasWidth * 0.5 - currentWidth * 0.5);\\r\\n    minTranslateY = Math.max(0, canvasHeight * 0.5 - currentHeight * 0.5);\\r\\n\\r\\n    maxTranslateX = Math.min(canvasWidth - currentWidth, canvasWidth * 0.5 - currentWidth * 0.5);\\r\\n    maxTranslateY = Math.min(canvasHeight - currentHeight, canvasHeight * 0.5 - currentHeight * 0.5);\\r\\n\\r\\n    //   ->\\r\\n    if (distanceX > 0 && newOffsetX > minTranslateX) {\\r\\n      newOffsetX = minTranslateX - 1 + Math.pow(-minTranslateX + currentOffsetX + distanceX, 0.8) || 0;\\r\\n    }\\r\\n\\r\\n    //    <-\\r\\n    if (distanceX < 0 && newOffsetX < maxTranslateX) {\\r\\n      newOffsetX = maxTranslateX + 1 - Math.pow(maxTranslateX - currentOffsetX - distanceX, 0.8) || 0;\\r\\n    }\\r\\n\\r\\n    //   \\\\/\\r\\n    if (distanceY > 0 && newOffsetY > minTranslateY) {\\r\\n      newOffsetY = minTranslateY - 1 + Math.pow(-minTranslateY + currentOffsetY + distanceY, 0.8) || 0;\\r\\n    }\\r\\n\\r\\n    //   /\\\\\\r\\n    if (distanceY < 0 && newOffsetY < maxTranslateY) {\\r\\n      newOffsetY = maxTranslateY + 1 - Math.pow(maxTranslateY - currentOffsetY - distanceY, 0.8) || 0;\\r\\n    }\\r\\n\\r\\n    return {\\r\\n      top: newOffsetY,\\r\\n      left: newOffsetX\\r\\n    };\\r\\n  };\\r\\n\\r\\n  Guestures.prototype.limitPosition = function(newOffsetX, newOffsetY, newWidth, newHeight) {\\r\\n    var self = this;\\r\\n\\r\\n    var canvasWidth = self.canvasWidth;\\r\\n    var canvasHeight = self.canvasHeight;\\r\\n\\r\\n    if (newWidth > canvasWidth) {\\r\\n      newOffsetX = newOffsetX > 0 ? 0 : newOffsetX;\\r\\n      newOffsetX = newOffsetX < canvasWidth - newWidth ? canvasWidth - newWidth : newOffsetX;\\r\\n    } else {\\r\\n      // Center horizontally\\r\\n      newOffsetX = Math.max(0, canvasWidth / 2 - newWidth / 2);\\r\\n    }\\r\\n\\r\\n    if (newHeight > canvasHeight) {\\r\\n      newOffsetY = newOffsetY > 0 ? 0 : newOffsetY;\\r\\n      newOffsetY = newOffsetY < canvasHeight - newHeight ? canvasHeight - newHeight : newOffsetY;\\r\\n    } else {\\r\\n      // Center vertically\\r\\n      newOffsetY = Math.max(0, canvasHeight / 2 - newHeight / 2);\\r\\n    }\\r\\n\\r\\n    return {\\r\\n      top: newOffsetY,\\r\\n      left: newOffsetX\\r\\n    };\\r\\n  };\\r\\n\\r\\n  Guestures.prototype.onZoom = function() {\\r\\n    var self = this;\\r\\n\\r\\n    // Calculate current distance between points to get pinch ratio and new width and height\\r\\n    var contentStartPos = self.contentStartPos;\\r\\n\\r\\n    var currentWidth = contentStartPos.width;\\r\\n    var currentHeight = contentStartPos.height;\\r\\n\\r\\n    var currentOffsetX = contentStartPos.left;\\r\\n    var currentOffsetY = contentStartPos.top;\\r\\n\\r\\n    var endDistanceBetweenFingers = distance(self.newPoints[0], self.newPoints[1]);\\r\\n\\r\\n    var pinchRatio = endDistanceBetweenFingers / self.startDistanceBetweenFingers;\\r\\n\\r\\n    var newWidth = Math.floor(currentWidth * pinchRatio);\\r\\n    var newHeight = Math.floor(currentHeight * pinchRatio);\\r\\n\\r\\n    // This is the translation due to pinch-zooming\\r\\n    var translateFromZoomingX = (currentWidth - newWidth) * self.percentageOfImageAtPinchPointX;\\r\\n    var translateFromZoomingY = (currentHeight - newHeight) * self.percentageOfImageAtPinchPointY;\\r\\n\\r\\n    // Point between the two touches\\r\\n    var centerPointEndX = (self.newPoints[0].x + self.newPoints[1].x) / 2 - $(window).scrollLeft();\\r\\n    var centerPointEndY = (self.newPoints[0].y + self.newPoints[1].y) / 2 - $(window).scrollTop();\\r\\n\\r\\n    // And this is the translation due to translation of the centerpoint\\r\\n    // between the two fingers\\r\\n    var translateFromTranslatingX = centerPointEndX - self.centerPointStartX;\\r\\n    var translateFromTranslatingY = centerPointEndY - self.centerPointStartY;\\r\\n\\r\\n    // The new offset is the old/current one plus the total translation\\r\\n    var newOffsetX = currentOffsetX + (translateFromZoomingX + translateFromTranslatingX);\\r\\n    var newOffsetY = currentOffsetY + (translateFromZoomingY + translateFromTranslatingY);\\r\\n\\r\\n    var newPos = {\\r\\n      top: newOffsetY,\\r\\n      left: newOffsetX,\\r\\n      scaleX: pinchRatio,\\r\\n      scaleY: pinchRatio\\r\\n    };\\r\\n\\r\\n    self.canTap = false;\\r\\n\\r\\n    self.newWidth = newWidth;\\r\\n    self.newHeight = newHeight;\\r\\n\\r\\n    self.contentLastPos = newPos;\\r\\n\\r\\n    if (self.requestId) {\\r\\n      cancelAFrame(self.requestId);\\r\\n    }\\r\\n\\r\\n    self.requestId = requestAFrame(function() {\\r\\n      $.fancybox.setTranslate(self.$content, self.contentLastPos);\\r\\n    });\\r\\n  };\\r\\n\\r\\n  Guestures.prototype.ontouchend = function(e) {\\r\\n    var self = this;\\r\\n\\r\\n    var swiping = self.isSwiping;\\r\\n    var panning = self.isPanning;\\r\\n    var zooming = self.isZooming;\\r\\n    var scrolling = self.isScrolling;\\r\\n\\r\\n    self.endPoints = getPointerXY(e);\\r\\n    self.dMs = Math.max(new Date().getTime() - self.startTime, 1);\\r\\n\\r\\n    self.$container.removeClass(\"fancybox-is-grabbing\");\\r\\n\\r\\n    $(document).off(\".fb.touch\");\\r\\n\\r\\n    document.removeEventListener(\"scroll\", self.onscroll, true);\\r\\n\\r\\n    if (self.requestId) {\\r\\n      cancelAFrame(self.requestId);\\r\\n\\r\\n      self.requestId = null;\\r\\n    }\\r\\n\\r\\n    self.isSwiping = false;\\r\\n    self.isPanning = false;\\r\\n    self.isZooming = false;\\r\\n    self.isScrolling = false;\\r\\n\\r\\n    self.instance.isDragging = false;\\r\\n\\r\\n    if (self.canTap) {\\r\\n      return self.onTap(e);\\r\\n    }\\r\\n\\r\\n    self.speed = 100;\\r\\n\\r\\n    // Speed in px/ms\\r\\n    self.velocityX = (self.distanceX / self.dMs) * 0.5;\\r\\n    self.velocityY = (self.distanceY / self.dMs) * 0.5;\\r\\n\\r\\n    if (panning) {\\r\\n      self.endPanning();\\r\\n    } else if (zooming) {\\r\\n      self.endZooming();\\r\\n    } else {\\r\\n      self.endSwiping(swiping, scrolling);\\r\\n    }\\r\\n\\r\\n    return;\\r\\n  };\\r\\n\\r\\n  Guestures.prototype.endSwiping = function(swiping, scrolling) {\\r\\n    var self = this,\\r\\n      ret = false,\\r\\n      len = self.instance.group.length,\\r\\n      distanceX = Math.abs(self.distanceX),\\r\\n      canAdvance = swiping == \"x\" && len > 1 && ((self.dMs > 130 && distanceX > 10) || distanceX > 50),\\r\\n      speedX = 300;\\r\\n\\r\\n    self.sliderLastPos = null;\\r\\n\\r\\n    // Close if swiped vertically / navigate if horizontally\\r\\n    if (swiping == \"y\" && !scrolling && Math.abs(self.distanceY) > 50) {\\r\\n      // Continue vertical movement\\r\\n      $.fancybox.animate(\\r\\n        self.instance.current.$slide,\\r\\n        {\\r\\n          top: self.sliderStartPos.top + self.distanceY + self.velocityY * 150,\\r\\n          opacity: 0\\r\\n        },\\r\\n        200\\r\\n      );\\r\\n      ret = self.instance.close(true, 250);\\r\\n    } else if (canAdvance && self.distanceX > 0) {\\r\\n      ret = self.instance.previous(speedX);\\r\\n    } else if (canAdvance && self.distanceX < 0) {\\r\\n      ret = self.instance.next(speedX);\\r\\n    }\\r\\n\\r\\n    if (ret === false && (swiping == \"x\" || swiping == \"y\")) {\\r\\n      self.instance.centerSlide(200);\\r\\n    }\\r\\n\\r\\n    self.$container.removeClass(\"fancybox-is-sliding\");\\r\\n  };\\r\\n\\r\\n  // Limit panning from edges\\r\\n  // ========================\\r\\n  Guestures.prototype.endPanning = function() {\\r\\n    var self = this,\\r\\n      newOffsetX,\\r\\n      newOffsetY,\\r\\n      newPos;\\r\\n\\r\\n    if (!self.contentLastPos) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    if (self.opts.momentum === false || self.dMs > 350) {\\r\\n      newOffsetX = self.contentLastPos.left;\\r\\n      newOffsetY = self.contentLastPos.top;\\r\\n    } else {\\r\\n      // Continue movement\\r\\n      newOffsetX = self.contentLastPos.left + self.velocityX * 500;\\r\\n      newOffsetY = self.contentLastPos.top + self.velocityY * 500;\\r\\n    }\\r\\n\\r\\n    newPos = self.limitPosition(newOffsetX, newOffsetY, self.contentStartPos.width, self.contentStartPos.height);\\r\\n\\r\\n    newPos.width = self.contentStartPos.width;\\r\\n    newPos.height = self.contentStartPos.height;\\r\\n\\r\\n    $.fancybox.animate(self.$content, newPos, 366);\\r\\n  };\\r\\n\\r\\n  Guestures.prototype.endZooming = function() {\\r\\n    var self = this;\\r\\n\\r\\n    var current = self.instance.current;\\r\\n\\r\\n    var newOffsetX, newOffsetY, newPos, reset;\\r\\n\\r\\n    var newWidth = self.newWidth;\\r\\n    var newHeight = self.newHeight;\\r\\n\\r\\n    if (!self.contentLastPos) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    newOffsetX = self.contentLastPos.left;\\r\\n    newOffsetY = self.contentLastPos.top;\\r\\n\\r\\n    reset = {\\r\\n      top: newOffsetY,\\r\\n      left: newOffsetX,\\r\\n      width: newWidth,\\r\\n      height: newHeight,\\r\\n      scaleX: 1,\\r\\n      scaleY: 1\\r\\n    };\\r\\n\\r\\n    // Reset scalex/scaleY values; this helps for perfomance and does not break animation\\r\\n    $.fancybox.setTranslate(self.$content, reset);\\r\\n\\r\\n    if (newWidth < self.canvasWidth && newHeight < self.canvasHeight) {\\r\\n      self.instance.scaleToFit(150);\\r\\n    } else if (newWidth > current.width || newHeight > current.height) {\\r\\n      self.instance.scaleToActual(self.centerPointStartX, self.centerPointStartY, 150);\\r\\n    } else {\\r\\n      newPos = self.limitPosition(newOffsetX, newOffsetY, newWidth, newHeight);\\r\\n\\r\\n      $.fancybox.animate(self.$content, newPos, 150);\\r\\n    }\\r\\n  };\\r\\n\\r\\n  Guestures.prototype.onTap = function(e) {\\r\\n    var self = this;\\r\\n    var $target = $(e.target);\\r\\n\\r\\n    var instance = self.instance;\\r\\n    var current = instance.current;\\r\\n\\r\\n    var endPoints = (e && getPointerXY(e)) || self.startPoints;\\r\\n\\r\\n    var tapX = endPoints[0] ? endPoints[0].x - $(window).scrollLeft() - self.stagePos.left : 0;\\r\\n    var tapY = endPoints[0] ? endPoints[0].y - $(window).scrollTop() - self.stagePos.top : 0;\\r\\n\\r\\n    var where;\\r\\n\\r\\n    var process = function(prefix) {\\r\\n      var action = current.opts[prefix];\\r\\n\\r\\n      if ($.isFunction(action)) {\\r\\n        action = action.apply(instance, [current, e]);\\r\\n      }\\r\\n\\r\\n      if (!action) {\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      switch (action) {\\r\\n        case \"close\":\\r\\n          instance.close(self.startEvent);\\r\\n\\r\\n          break;\\r\\n\\r\\n        case \"toggleControls\":\\r\\n          instance.toggleControls();\\r\\n\\r\\n          break;\\r\\n\\r\\n        case \"next\":\\r\\n          instance.next();\\r\\n\\r\\n          break;\\r\\n\\r\\n        case \"nextOrClose\":\\r\\n          if (instance.group.length > 1) {\\r\\n            instance.next();\\r\\n          } else {\\r\\n            instance.close(self.startEvent);\\r\\n          }\\r\\n\\r\\n          break;\\r\\n\\r\\n        case \"zoom\":\\r\\n          if (current.type == \"image\" && (current.isLoaded || current.$ghost)) {\\r\\n            if (instance.canPan()) {\\r\\n              instance.scaleToFit();\\r\\n            } else if (instance.isScaledDown()) {\\r\\n              instance.scaleToActual(tapX, tapY);\\r\\n            } else if (instance.group.length < 2) {\\r\\n              instance.close(self.startEvent);\\r\\n            }\\r\\n          }\\r\\n\\r\\n          break;\\r\\n      }\\r\\n    };\\r\\n\\r\\n    // Ignore right click\\r\\n    if (e.originalEvent && e.originalEvent.button == 2) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    // Skip if clicked on the scrollbar\\r\\n    if (!$target.is(\"img\") && tapX > $target[0].clientWidth + $target.offset().left) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    // Check where is clicked\\r\\n    if ($target.is(\".fancybox-bg,.fancybox-inner,.fancybox-outer,.fancybox-container\")) {\\r\\n      where = \"Outside\";\\r\\n    } else if ($target.is(\".fancybox-slide\")) {\\r\\n      where = \"Slide\";\\r\\n    } else if (\\r\\n      instance.current.$content &&\\r\\n      instance.current.$content\\r\\n        .find($target)\\r\\n        .addBack()\\r\\n        .filter($target).length\\r\\n    ) {\\r\\n      where = \"Content\";\\r\\n    } else {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    // Check if this is a double tap\\r\\n    if (self.tapped) {\\r\\n      // Stop previously created single tap\\r\\n      clearTimeout(self.tapped);\\r\\n      self.tapped = null;\\r\\n\\r\\n      // Skip if distance between taps is too big\\r\\n      if (Math.abs(tapX - self.tapX) > 50 || Math.abs(tapY - self.tapY) > 50) {\\r\\n        return this;\\r\\n      }\\r\\n\\r\\n      // OK, now we assume that this is a double-tap\\r\\n      process(\"dblclick\" + where);\\r\\n    } else {\\r\\n      // Single tap will be processed if user has not clicked second time within 300ms\\r\\n      // or there is no need to wait for double-tap\\r\\n      self.tapX = tapX;\\r\\n      self.tapY = tapY;\\r\\n\\r\\n      if (current.opts[\"dblclick\" + where] && current.opts[\"dblclick\" + where] !== current.opts[\"click\" + where]) {\\r\\n        self.tapped = setTimeout(function() {\\r\\n          self.tapped = null;\\r\\n\\r\\n          if (!instance.isAnimating) {\\r\\n            process(\"click\" + where);\\r\\n          }\\r\\n        }, 500);\\r\\n      } else {\\r\\n        process(\"click\" + where);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return this;\\r\\n  };\\r\\n\\r\\n  $(document)\\r\\n    .on(\"onActivate.fb\", function(e, instance) {\\r\\n      if (instance && !instance.Guestures) {\\r\\n        instance.Guestures = new Guestures(instance);\\r\\n      }\\r\\n    })\\r\\n    .on(\"beforeClose.fb\", function(e, instance) {\\r\\n      if (instance && instance.Guestures) {\\r\\n        instance.Guestures.destroy();\\r\\n      }\\r\\n    });\\r\\n})(window, document, jQuery);\\r\\n\\n// ==========================================================================\\r\\n//\\r\\n// SlideShow\\r\\n// Enables slideshow functionality\\r\\n//\\r\\n// Example of usage:\\r\\n// $.fancybox.getInstance().SlideShow.start()\\r\\n//\\r\\n// ==========================================================================\\r\\n(function(document, $) {\\r\\n  \"use strict\";\\r\\n\\r\\n  $.extend(true, $.fancybox.defaults, {\\r\\n    btnTpl: {\\r\\n      slideShow:\\r\\n        \\'<button data-fancybox-play class=\"fancybox-button fancybox-button--play\" title=\"{{PLAY_START}}\">\\' +\\r\\n        \\'<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M6.5 5.4v13.2l11-6.6z\"/></svg>\\' +\\r\\n        \\'<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M8.33 5.75h2.2v12.5h-2.2V5.75zm5.15 0h2.2v12.5h-2.2V5.75z\"/></svg>\\' +\\r\\n        \"</button>\"\\r\\n    },\\r\\n    slideShow: {\\r\\n      autoStart: false,\\r\\n      speed: 3000,\\r\\n      progress: true\\r\\n    }\\r\\n  });\\r\\n\\r\\n  var SlideShow = function(instance) {\\r\\n    this.instance = instance;\\r\\n    this.init();\\r\\n  };\\r\\n\\r\\n  $.extend(SlideShow.prototype, {\\r\\n    timer: null,\\r\\n    isActive: false,\\r\\n    $button: null,\\r\\n\\r\\n    init: function() {\\r\\n      var self = this,\\r\\n        instance = self.instance,\\r\\n        opts = instance.group[instance.currIndex].opts.slideShow;\\r\\n\\r\\n      self.$button = instance.$refs.toolbar.find(\"[data-fancybox-play]\").on(\"click\", function() {\\r\\n        self.toggle();\\r\\n      });\\r\\n\\r\\n      if (instance.group.length < 2 || !opts) {\\r\\n        self.$button.hide();\\r\\n      } else if (opts.progress) {\\r\\n        self.$progress = $(\\'<div class=\"fancybox-progress\"></div>\\').appendTo(instance.$refs.inner);\\r\\n      }\\r\\n    },\\r\\n\\r\\n    set: function(force) {\\r\\n      var self = this,\\r\\n        instance = self.instance,\\r\\n        current = instance.current;\\r\\n\\r\\n      // Check if reached last element\\r\\n      if (current && (force === true || current.opts.loop || instance.currIndex < instance.group.length - 1)) {\\r\\n        if (self.isActive && current.contentType !== \"video\") {\\r\\n          if (self.$progress) {\\r\\n            $.fancybox.animate(self.$progress.show(), {scaleX: 1}, current.opts.slideShow.speed);\\r\\n          }\\r\\n\\r\\n          self.timer = setTimeout(function() {\\r\\n            if (!instance.current.opts.loop && instance.current.index == instance.group.length - 1) {\\r\\n              instance.jumpTo(0);\\r\\n            } else {\\r\\n              instance.next();\\r\\n            }\\r\\n          }, current.opts.slideShow.speed);\\r\\n        }\\r\\n      } else {\\r\\n        self.stop();\\r\\n        instance.idleSecondsCounter = 0;\\r\\n        instance.showControls();\\r\\n      }\\r\\n    },\\r\\n\\r\\n    clear: function() {\\r\\n      var self = this;\\r\\n\\r\\n      clearTimeout(self.timer);\\r\\n\\r\\n      self.timer = null;\\r\\n\\r\\n      if (self.$progress) {\\r\\n        self.$progress.removeAttr(\"style\").hide();\\r\\n      }\\r\\n    },\\r\\n\\r\\n    start: function() {\\r\\n      var self = this,\\r\\n        current = self.instance.current;\\r\\n\\r\\n      if (current) {\\r\\n        self.$button\\r\\n          .attr(\"title\", (current.opts.i18n[current.opts.lang] || current.opts.i18n.en).PLAY_STOP)\\r\\n          .removeClass(\"fancybox-button--play\")\\r\\n          .addClass(\"fancybox-button--pause\");\\r\\n\\r\\n        self.isActive = true;\\r\\n\\r\\n        if (current.isComplete) {\\r\\n          self.set(true);\\r\\n        }\\r\\n\\r\\n        self.instance.trigger(\"onSlideShowChange\", true);\\r\\n      }\\r\\n    },\\r\\n\\r\\n    stop: function() {\\r\\n      var self = this,\\r\\n        current = self.instance.current;\\r\\n\\r\\n      self.clear();\\r\\n\\r\\n      self.$button\\r\\n        .attr(\"title\", (current.opts.i18n[current.opts.lang] || current.opts.i18n.en).PLAY_START)\\r\\n        .removeClass(\"fancybox-button--pause\")\\r\\n        .addClass(\"fancybox-button--play\");\\r\\n\\r\\n      self.isActive = false;\\r\\n\\r\\n      self.instance.trigger(\"onSlideShowChange\", false);\\r\\n\\r\\n      if (self.$progress) {\\r\\n        self.$progress.removeAttr(\"style\").hide();\\r\\n      }\\r\\n    },\\r\\n\\r\\n    toggle: function() {\\r\\n      var self = this;\\r\\n\\r\\n      if (self.isActive) {\\r\\n        self.stop();\\r\\n      } else {\\r\\n        self.start();\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n\\r\\n  $(document).on({\\r\\n    \"onInit.fb\": function(e, instance) {\\r\\n      if (instance && !instance.SlideShow) {\\r\\n        instance.SlideShow = new SlideShow(instance);\\r\\n      }\\r\\n    },\\r\\n\\r\\n    \"beforeShow.fb\": function(e, instance, current, firstRun) {\\r\\n      var SlideShow = instance && instance.SlideShow;\\r\\n\\r\\n      if (firstRun) {\\r\\n        if (SlideShow && current.opts.slideShow.autoStart) {\\r\\n          SlideShow.start();\\r\\n        }\\r\\n      } else if (SlideShow && SlideShow.isActive) {\\r\\n        SlideShow.clear();\\r\\n      }\\r\\n    },\\r\\n\\r\\n    \"afterShow.fb\": function(e, instance, current) {\\r\\n      var SlideShow = instance && instance.SlideShow;\\r\\n\\r\\n      if (SlideShow && SlideShow.isActive) {\\r\\n        SlideShow.set();\\r\\n      }\\r\\n    },\\r\\n\\r\\n    \"afterKeydown.fb\": function(e, instance, current, keypress, keycode) {\\r\\n      var SlideShow = instance && instance.SlideShow;\\r\\n\\r\\n      // \"P\" or Spacebar\\r\\n      if (SlideShow && current.opts.slideShow && (keycode === 80 || keycode === 32) && !$(document.activeElement).is(\"button,a,input\")) {\\r\\n        keypress.preventDefault();\\r\\n\\r\\n        SlideShow.toggle();\\r\\n      }\\r\\n    },\\r\\n\\r\\n    \"beforeClose.fb onDeactivate.fb\": function(e, instance) {\\r\\n      var SlideShow = instance && instance.SlideShow;\\r\\n\\r\\n      if (SlideShow) {\\r\\n        SlideShow.stop();\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n\\r\\n  // Page Visibility API to pause slideshow when window is not active\\r\\n  $(document).on(\"visibilitychange\", function() {\\r\\n    var instance = $.fancybox.getInstance(),\\r\\n      SlideShow = instance && instance.SlideShow;\\r\\n\\r\\n    if (SlideShow && SlideShow.isActive) {\\r\\n      if (document.hidden) {\\r\\n        SlideShow.clear();\\r\\n      } else {\\r\\n        SlideShow.set();\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n})(document, jQuery);\\r\\n\\n// ==========================================================================\\r\\n//\\r\\n// FullScreen\\r\\n// Adds fullscreen functionality\\r\\n//\\r\\n// ==========================================================================\\r\\n(function(document, $) {\\r\\n  \"use strict\";\\r\\n\\r\\n  // Collection of methods supported by user browser\\r\\n  var fn = (function() {\\r\\n    var fnMap = [\\r\\n      [\"requestFullscreen\", \"exitFullscreen\", \"fullscreenElement\", \"fullscreenEnabled\", \"fullscreenchange\", \"fullscreenerror\"],\\r\\n      // new WebKit\\r\\n      [\\r\\n        \"webkitRequestFullscreen\",\\r\\n        \"webkitExitFullscreen\",\\r\\n        \"webkitFullscreenElement\",\\r\\n        \"webkitFullscreenEnabled\",\\r\\n        \"webkitfullscreenchange\",\\r\\n        \"webkitfullscreenerror\"\\r\\n      ],\\r\\n      // old WebKit (Safari 5.1)\\r\\n      [\\r\\n        \"webkitRequestFullScreen\",\\r\\n        \"webkitCancelFullScreen\",\\r\\n        \"webkitCurrentFullScreenElement\",\\r\\n        \"webkitCancelFullScreen\",\\r\\n        \"webkitfullscreenchange\",\\r\\n        \"webkitfullscreenerror\"\\r\\n      ],\\r\\n      [\\r\\n        \"mozRequestFullScreen\",\\r\\n        \"mozCancelFullScreen\",\\r\\n        \"mozFullScreenElement\",\\r\\n        \"mozFullScreenEnabled\",\\r\\n        \"mozfullscreenchange\",\\r\\n        \"mozfullscreenerror\"\\r\\n      ],\\r\\n      [\"msRequestFullscreen\", \"msExitFullscreen\", \"msFullscreenElement\", \"msFullscreenEnabled\", \"MSFullscreenChange\", \"MSFullscreenError\"]\\r\\n    ];\\r\\n\\r\\n    var ret = {};\\r\\n\\r\\n    for (var i = 0; i < fnMap.length; i++) {\\r\\n      var val = fnMap[i];\\r\\n\\r\\n      if (val && val[1] in document) {\\r\\n        for (var j = 0; j < val.length; j++) {\\r\\n          ret[fnMap[0][j]] = val[j];\\r\\n        }\\r\\n\\r\\n        return ret;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return false;\\r\\n  })();\\r\\n\\r\\n  if (fn) {\\r\\n    var FullScreen = {\\r\\n      request: function(elem) {\\r\\n        elem = elem || document.documentElement;\\r\\n\\r\\n        elem[fn.requestFullscreen](elem.ALLOW_KEYBOARD_INPUT);\\r\\n      },\\r\\n      exit: function() {\\r\\n        document[fn.exitFullscreen]();\\r\\n      },\\r\\n      toggle: function(elem) {\\r\\n        elem = elem || document.documentElement;\\r\\n\\r\\n        if (this.isFullscreen()) {\\r\\n          this.exit();\\r\\n        } else {\\r\\n          this.request(elem);\\r\\n        }\\r\\n      },\\r\\n      isFullscreen: function() {\\r\\n        return Boolean(document[fn.fullscreenElement]);\\r\\n      },\\r\\n      enabled: function() {\\r\\n        return Boolean(document[fn.fullscreenEnabled]);\\r\\n      }\\r\\n    };\\r\\n\\r\\n    $.extend(true, $.fancybox.defaults, {\\r\\n      btnTpl: {\\r\\n        fullScreen:\\r\\n          \\'<button data-fancybox-fullscreen class=\"fancybox-button fancybox-button--fsenter\" title=\"{{FULL_SCREEN}}\">\\' +\\r\\n          \\'<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z\"/></svg>\\' +\\r\\n          \\'<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M5 16h3v3h2v-5H5zm3-8H5v2h5V5H8zm6 11h2v-3h3v-2h-5zm2-11V5h-2v5h5V8z\"/></svg>\\' +\\r\\n          \"</button>\"\\r\\n      },\\r\\n      fullScreen: {\\r\\n        autoStart: false\\r\\n      }\\r\\n    });\\r\\n\\r\\n    $(document).on(fn.fullscreenchange, function() {\\r\\n      var isFullscreen = FullScreen.isFullscreen(),\\r\\n        instance = $.fancybox.getInstance();\\r\\n\\r\\n      if (instance) {\\r\\n        // If image is zooming, then force to stop and reposition properly\\r\\n        if (instance.current && instance.current.type === \"image\" && instance.isAnimating) {\\r\\n          instance.isAnimating = false;\\r\\n\\r\\n          instance.update(true, true, 0);\\r\\n\\r\\n          if (!instance.isComplete) {\\r\\n            instance.complete();\\r\\n          }\\r\\n        }\\r\\n\\r\\n        instance.trigger(\"onFullscreenChange\", isFullscreen);\\r\\n\\r\\n        instance.$refs.container.toggleClass(\"fancybox-is-fullscreen\", isFullscreen);\\r\\n\\r\\n        instance.$refs.toolbar\\r\\n          .find(\"[data-fancybox-fullscreen]\")\\r\\n          .toggleClass(\"fancybox-button--fsenter\", !isFullscreen)\\r\\n          .toggleClass(\"fancybox-button--fsexit\", isFullscreen);\\r\\n      }\\r\\n    });\\r\\n  }\\r\\n\\r\\n  $(document).on({\\r\\n    \"onInit.fb\": function(e, instance) {\\r\\n      var $container;\\r\\n\\r\\n      if (!fn) {\\r\\n        instance.$refs.toolbar.find(\"[data-fancybox-fullscreen]\").remove();\\r\\n\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      if (instance && instance.group[instance.currIndex].opts.fullScreen) {\\r\\n        $container = instance.$refs.container;\\r\\n\\r\\n        $container.on(\"click.fb-fullscreen\", \"[data-fancybox-fullscreen]\", function(e) {\\r\\n          e.stopPropagation();\\r\\n          e.preventDefault();\\r\\n\\r\\n          FullScreen.toggle();\\r\\n        });\\r\\n\\r\\n        if (instance.opts.fullScreen && instance.opts.fullScreen.autoStart === true) {\\r\\n          FullScreen.request();\\r\\n        }\\r\\n\\r\\n        // Expose API\\r\\n        instance.FullScreen = FullScreen;\\r\\n      } else if (instance) {\\r\\n        instance.$refs.toolbar.find(\"[data-fancybox-fullscreen]\").hide();\\r\\n      }\\r\\n    },\\r\\n\\r\\n    \"afterKeydown.fb\": function(e, instance, current, keypress, keycode) {\\r\\n      // \"F\"\\r\\n      if (instance && instance.FullScreen && keycode === 70) {\\r\\n        keypress.preventDefault();\\r\\n\\r\\n        instance.FullScreen.toggle();\\r\\n      }\\r\\n    },\\r\\n\\r\\n    \"beforeClose.fb\": function(e, instance) {\\r\\n      if (instance && instance.FullScreen && instance.$refs.container.hasClass(\"fancybox-is-fullscreen\")) {\\r\\n        FullScreen.exit();\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n})(document, jQuery);\\r\\n\\n// ==========================================================================\\r\\n//\\r\\n// Thumbs\\r\\n// Displays thumbnails in a grid\\r\\n//\\r\\n// ==========================================================================\\r\\n(function(document, $) {\\r\\n  \"use strict\";\\r\\n\\r\\n  var CLASS = \"fancybox-thumbs\",\\r\\n    CLASS_ACTIVE = CLASS + \"-active\";\\r\\n\\r\\n  // Make sure there are default values\\r\\n  $.fancybox.defaults = $.extend(\\r\\n    true,\\r\\n    {\\r\\n      btnTpl: {\\r\\n        thumbs:\\r\\n          \\'<button data-fancybox-thumbs class=\"fancybox-button fancybox-button--thumbs\" title=\"{{THUMBS}}\">\\' +\\r\\n          \\'<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M14.59 14.59h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76H5.65V5.65z\"/></svg>\\' +\\r\\n          \"</button>\"\\r\\n      },\\r\\n      thumbs: {\\r\\n        autoStart: false, // Display thumbnails on opening\\r\\n        hideOnClose: true, // Hide thumbnail grid when closing animation starts\\r\\n        parentEl: \".fancybox-container\", // Container is injected into this element\\r\\n        axis: \"y\" // Vertical (y) or horizontal (x) scrolling\\r\\n      }\\r\\n    },\\r\\n    $.fancybox.defaults\\r\\n  );\\r\\n\\r\\n  var FancyThumbs = function(instance) {\\r\\n    this.init(instance);\\r\\n  };\\r\\n\\r\\n  $.extend(FancyThumbs.prototype, {\\r\\n    $button: null,\\r\\n    $grid: null,\\r\\n    $list: null,\\r\\n    isVisible: false,\\r\\n    isActive: false,\\r\\n\\r\\n    init: function(instance) {\\r\\n      var self = this,\\r\\n        group = instance.group,\\r\\n        enabled = 0;\\r\\n\\r\\n      self.instance = instance;\\r\\n      self.opts = group[instance.currIndex].opts.thumbs;\\r\\n\\r\\n      instance.Thumbs = self;\\r\\n\\r\\n      self.$button = instance.$refs.toolbar.find(\"[data-fancybox-thumbs]\");\\r\\n\\r\\n      // Enable thumbs if at least two group items have thumbnails\\r\\n      for (var i = 0, len = group.length; i < len; i++) {\\r\\n        if (group[i].thumb) {\\r\\n          enabled++;\\r\\n        }\\r\\n\\r\\n        if (enabled > 1) {\\r\\n          break;\\r\\n        }\\r\\n      }\\r\\n\\r\\n      if (enabled > 1 && !!self.opts) {\\r\\n        self.$button.removeAttr(\"style\").on(\"click\", function() {\\r\\n          self.toggle();\\r\\n        });\\r\\n\\r\\n        self.isActive = true;\\r\\n      } else {\\r\\n        self.$button.hide();\\r\\n      }\\r\\n    },\\r\\n\\r\\n    create: function() {\\r\\n      var self = this,\\r\\n        instance = self.instance,\\r\\n        parentEl = self.opts.parentEl,\\r\\n        list = [],\\r\\n        src;\\r\\n\\r\\n      if (!self.$grid) {\\r\\n        // Create main element\\r\\n        self.$grid = $(\\'<div class=\"\\' + CLASS + \" \" + CLASS + \"-\" + self.opts.axis + \\'\"></div>\\').appendTo(\\r\\n          instance.$refs.container\\r\\n            .find(parentEl)\\r\\n            .addBack()\\r\\n            .filter(parentEl)\\r\\n        );\\r\\n\\r\\n        // Add \"click\" event that performs gallery navigation\\r\\n        self.$grid.on(\"click\", \"a\", function() {\\r\\n          instance.jumpTo($(this).attr(\"data-index\"));\\r\\n        });\\r\\n      }\\r\\n\\r\\n      // Build the list\\r\\n      if (!self.$list) {\\r\\n        self.$list = $(\\'<div class=\"\\' + CLASS + \\'__list\">\\').appendTo(self.$grid);\\r\\n      }\\r\\n\\r\\n      $.each(instance.group, function(i, item) {\\r\\n        src = item.thumb;\\r\\n\\r\\n        if (!src && item.type === \"image\") {\\r\\n          src = item.src;\\r\\n        }\\r\\n\\r\\n        list.push(\\r\\n          \\'<a href=\"javascript:;\" tabindex=\"0\" data-index=\"\\' +\\r\\n            i +\\r\\n            \\'\"\\' +\\r\\n            (src && src.length ? \\' style=\"background-image:url(\\' + src + \\')\"\\' : \\'class=\"fancybox-thumbs-missing\"\\') +\\r\\n            \"></a>\"\\r\\n        );\\r\\n      });\\r\\n\\r\\n      self.$list[0].innerHTML = list.join(\"\");\\r\\n\\r\\n      if (self.opts.axis === \"x\") {\\r\\n        // Set fixed width for list element to enable horizontal scrolling\\r\\n        self.$list.width(\\r\\n          parseInt(self.$grid.css(\"padding-right\"), 10) +\\r\\n            instance.group.length *\\r\\n              self.$list\\r\\n                .children()\\r\\n                .eq(0)\\r\\n                .outerWidth(true)\\r\\n        );\\r\\n      }\\r\\n    },\\r\\n\\r\\n    focus: function(duration) {\\r\\n      var self = this,\\r\\n        $list = self.$list,\\r\\n        $grid = self.$grid,\\r\\n        thumb,\\r\\n        thumbPos;\\r\\n\\r\\n      if (!self.instance.current) {\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      thumb = $list\\r\\n        .children()\\r\\n        .removeClass(CLASS_ACTIVE)\\r\\n        .filter(\\'[data-index=\"\\' + self.instance.current.index + \\'\"]\\')\\r\\n        .addClass(CLASS_ACTIVE);\\r\\n\\r\\n      thumbPos = thumb.position();\\r\\n\\r\\n      // Check if need to scroll to make current thumb visible\\r\\n      if (self.opts.axis === \"y\" && (thumbPos.top < 0 || thumbPos.top > $list.height() - thumb.outerHeight())) {\\r\\n        $list.stop().animate(\\r\\n          {\\r\\n            scrollTop: $list.scrollTop() + thumbPos.top\\r\\n          },\\r\\n          duration\\r\\n        );\\r\\n      } else if (\\r\\n        self.opts.axis === \"x\" &&\\r\\n        (thumbPos.left < $grid.scrollLeft() || thumbPos.left > $grid.scrollLeft() + ($grid.width() - thumb.outerWidth()))\\r\\n      ) {\\r\\n        $list\\r\\n          .parent()\\r\\n          .stop()\\r\\n          .animate(\\r\\n            {\\r\\n              scrollLeft: thumbPos.left\\r\\n            },\\r\\n            duration\\r\\n          );\\r\\n      }\\r\\n    },\\r\\n\\r\\n    update: function() {\\r\\n      var that = this;\\r\\n      that.instance.$refs.container.toggleClass(\"fancybox-show-thumbs\", this.isVisible);\\r\\n\\r\\n      if (that.isVisible) {\\r\\n        if (!that.$grid) {\\r\\n          that.create();\\r\\n        }\\r\\n\\r\\n        that.instance.trigger(\"onThumbsShow\");\\r\\n\\r\\n        that.focus(0);\\r\\n      } else if (that.$grid) {\\r\\n        that.instance.trigger(\"onThumbsHide\");\\r\\n      }\\r\\n\\r\\n      // Update content position\\r\\n      that.instance.update();\\r\\n    },\\r\\n\\r\\n    hide: function() {\\r\\n      this.isVisible = false;\\r\\n      this.update();\\r\\n    },\\r\\n\\r\\n    show: function() {\\r\\n      this.isVisible = true;\\r\\n      this.update();\\r\\n    },\\r\\n\\r\\n    toggle: function() {\\r\\n      this.isVisible = !this.isVisible;\\r\\n      this.update();\\r\\n    }\\r\\n  });\\r\\n\\r\\n  $(document).on({\\r\\n    \"onInit.fb\": function(e, instance) {\\r\\n      var Thumbs;\\r\\n\\r\\n      if (instance && !instance.Thumbs) {\\r\\n        Thumbs = new FancyThumbs(instance);\\r\\n\\r\\n        if (Thumbs.isActive && Thumbs.opts.autoStart === true) {\\r\\n          Thumbs.show();\\r\\n        }\\r\\n      }\\r\\n    },\\r\\n\\r\\n    \"beforeShow.fb\": function(e, instance, item, firstRun) {\\r\\n      var Thumbs = instance && instance.Thumbs;\\r\\n\\r\\n      if (Thumbs && Thumbs.isVisible) {\\r\\n        Thumbs.focus(firstRun ? 0 : 250);\\r\\n      }\\r\\n    },\\r\\n\\r\\n    \"afterKeydown.fb\": function(e, instance, current, keypress, keycode) {\\r\\n      var Thumbs = instance && instance.Thumbs;\\r\\n\\r\\n      // \"G\"\\r\\n      if (Thumbs && Thumbs.isActive && keycode === 71) {\\r\\n        keypress.preventDefault();\\r\\n\\r\\n        Thumbs.toggle();\\r\\n      }\\r\\n    },\\r\\n\\r\\n    \"beforeClose.fb\": function(e, instance) {\\r\\n      var Thumbs = instance && instance.Thumbs;\\r\\n\\r\\n      if (Thumbs && Thumbs.isVisible && Thumbs.opts.hideOnClose !== false) {\\r\\n        Thumbs.$grid.hide();\\r\\n      }\\r\\n    }\\r\\n  });\\r\\n})(document, jQuery);\\r\\n\\n//// ==========================================================================\\r\\n//\\r\\n// Share\\r\\n// Displays simple form for sharing current url\\r\\n//\\r\\n// ==========================================================================\\r\\n(function(document, $) {\\r\\n  \"use strict\";\\r\\n\\r\\n  $.extend(true, $.fancybox.defaults, {\\r\\n    btnTpl: {\\r\\n      share:\\r\\n        \\'<button data-fancybox-share class=\"fancybox-button fancybox-button--share\" title=\"{{SHARE}}\">\\' +\\r\\n        \\'<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\"><path d=\"M2.55 19c1.4-8.4 9.1-9.8 11.9-9.8V5l7 7-7 6.3v-3.5c-2.8 0-10.5 2.1-11.9 4.2z\"/></svg>\\' +\\r\\n        \"</button>\"\\r\\n    },\\r\\n    share: {\\r\\n      url: function(instance, item) {\\r\\n        return (\\r\\n          (!instance.currentHash && !(item.type === \"inline\" || item.type === \"html\") ? item.origSrc || item.src : false) || window.location\\r\\n        );\\r\\n      },\\r\\n      tpl:\\r\\n        \\'<div class=\"fancybox-share\">\\' +\\r\\n        \"<h1>{{SHARE}}</h1>\" +\\r\\n        \"<p>\" +\\r\\n        \\'<a class=\"fancybox-share__button fancybox-share__button--fb\" href=\"https://www.facebook.com/sharer/sharer.php?u={{url}}\">\\' +\\r\\n        \\'<svg viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m287 456v-299c0-21 6-35 35-35h38v-63c-7-1-29-3-55-3-54 0-91 33-91 94v306m143-254h-205v72h196\" /></svg>\\' +\\r\\n        \"<span>Facebook</span>\" +\\r\\n        \"</a>\" +\\r\\n        \\'<a class=\"fancybox-share__button fancybox-share__button--tw\" href=\"https://twitter.com/intent/tweet?url={{url}}&text={{descr}}\">\\' +\\r\\n        \\'<svg viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m456 133c-14 7-31 11-47 13 17-10 30-27 37-46-15 10-34 16-52 20-61-62-157-7-141 75-68-3-129-35-169-85-22 37-11 86 26 109-13 0-26-4-37-9 0 39 28 72 65 80-12 3-25 4-37 2 10 33 41 57 77 57-42 30-77 38-122 34 170 111 378-32 359-208 16-11 30-25 41-42z\" /></svg>\\' +\\r\\n        \"<span>Twitter</span>\" +\\r\\n        \"</a>\" +\\r\\n        \\'<a class=\"fancybox-share__button fancybox-share__button--pt\" href=\"https://www.pinterest.com/pin/create/button/?url={{url}}&description={{descr}}&media={{media}}\">\\' +\\r\\n        \\'<svg viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"m265 56c-109 0-164 78-164 144 0 39 15 74 47 87 5 2 10 0 12-5l4-19c2-6 1-8-3-13-9-11-15-25-15-45 0-58 43-110 113-110 62 0 96 38 96 88 0 67-30 122-73 122-24 0-42-19-36-44 6-29 20-60 20-81 0-19-10-35-31-35-25 0-44 26-44 60 0 21 7 36 7 36l-30 125c-8 37-1 83 0 87 0 3 4 4 5 2 2-3 32-39 42-75l16-64c8 16 31 29 56 29 74 0 124-67 124-157 0-69-58-132-146-132z\" fill=\"#fff\"/></svg>\\' +\\r\\n        \"<span>Pinterest</span>\" +\\r\\n        \"</a>\" +\\r\\n        \"</p>\" +\\r\\n        \\'<p><input class=\"fancybox-share__input\" type=\"text\" value=\"{{url_raw}}\" onclick=\"select()\" /></p>\\' +\\r\\n        \"</div>\"\\r\\n    }\\r\\n  });\\r\\n\\r\\n  function escapeHtml(string) {\\r\\n    var entityMap = {\\r\\n      \"&\": \"&amp;\",\\r\\n      \"<\": \"&lt;\",\\r\\n      \">\": \"&gt;\",\\r\\n      \\'\"\\': \"&quot;\",\\r\\n      \"\\'\": \"&#39;\",\\r\\n      \"/\": \"&#x2F;\",\\r\\n      \"`\": \"&#x60;\",\\r\\n      \"=\": \"&#x3D;\"\\r\\n    };\\r\\n\\r\\n    return String(string).replace(/[&<>\"\\'`=\\\\/]/g, function(s) {\\r\\n      return entityMap[s];\\r\\n    });\\r\\n  }\\r\\n\\r\\n  $(document).on(\"click\", \"[data-fancybox-share]\", function() {\\r\\n    var instance = $.fancybox.getInstance(),\\r\\n      current = instance.current || null,\\r\\n      url,\\r\\n      tpl;\\r\\n\\r\\n    if (!current) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    if ($.type(current.opts.share.url) === \"function\") {\\r\\n      url = current.opts.share.url.apply(current, [instance, current]);\\r\\n    }\\r\\n\\r\\n    tpl = current.opts.share.tpl\\r\\n      .replace(/\\\\{\\\\{media\\\\}\\\\}/g, current.type === \"image\" ? encodeURIComponent(current.src) : \"\")\\r\\n      .replace(/\\\\{\\\\{url\\\\}\\\\}/g, encodeURIComponent(url))\\r\\n      .replace(/\\\\{\\\\{url_raw\\\\}\\\\}/g, escapeHtml(url))\\r\\n      .replace(/\\\\{\\\\{descr\\\\}\\\\}/g, instance.$caption ? encodeURIComponent(instance.$caption.text()) : \"\");\\r\\n\\r\\n    $.fancybox.open({\\r\\n      src: instance.translate(instance, tpl),\\r\\n      type: \"html\",\\r\\n      opts: {\\r\\n        touch: false,\\r\\n        animationEffect: false,\\r\\n        afterLoad: function(shareInstance, shareCurrent) {\\r\\n          // Close self if parent instance is closing\\r\\n          instance.$refs.container.one(\"beforeClose.fb\", function() {\\r\\n            shareInstance.close(null, 0);\\r\\n          });\\r\\n\\r\\n          // Opening links in a popup window\\r\\n          shareCurrent.$content.find(\".fancybox-share__button\").click(function() {\\r\\n            window.open(this.href, \"Share\", \"width=550, height=450\");\\r\\n            return false;\\r\\n          });\\r\\n        },\\r\\n        mobile: {\\r\\n          autoFocus: false\\r\\n        }\\r\\n      }\\r\\n    });\\r\\n  });\\r\\n})(document, jQuery);\\r\\n\\n// ==========================================================================\\r\\n//\\r\\n// Hash\\r\\n// Enables linking to each modal\\r\\n//\\r\\n// ==========================================================================\\r\\n(function(window, document, $) {\\r\\n  \"use strict\";\\r\\n\\r\\n  // Simple $.escapeSelector polyfill (for jQuery prior v3)\\r\\n  if (!$.escapeSelector) {\\r\\n    $.escapeSelector = function(sel) {\\r\\n      var rcssescape = /([\\\\0-\\\\x1f\\\\x7f]|^-?\\\\d)|^-$|[^\\\\x80-\\\\uFFFF\\\\w-]/g;\\r\\n      var fcssescape = function(ch, asCodePoint) {\\r\\n        if (asCodePoint) {\\r\\n          // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\\r\\n          if (ch === \"\\\\0\") {\\r\\n            return \"\\\\uFFFD\";\\r\\n          }\\r\\n\\r\\n          // Control characters and (dependent upon position) numbers get escaped as code points\\r\\n          return ch.slice(0, -1) + \"\\\\\\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + \" \";\\r\\n        }\\r\\n\\r\\n        // Other potentially-special ASCII characters get backslash-escaped\\r\\n        return \"\\\\\\\\\" + ch;\\r\\n      };\\r\\n\\r\\n      return (sel + \"\").replace(rcssescape, fcssescape);\\r\\n    };\\r\\n  }\\r\\n\\r\\n  // Get info about gallery name and current index from url\\r\\n  function parseUrl() {\\r\\n    var hash = window.location.hash.substr(1),\\r\\n      rez = hash.split(\"-\"),\\r\\n      index = rez.length > 1 && /^\\\\+?\\\\d+$/.test(rez[rez.length - 1]) ? parseInt(rez.pop(-1), 10) || 1 : 1,\\r\\n      gallery = rez.join(\"-\");\\r\\n\\r\\n    return {\\r\\n      hash: hash,\\r\\n      /* Index is starting from 1 */\\r\\n      index: index < 1 ? 1 : index,\\r\\n      gallery: gallery\\r\\n    };\\r\\n  }\\r\\n\\r\\n  // Trigger click evnt on links to open new fancyBox instance\\r\\n  function triggerFromUrl(url) {\\r\\n    if (url.gallery !== \"\") {\\r\\n      // If we can find element matching \\'data-fancybox\\' atribute,\\r\\n      // then triggering click event should start fancyBox\\r\\n      $(\"[data-fancybox=\\'\" + $.escapeSelector(url.gallery) + \"\\']\")\\r\\n        .eq(url.index - 1)\\r\\n        .focus()\\r\\n        .trigger(\"click.fb-start\");\\r\\n    }\\r\\n  }\\r\\n\\r\\n  // Get gallery name from current instance\\r\\n  function getGalleryID(instance) {\\r\\n    var opts, ret;\\r\\n\\r\\n    if (!instance) {\\r\\n      return false;\\r\\n    }\\r\\n\\r\\n    opts = instance.current ? instance.current.opts : instance.opts;\\r\\n    ret = opts.hash || (opts.$orig ? opts.$orig.data(\"fancybox\") || opts.$orig.data(\"fancybox-trigger\") : \"\");\\r\\n\\r\\n    return ret === \"\" ? false : ret;\\r\\n  }\\r\\n\\r\\n  // Start when DOM becomes ready\\r\\n  $(function() {\\r\\n    // Check if user has disabled this module\\r\\n    if ($.fancybox.defaults.hash === false) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    // Update hash when opening/closing fancyBox\\r\\n    $(document).on({\\r\\n      \"onInit.fb\": function(e, instance) {\\r\\n        var url, gallery;\\r\\n\\r\\n        if (instance.group[instance.currIndex].opts.hash === false) {\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        url = parseUrl();\\r\\n        gallery = getGalleryID(instance);\\r\\n\\r\\n        // Make sure gallery start index matches index from hash\\r\\n        if (gallery && url.gallery && gallery == url.gallery) {\\r\\n          instance.currIndex = url.index - 1;\\r\\n        }\\r\\n      },\\r\\n\\r\\n      \"beforeShow.fb\": function(e, instance, current, firstRun) {\\r\\n        var gallery;\\r\\n\\r\\n        if (!current || current.opts.hash === false) {\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        // Check if need to update window hash\\r\\n        gallery = getGalleryID(instance);\\r\\n\\r\\n        if (!gallery) {\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        // Variable containing last hash value set by fancyBox\\r\\n        // It will be used to determine if fancyBox needs to close after hash change is detected\\r\\n        instance.currentHash = gallery + (instance.group.length > 1 ? \"-\" + (current.index + 1) : \"\");\\r\\n\\r\\n        // If current hash is the same (this instance most likely is opened by hashchange), then do nothing\\r\\n        if (window.location.hash === \"#\" + instance.currentHash) {\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        if (firstRun && !instance.origHash) {\\r\\n          instance.origHash = window.location.hash;\\r\\n        }\\r\\n\\r\\n        if (instance.hashTimer) {\\r\\n          clearTimeout(instance.hashTimer);\\r\\n        }\\r\\n\\r\\n        // Update hash\\r\\n        instance.hashTimer = setTimeout(function() {\\r\\n          if (\"replaceState\" in window.history) {\\r\\n            window.history[firstRun ? \"pushState\" : \"replaceState\"](\\r\\n              {},\\r\\n              document.title,\\r\\n              window.location.pathname + window.location.search + \"#\" + instance.currentHash\\r\\n            );\\r\\n\\r\\n            if (firstRun) {\\r\\n              instance.hasCreatedHistory = true;\\r\\n            }\\r\\n          } else {\\r\\n            window.location.hash = instance.currentHash;\\r\\n          }\\r\\n\\r\\n          instance.hashTimer = null;\\r\\n        }, 300);\\r\\n      },\\r\\n\\r\\n      \"beforeClose.fb\": function(e, instance, current) {\\r\\n        if (!current || current.opts.hash === false) {\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        clearTimeout(instance.hashTimer);\\r\\n\\r\\n        // Goto previous history entry\\r\\n        if (instance.currentHash && instance.hasCreatedHistory) {\\r\\n          window.history.back();\\r\\n        } else if (instance.currentHash) {\\r\\n          if (\"replaceState\" in window.history) {\\r\\n            window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (instance.origHash || \"\"));\\r\\n          } else {\\r\\n            window.location.hash = instance.origHash;\\r\\n          }\\r\\n        }\\r\\n\\r\\n        instance.currentHash = null;\\r\\n      }\\r\\n    });\\r\\n\\r\\n    // Check if need to start/close after url has changed\\r\\n    $(window).on(\"hashchange.fb\", function() {\\r\\n      var url = parseUrl(),\\r\\n        fb = null;\\r\\n\\r\\n      // Find last fancyBox instance that has \"hash\"\\r\\n      $.each(\\r\\n        $(\".fancybox-container\")\\r\\n          .get()\\r\\n          .reverse(),\\r\\n        function(index, value) {\\r\\n          var tmp = $(value).data(\"FancyBox\");\\r\\n\\r\\n          if (tmp && tmp.currentHash) {\\r\\n            fb = tmp;\\r\\n            return false;\\r\\n          }\\r\\n        }\\r\\n      );\\r\\n\\r\\n      if (fb) {\\r\\n        // Now, compare hash values\\r\\n        if (fb.currentHash !== url.gallery + \"-\" + url.index && !(url.index === 1 && fb.currentHash == url.gallery)) {\\r\\n          fb.currentHash = null;\\r\\n\\r\\n          fb.close();\\r\\n        }\\r\\n      } else if (url.gallery !== \"\") {\\r\\n        triggerFromUrl(url);\\r\\n      }\\r\\n    });\\r\\n\\r\\n    // Check current hash and trigger click event on matching element to start fancyBox, if needed\\r\\n    setTimeout(function() {\\r\\n      if (!$.fancybox.getInstance()) {\\r\\n        triggerFromUrl(parseUrl());\\r\\n      }\\r\\n    }, 50);\\r\\n  });\\r\\n})(window, document, jQuery);\\r\\n\\n// ==========================================================================\\r\\n//\\r\\n// Wheel\\r\\n// Basic mouse weheel support for gallery navigation\\r\\n//\\r\\n// ==========================================================================\\r\\n(function(document, $) {\\r\\n  \"use strict\";\\r\\n\\r\\n  var prevTime = new Date().getTime();\\r\\n\\r\\n  $(document).on({\\r\\n    \"onInit.fb\": function(e, instance, current) {\\r\\n      instance.$refs.stage.on(\"mousewheel DOMMouseScroll wheel MozMousePixelScroll\", function(e) {\\r\\n        var current = instance.current,\\r\\n          currTime = new Date().getTime();\\r\\n\\r\\n        if (instance.group.length < 2 || current.opts.wheel === false || (current.opts.wheel === \"auto\" && current.type !== \"image\")) {\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        e.preventDefault();\\r\\n        e.stopPropagation();\\r\\n\\r\\n        if (current.$slide.hasClass(\"fancybox-animated\")) {\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        e = e.originalEvent || e;\\r\\n\\r\\n        if (currTime - prevTime < 250) {\\r\\n          return;\\r\\n        }\\r\\n\\r\\n        prevTime = currTime;\\r\\n\\r\\n        instance[(-e.deltaY || -e.deltaX || e.wheelDelta || -e.detail) < 0 ? \"next\" : \"previous\"]();\\r\\n      });\\r\\n    }\\r\\n  });\\r\\n})(document, jQuery);\\r\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\\n\\n//# sourceURL=webpack:///./node_modules/@fancyapps/fancybox/dist/jquery.fancybox.js?')},\"./node_modules/bootstrap/js/dist/collapse.js\":function(module,exports,__webpack_require__){eval(\"(function (global, factory) {\\n   true ? module.exports = factory(__webpack_require__(/*! jquery */ \\\"./node_modules/jquery/dist/jquery.js\\\"), __webpack_require__(/*! ./util.js */ \\\"./node_modules/bootstrap/js/dist/util.js\\\")) :\\n  undefined;\\n}(this, (function ($,Util) { 'use strict';\\n\\n  $ = $ && $.hasOwnProperty('default') ? $['default'] : $;\\n  Util = Util && Util.hasOwnProperty('default') ? Util['default'] : Util;\\n\\n  function _defineProperties(target, props) {\\n    for (var i = 0; i < props.length; i++) {\\n      var descriptor = props[i];\\n      descriptor.enumerable = descriptor.enumerable || false;\\n      descriptor.configurable = true;\\n      if (\\\"value\\\" in descriptor) descriptor.writable = true;\\n      Object.defineProperty(target, descriptor.key, descriptor);\\n    }\\n  }\\n\\n  function _createClass(Constructor, protoProps, staticProps) {\\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\\n    if (staticProps) _defineProperties(Constructor, staticProps);\\n    return Constructor;\\n  }\\n\\n  function _defineProperty(obj, key, value) {\\n    if (key in obj) {\\n      Object.defineProperty(obj, key, {\\n        value: value,\\n        enumerable: true,\\n        configurable: true,\\n        writable: true\\n      });\\n    } else {\\n      obj[key] = value;\\n    }\\n\\n    return obj;\\n  }\\n\\n  function _objectSpread(target) {\\n    for (var i = 1; i < arguments.length; i++) {\\n      var source = arguments[i] != null ? arguments[i] : {};\\n      var ownKeys = Object.keys(source);\\n\\n      if (typeof Object.getOwnPropertySymbols === 'function') {\\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\\n        }));\\n      }\\n\\n      ownKeys.forEach(function (key) {\\n        _defineProperty(target, key, source[key]);\\n      });\\n    }\\n\\n    return target;\\n  }\\n\\n  /**\\n   * --------------------------------------------------------------------------\\n   * Bootstrap (v4.1.3): collapse.js\\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n   * --------------------------------------------------------------------------\\n   */\\n\\n  var Collapse = function ($$$1) {\\n    /**\\n     * ------------------------------------------------------------------------\\n     * Constants\\n     * ------------------------------------------------------------------------\\n     */\\n    var NAME = 'collapse';\\n    var VERSION = '4.1.3';\\n    var DATA_KEY = 'bs.collapse';\\n    var EVENT_KEY = \\\".\\\" + DATA_KEY;\\n    var DATA_API_KEY = '.data-api';\\n    var JQUERY_NO_CONFLICT = $$$1.fn[NAME];\\n    var Default = {\\n      toggle: true,\\n      parent: ''\\n    };\\n    var DefaultType = {\\n      toggle: 'boolean',\\n      parent: '(string|element)'\\n    };\\n    var Event = {\\n      SHOW: \\\"show\\\" + EVENT_KEY,\\n      SHOWN: \\\"shown\\\" + EVENT_KEY,\\n      HIDE: \\\"hide\\\" + EVENT_KEY,\\n      HIDDEN: \\\"hidden\\\" + EVENT_KEY,\\n      CLICK_DATA_API: \\\"click\\\" + EVENT_KEY + DATA_API_KEY\\n    };\\n    var ClassName = {\\n      SHOW: 'show',\\n      COLLAPSE: 'collapse',\\n      COLLAPSING: 'collapsing',\\n      COLLAPSED: 'collapsed'\\n    };\\n    var Dimension = {\\n      WIDTH: 'width',\\n      HEIGHT: 'height'\\n    };\\n    var Selector = {\\n      ACTIVES: '.show, .collapsing',\\n      DATA_TOGGLE: '[data-toggle=\\\"collapse\\\"]'\\n      /**\\n       * ------------------------------------------------------------------------\\n       * Class Definition\\n       * ------------------------------------------------------------------------\\n       */\\n\\n    };\\n\\n    var Collapse =\\n    /*#__PURE__*/\\n    function () {\\n      function Collapse(element, config) {\\n        this._isTransitioning = false;\\n        this._element = element;\\n        this._config = this._getConfig(config);\\n        this._triggerArray = $$$1.makeArray(document.querySelectorAll(\\\"[data-toggle=\\\\\\\"collapse\\\\\\\"][href=\\\\\\\"#\\\" + element.id + \\\"\\\\\\\"],\\\" + (\\\"[data-toggle=\\\\\\\"collapse\\\\\\\"][data-target=\\\\\\\"#\\\" + element.id + \\\"\\\\\\\"]\\\")));\\n        var toggleList = [].slice.call(document.querySelectorAll(Selector.DATA_TOGGLE));\\n\\n        for (var i = 0, len = toggleList.length; i < len; i++) {\\n          var elem = toggleList[i];\\n          var selector = Util.getSelectorFromElement(elem);\\n          var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function (foundElem) {\\n            return foundElem === element;\\n          });\\n\\n          if (selector !== null && filterElement.length > 0) {\\n            this._selector = selector;\\n\\n            this._triggerArray.push(elem);\\n          }\\n        }\\n\\n        this._parent = this._config.parent ? this._getParent() : null;\\n\\n        if (!this._config.parent) {\\n          this._addAriaAndCollapsedClass(this._element, this._triggerArray);\\n        }\\n\\n        if (this._config.toggle) {\\n          this.toggle();\\n        }\\n      } // Getters\\n\\n\\n      var _proto = Collapse.prototype;\\n\\n      // Public\\n      _proto.toggle = function toggle() {\\n        if ($$$1(this._element).hasClass(ClassName.SHOW)) {\\n          this.hide();\\n        } else {\\n          this.show();\\n        }\\n      };\\n\\n      _proto.show = function show() {\\n        var _this = this;\\n\\n        if (this._isTransitioning || $$$1(this._element).hasClass(ClassName.SHOW)) {\\n          return;\\n        }\\n\\n        var actives;\\n        var activesData;\\n\\n        if (this._parent) {\\n          actives = [].slice.call(this._parent.querySelectorAll(Selector.ACTIVES)).filter(function (elem) {\\n            return elem.getAttribute('data-parent') === _this._config.parent;\\n          });\\n\\n          if (actives.length === 0) {\\n            actives = null;\\n          }\\n        }\\n\\n        if (actives) {\\n          activesData = $$$1(actives).not(this._selector).data(DATA_KEY);\\n\\n          if (activesData && activesData._isTransitioning) {\\n            return;\\n          }\\n        }\\n\\n        var startEvent = $$$1.Event(Event.SHOW);\\n        $$$1(this._element).trigger(startEvent);\\n\\n        if (startEvent.isDefaultPrevented()) {\\n          return;\\n        }\\n\\n        if (actives) {\\n          Collapse._jQueryInterface.call($$$1(actives).not(this._selector), 'hide');\\n\\n          if (!activesData) {\\n            $$$1(actives).data(DATA_KEY, null);\\n          }\\n        }\\n\\n        var dimension = this._getDimension();\\n\\n        $$$1(this._element).removeClass(ClassName.COLLAPSE).addClass(ClassName.COLLAPSING);\\n        this._element.style[dimension] = 0;\\n\\n        if (this._triggerArray.length) {\\n          $$$1(this._triggerArray).removeClass(ClassName.COLLAPSED).attr('aria-expanded', true);\\n        }\\n\\n        this.setTransitioning(true);\\n\\n        var complete = function complete() {\\n          $$$1(_this._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).addClass(ClassName.SHOW);\\n          _this._element.style[dimension] = '';\\n\\n          _this.setTransitioning(false);\\n\\n          $$$1(_this._element).trigger(Event.SHOWN);\\n        };\\n\\n        var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\\n        var scrollSize = \\\"scroll\\\" + capitalizedDimension;\\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\\n        $$$1(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\\n        this._element.style[dimension] = this._element[scrollSize] + \\\"px\\\";\\n      };\\n\\n      _proto.hide = function hide() {\\n        var _this2 = this;\\n\\n        if (this._isTransitioning || !$$$1(this._element).hasClass(ClassName.SHOW)) {\\n          return;\\n        }\\n\\n        var startEvent = $$$1.Event(Event.HIDE);\\n        $$$1(this._element).trigger(startEvent);\\n\\n        if (startEvent.isDefaultPrevented()) {\\n          return;\\n        }\\n\\n        var dimension = this._getDimension();\\n\\n        this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + \\\"px\\\";\\n        Util.reflow(this._element);\\n        $$$1(this._element).addClass(ClassName.COLLAPSING).removeClass(ClassName.COLLAPSE).removeClass(ClassName.SHOW);\\n        var triggerArrayLength = this._triggerArray.length;\\n\\n        if (triggerArrayLength > 0) {\\n          for (var i = 0; i < triggerArrayLength; i++) {\\n            var trigger = this._triggerArray[i];\\n            var selector = Util.getSelectorFromElement(trigger);\\n\\n            if (selector !== null) {\\n              var $elem = $$$1([].slice.call(document.querySelectorAll(selector)));\\n\\n              if (!$elem.hasClass(ClassName.SHOW)) {\\n                $$$1(trigger).addClass(ClassName.COLLAPSED).attr('aria-expanded', false);\\n              }\\n            }\\n          }\\n        }\\n\\n        this.setTransitioning(true);\\n\\n        var complete = function complete() {\\n          _this2.setTransitioning(false);\\n\\n          $$$1(_this2._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).trigger(Event.HIDDEN);\\n        };\\n\\n        this._element.style[dimension] = '';\\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\\n        $$$1(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\\n      };\\n\\n      _proto.setTransitioning = function setTransitioning(isTransitioning) {\\n        this._isTransitioning = isTransitioning;\\n      };\\n\\n      _proto.dispose = function dispose() {\\n        $$$1.removeData(this._element, DATA_KEY);\\n        this._config = null;\\n        this._parent = null;\\n        this._element = null;\\n        this._triggerArray = null;\\n        this._isTransitioning = null;\\n      }; // Private\\n\\n\\n      _proto._getConfig = function _getConfig(config) {\\n        config = _objectSpread({}, Default, config);\\n        config.toggle = Boolean(config.toggle); // Coerce string values\\n\\n        Util.typeCheckConfig(NAME, config, DefaultType);\\n        return config;\\n      };\\n\\n      _proto._getDimension = function _getDimension() {\\n        var hasWidth = $$$1(this._element).hasClass(Dimension.WIDTH);\\n        return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;\\n      };\\n\\n      _proto._getParent = function _getParent() {\\n        var _this3 = this;\\n\\n        var parent = null;\\n\\n        if (Util.isElement(this._config.parent)) {\\n          parent = this._config.parent; // It's a jQuery object\\n\\n          if (typeof this._config.parent.jquery !== 'undefined') {\\n            parent = this._config.parent[0];\\n          }\\n        } else {\\n          parent = document.querySelector(this._config.parent);\\n        }\\n\\n        var selector = \\\"[data-toggle=\\\\\\\"collapse\\\\\\\"][data-parent=\\\\\\\"\\\" + this._config.parent + \\\"\\\\\\\"]\\\";\\n        var children = [].slice.call(parent.querySelectorAll(selector));\\n        $$$1(children).each(function (i, element) {\\n          _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);\\n        });\\n        return parent;\\n      };\\n\\n      _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {\\n        if (element) {\\n          var isOpen = $$$1(element).hasClass(ClassName.SHOW);\\n\\n          if (triggerArray.length) {\\n            $$$1(triggerArray).toggleClass(ClassName.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);\\n          }\\n        }\\n      }; // Static\\n\\n\\n      Collapse._getTargetFromElement = function _getTargetFromElement(element) {\\n        var selector = Util.getSelectorFromElement(element);\\n        return selector ? document.querySelector(selector) : null;\\n      };\\n\\n      Collapse._jQueryInterface = function _jQueryInterface(config) {\\n        return this.each(function () {\\n          var $this = $$$1(this);\\n          var data = $this.data(DATA_KEY);\\n\\n          var _config = _objectSpread({}, Default, $this.data(), typeof config === 'object' && config ? config : {});\\n\\n          if (!data && _config.toggle && /show|hide/.test(config)) {\\n            _config.toggle = false;\\n          }\\n\\n          if (!data) {\\n            data = new Collapse(this, _config);\\n            $this.data(DATA_KEY, data);\\n          }\\n\\n          if (typeof config === 'string') {\\n            if (typeof data[config] === 'undefined') {\\n              throw new TypeError(\\\"No method named \\\\\\\"\\\" + config + \\\"\\\\\\\"\\\");\\n            }\\n\\n            data[config]();\\n          }\\n        });\\n      };\\n\\n      _createClass(Collapse, null, [{\\n        key: \\\"VERSION\\\",\\n        get: function get() {\\n          return VERSION;\\n        }\\n      }, {\\n        key: \\\"Default\\\",\\n        get: function get() {\\n          return Default;\\n        }\\n      }]);\\n\\n      return Collapse;\\n    }();\\n    /**\\n     * ------------------------------------------------------------------------\\n     * Data Api implementation\\n     * ------------------------------------------------------------------------\\n     */\\n\\n\\n    $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\\n      // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\\n      if (event.currentTarget.tagName === 'A') {\\n        event.preventDefault();\\n      }\\n\\n      var $trigger = $$$1(this);\\n      var selector = Util.getSelectorFromElement(this);\\n      var selectors = [].slice.call(document.querySelectorAll(selector));\\n      $$$1(selectors).each(function () {\\n        var $target = $$$1(this);\\n        var data = $target.data(DATA_KEY);\\n        var config = data ? 'toggle' : $trigger.data();\\n\\n        Collapse._jQueryInterface.call($target, config);\\n      });\\n    });\\n    /**\\n     * ------------------------------------------------------------------------\\n     * jQuery\\n     * ------------------------------------------------------------------------\\n     */\\n\\n    $$$1.fn[NAME] = Collapse._jQueryInterface;\\n    $$$1.fn[NAME].Constructor = Collapse;\\n\\n    $$$1.fn[NAME].noConflict = function () {\\n      $$$1.fn[NAME] = JQUERY_NO_CONFLICT;\\n      return Collapse._jQueryInterface;\\n    };\\n\\n    return Collapse;\\n  }($);\\n\\n  return Collapse;\\n\\n})));\\n//# sourceMappingURL=collapse.js.map\\n\\n\\n//# sourceURL=webpack:///./node_modules/bootstrap/js/dist/collapse.js?\")},\"./node_modules/bootstrap/js/dist/modal.js\":function(module,exports,__webpack_require__){eval(\"(function (global, factory) {\\n   true ? module.exports = factory(__webpack_require__(/*! jquery */ \\\"./node_modules/jquery/dist/jquery.js\\\"), __webpack_require__(/*! ./util.js */ \\\"./node_modules/bootstrap/js/dist/util.js\\\")) :\\n  undefined;\\n}(this, (function ($,Util) { 'use strict';\\n\\n  $ = $ && $.hasOwnProperty('default') ? $['default'] : $;\\n  Util = Util && Util.hasOwnProperty('default') ? Util['default'] : Util;\\n\\n  function _defineProperties(target, props) {\\n    for (var i = 0; i < props.length; i++) {\\n      var descriptor = props[i];\\n      descriptor.enumerable = descriptor.enumerable || false;\\n      descriptor.configurable = true;\\n      if (\\\"value\\\" in descriptor) descriptor.writable = true;\\n      Object.defineProperty(target, descriptor.key, descriptor);\\n    }\\n  }\\n\\n  function _createClass(Constructor, protoProps, staticProps) {\\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\\n    if (staticProps) _defineProperties(Constructor, staticProps);\\n    return Constructor;\\n  }\\n\\n  function _defineProperty(obj, key, value) {\\n    if (key in obj) {\\n      Object.defineProperty(obj, key, {\\n        value: value,\\n        enumerable: true,\\n        configurable: true,\\n        writable: true\\n      });\\n    } else {\\n      obj[key] = value;\\n    }\\n\\n    return obj;\\n  }\\n\\n  function _objectSpread(target) {\\n    for (var i = 1; i < arguments.length; i++) {\\n      var source = arguments[i] != null ? arguments[i] : {};\\n      var ownKeys = Object.keys(source);\\n\\n      if (typeof Object.getOwnPropertySymbols === 'function') {\\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\\n        }));\\n      }\\n\\n      ownKeys.forEach(function (key) {\\n        _defineProperty(target, key, source[key]);\\n      });\\n    }\\n\\n    return target;\\n  }\\n\\n  /**\\n   * --------------------------------------------------------------------------\\n   * Bootstrap (v4.1.3): modal.js\\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n   * --------------------------------------------------------------------------\\n   */\\n\\n  var Modal = function ($$$1) {\\n    /**\\n     * ------------------------------------------------------------------------\\n     * Constants\\n     * ------------------------------------------------------------------------\\n     */\\n    var NAME = 'modal';\\n    var VERSION = '4.1.3';\\n    var DATA_KEY = 'bs.modal';\\n    var EVENT_KEY = \\\".\\\" + DATA_KEY;\\n    var DATA_API_KEY = '.data-api';\\n    var JQUERY_NO_CONFLICT = $$$1.fn[NAME];\\n    var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key\\n\\n    var Default = {\\n      backdrop: true,\\n      keyboard: true,\\n      focus: true,\\n      show: true\\n    };\\n    var DefaultType = {\\n      backdrop: '(boolean|string)',\\n      keyboard: 'boolean',\\n      focus: 'boolean',\\n      show: 'boolean'\\n    };\\n    var Event = {\\n      HIDE: \\\"hide\\\" + EVENT_KEY,\\n      HIDDEN: \\\"hidden\\\" + EVENT_KEY,\\n      SHOW: \\\"show\\\" + EVENT_KEY,\\n      SHOWN: \\\"shown\\\" + EVENT_KEY,\\n      FOCUSIN: \\\"focusin\\\" + EVENT_KEY,\\n      RESIZE: \\\"resize\\\" + EVENT_KEY,\\n      CLICK_DISMISS: \\\"click.dismiss\\\" + EVENT_KEY,\\n      KEYDOWN_DISMISS: \\\"keydown.dismiss\\\" + EVENT_KEY,\\n      MOUSEUP_DISMISS: \\\"mouseup.dismiss\\\" + EVENT_KEY,\\n      MOUSEDOWN_DISMISS: \\\"mousedown.dismiss\\\" + EVENT_KEY,\\n      CLICK_DATA_API: \\\"click\\\" + EVENT_KEY + DATA_API_KEY\\n    };\\n    var ClassName = {\\n      SCROLLBAR_MEASURER: 'modal-scrollbar-measure',\\n      BACKDROP: 'modal-backdrop',\\n      OPEN: 'modal-open',\\n      FADE: 'fade',\\n      SHOW: 'show'\\n    };\\n    var Selector = {\\n      DIALOG: '.modal-dialog',\\n      DATA_TOGGLE: '[data-toggle=\\\"modal\\\"]',\\n      DATA_DISMISS: '[data-dismiss=\\\"modal\\\"]',\\n      FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',\\n      STICKY_CONTENT: '.sticky-top'\\n      /**\\n       * ------------------------------------------------------------------------\\n       * Class Definition\\n       * ------------------------------------------------------------------------\\n       */\\n\\n    };\\n\\n    var Modal =\\n    /*#__PURE__*/\\n    function () {\\n      function Modal(element, config) {\\n        this._config = this._getConfig(config);\\n        this._element = element;\\n        this._dialog = element.querySelector(Selector.DIALOG);\\n        this._backdrop = null;\\n        this._isShown = false;\\n        this._isBodyOverflowing = false;\\n        this._ignoreBackdropClick = false;\\n        this._scrollbarWidth = 0;\\n      } // Getters\\n\\n\\n      var _proto = Modal.prototype;\\n\\n      // Public\\n      _proto.toggle = function toggle(relatedTarget) {\\n        return this._isShown ? this.hide() : this.show(relatedTarget);\\n      };\\n\\n      _proto.show = function show(relatedTarget) {\\n        var _this = this;\\n\\n        if (this._isTransitioning || this._isShown) {\\n          return;\\n        }\\n\\n        if ($$$1(this._element).hasClass(ClassName.FADE)) {\\n          this._isTransitioning = true;\\n        }\\n\\n        var showEvent = $$$1.Event(Event.SHOW, {\\n          relatedTarget: relatedTarget\\n        });\\n        $$$1(this._element).trigger(showEvent);\\n\\n        if (this._isShown || showEvent.isDefaultPrevented()) {\\n          return;\\n        }\\n\\n        this._isShown = true;\\n\\n        this._checkScrollbar();\\n\\n        this._setScrollbar();\\n\\n        this._adjustDialog();\\n\\n        $$$1(document.body).addClass(ClassName.OPEN);\\n\\n        this._setEscapeEvent();\\n\\n        this._setResizeEvent();\\n\\n        $$$1(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, function (event) {\\n          return _this.hide(event);\\n        });\\n        $$$1(this._dialog).on(Event.MOUSEDOWN_DISMISS, function () {\\n          $$$1(_this._element).one(Event.MOUSEUP_DISMISS, function (event) {\\n            if ($$$1(event.target).is(_this._element)) {\\n              _this._ignoreBackdropClick = true;\\n            }\\n          });\\n        });\\n\\n        this._showBackdrop(function () {\\n          return _this._showElement(relatedTarget);\\n        });\\n      };\\n\\n      _proto.hide = function hide(event) {\\n        var _this2 = this;\\n\\n        if (event) {\\n          event.preventDefault();\\n        }\\n\\n        if (this._isTransitioning || !this._isShown) {\\n          return;\\n        }\\n\\n        var hideEvent = $$$1.Event(Event.HIDE);\\n        $$$1(this._element).trigger(hideEvent);\\n\\n        if (!this._isShown || hideEvent.isDefaultPrevented()) {\\n          return;\\n        }\\n\\n        this._isShown = false;\\n        var transition = $$$1(this._element).hasClass(ClassName.FADE);\\n\\n        if (transition) {\\n          this._isTransitioning = true;\\n        }\\n\\n        this._setEscapeEvent();\\n\\n        this._setResizeEvent();\\n\\n        $$$1(document).off(Event.FOCUSIN);\\n        $$$1(this._element).removeClass(ClassName.SHOW);\\n        $$$1(this._element).off(Event.CLICK_DISMISS);\\n        $$$1(this._dialog).off(Event.MOUSEDOWN_DISMISS);\\n\\n        if (transition) {\\n          var transitionDuration = Util.getTransitionDurationFromElement(this._element);\\n          $$$1(this._element).one(Util.TRANSITION_END, function (event) {\\n            return _this2._hideModal(event);\\n          }).emulateTransitionEnd(transitionDuration);\\n        } else {\\n          this._hideModal();\\n        }\\n      };\\n\\n      _proto.dispose = function dispose() {\\n        $$$1.removeData(this._element, DATA_KEY);\\n        $$$1(window, document, this._element, this._backdrop).off(EVENT_KEY);\\n        this._config = null;\\n        this._element = null;\\n        this._dialog = null;\\n        this._backdrop = null;\\n        this._isShown = null;\\n        this._isBodyOverflowing = null;\\n        this._ignoreBackdropClick = null;\\n        this._scrollbarWidth = null;\\n      };\\n\\n      _proto.handleUpdate = function handleUpdate() {\\n        this._adjustDialog();\\n      }; // Private\\n\\n\\n      _proto._getConfig = function _getConfig(config) {\\n        config = _objectSpread({}, Default, config);\\n        Util.typeCheckConfig(NAME, config, DefaultType);\\n        return config;\\n      };\\n\\n      _proto._showElement = function _showElement(relatedTarget) {\\n        var _this3 = this;\\n\\n        var transition = $$$1(this._element).hasClass(ClassName.FADE);\\n\\n        if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {\\n          // Don't move modal's DOM position\\n          document.body.appendChild(this._element);\\n        }\\n\\n        this._element.style.display = 'block';\\n\\n        this._element.removeAttribute('aria-hidden');\\n\\n        this._element.scrollTop = 0;\\n\\n        if (transition) {\\n          Util.reflow(this._element);\\n        }\\n\\n        $$$1(this._element).addClass(ClassName.SHOW);\\n\\n        if (this._config.focus) {\\n          this._enforceFocus();\\n        }\\n\\n        var shownEvent = $$$1.Event(Event.SHOWN, {\\n          relatedTarget: relatedTarget\\n        });\\n\\n        var transitionComplete = function transitionComplete() {\\n          if (_this3._config.focus) {\\n            _this3._element.focus();\\n          }\\n\\n          _this3._isTransitioning = false;\\n          $$$1(_this3._element).trigger(shownEvent);\\n        };\\n\\n        if (transition) {\\n          var transitionDuration = Util.getTransitionDurationFromElement(this._element);\\n          $$$1(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);\\n        } else {\\n          transitionComplete();\\n        }\\n      };\\n\\n      _proto._enforceFocus = function _enforceFocus() {\\n        var _this4 = this;\\n\\n        $$$1(document).off(Event.FOCUSIN) // Guard against infinite focus loop\\n        .on(Event.FOCUSIN, function (event) {\\n          if (document !== event.target && _this4._element !== event.target && $$$1(_this4._element).has(event.target).length === 0) {\\n            _this4._element.focus();\\n          }\\n        });\\n      };\\n\\n      _proto._setEscapeEvent = function _setEscapeEvent() {\\n        var _this5 = this;\\n\\n        if (this._isShown && this._config.keyboard) {\\n          $$$1(this._element).on(Event.KEYDOWN_DISMISS, function (event) {\\n            if (event.which === ESCAPE_KEYCODE) {\\n              event.preventDefault();\\n\\n              _this5.hide();\\n            }\\n          });\\n        } else if (!this._isShown) {\\n          $$$1(this._element).off(Event.KEYDOWN_DISMISS);\\n        }\\n      };\\n\\n      _proto._setResizeEvent = function _setResizeEvent() {\\n        var _this6 = this;\\n\\n        if (this._isShown) {\\n          $$$1(window).on(Event.RESIZE, function (event) {\\n            return _this6.handleUpdate(event);\\n          });\\n        } else {\\n          $$$1(window).off(Event.RESIZE);\\n        }\\n      };\\n\\n      _proto._hideModal = function _hideModal() {\\n        var _this7 = this;\\n\\n        this._element.style.display = 'none';\\n\\n        this._element.setAttribute('aria-hidden', true);\\n\\n        this._isTransitioning = false;\\n\\n        this._showBackdrop(function () {\\n          $$$1(document.body).removeClass(ClassName.OPEN);\\n\\n          _this7._resetAdjustments();\\n\\n          _this7._resetScrollbar();\\n\\n          $$$1(_this7._element).trigger(Event.HIDDEN);\\n        });\\n      };\\n\\n      _proto._removeBackdrop = function _removeBackdrop() {\\n        if (this._backdrop) {\\n          $$$1(this._backdrop).remove();\\n          this._backdrop = null;\\n        }\\n      };\\n\\n      _proto._showBackdrop = function _showBackdrop(callback) {\\n        var _this8 = this;\\n\\n        var animate = $$$1(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : '';\\n\\n        if (this._isShown && this._config.backdrop) {\\n          this._backdrop = document.createElement('div');\\n          this._backdrop.className = ClassName.BACKDROP;\\n\\n          if (animate) {\\n            this._backdrop.classList.add(animate);\\n          }\\n\\n          $$$1(this._backdrop).appendTo(document.body);\\n          $$$1(this._element).on(Event.CLICK_DISMISS, function (event) {\\n            if (_this8._ignoreBackdropClick) {\\n              _this8._ignoreBackdropClick = false;\\n              return;\\n            }\\n\\n            if (event.target !== event.currentTarget) {\\n              return;\\n            }\\n\\n            if (_this8._config.backdrop === 'static') {\\n              _this8._element.focus();\\n            } else {\\n              _this8.hide();\\n            }\\n          });\\n\\n          if (animate) {\\n            Util.reflow(this._backdrop);\\n          }\\n\\n          $$$1(this._backdrop).addClass(ClassName.SHOW);\\n\\n          if (!callback) {\\n            return;\\n          }\\n\\n          if (!animate) {\\n            callback();\\n            return;\\n          }\\n\\n          var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);\\n          $$$1(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);\\n        } else if (!this._isShown && this._backdrop) {\\n          $$$1(this._backdrop).removeClass(ClassName.SHOW);\\n\\n          var callbackRemove = function callbackRemove() {\\n            _this8._removeBackdrop();\\n\\n            if (callback) {\\n              callback();\\n            }\\n          };\\n\\n          if ($$$1(this._element).hasClass(ClassName.FADE)) {\\n            var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);\\n\\n            $$$1(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);\\n          } else {\\n            callbackRemove();\\n          }\\n        } else if (callback) {\\n          callback();\\n        }\\n      }; // ----------------------------------------------------------------------\\n      // the following methods are used to handle overflowing modals\\n      // todo (fat): these should probably be refactored out of modal.js\\n      // ----------------------------------------------------------------------\\n\\n\\n      _proto._adjustDialog = function _adjustDialog() {\\n        var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\\n\\n        if (!this._isBodyOverflowing && isModalOverflowing) {\\n          this._element.style.paddingLeft = this._scrollbarWidth + \\\"px\\\";\\n        }\\n\\n        if (this._isBodyOverflowing && !isModalOverflowing) {\\n          this._element.style.paddingRight = this._scrollbarWidth + \\\"px\\\";\\n        }\\n      };\\n\\n      _proto._resetAdjustments = function _resetAdjustments() {\\n        this._element.style.paddingLeft = '';\\n        this._element.style.paddingRight = '';\\n      };\\n\\n      _proto._checkScrollbar = function _checkScrollbar() {\\n        var rect = document.body.getBoundingClientRect();\\n        this._isBodyOverflowing = rect.left + rect.right < window.innerWidth;\\n        this._scrollbarWidth = this._getScrollbarWidth();\\n      };\\n\\n      _proto._setScrollbar = function _setScrollbar() {\\n        var _this9 = this;\\n\\n        if (this._isBodyOverflowing) {\\n          // Note: DOMNode.style.paddingRight returns the actual value or '' if not set\\n          //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set\\n          var fixedContent = [].slice.call(document.querySelectorAll(Selector.FIXED_CONTENT));\\n          var stickyContent = [].slice.call(document.querySelectorAll(Selector.STICKY_CONTENT)); // Adjust fixed content padding\\n\\n          $$$1(fixedContent).each(function (index, element) {\\n            var actualPadding = element.style.paddingRight;\\n            var calculatedPadding = $$$1(element).css('padding-right');\\n            $$$1(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this9._scrollbarWidth + \\\"px\\\");\\n          }); // Adjust sticky content margin\\n\\n          $$$1(stickyContent).each(function (index, element) {\\n            var actualMargin = element.style.marginRight;\\n            var calculatedMargin = $$$1(element).css('margin-right');\\n            $$$1(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this9._scrollbarWidth + \\\"px\\\");\\n          }); // Adjust body padding\\n\\n          var actualPadding = document.body.style.paddingRight;\\n          var calculatedPadding = $$$1(document.body).css('padding-right');\\n          $$$1(document.body).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + \\\"px\\\");\\n        }\\n      };\\n\\n      _proto._resetScrollbar = function _resetScrollbar() {\\n        // Restore fixed content padding\\n        var fixedContent = [].slice.call(document.querySelectorAll(Selector.FIXED_CONTENT));\\n        $$$1(fixedContent).each(function (index, element) {\\n          var padding = $$$1(element).data('padding-right');\\n          $$$1(element).removeData('padding-right');\\n          element.style.paddingRight = padding ? padding : '';\\n        }); // Restore sticky content\\n\\n        var elements = [].slice.call(document.querySelectorAll(\\\"\\\" + Selector.STICKY_CONTENT));\\n        $$$1(elements).each(function (index, element) {\\n          var margin = $$$1(element).data('margin-right');\\n\\n          if (typeof margin !== 'undefined') {\\n            $$$1(element).css('margin-right', margin).removeData('margin-right');\\n          }\\n        }); // Restore body padding\\n\\n        var padding = $$$1(document.body).data('padding-right');\\n        $$$1(document.body).removeData('padding-right');\\n        document.body.style.paddingRight = padding ? padding : '';\\n      };\\n\\n      _proto._getScrollbarWidth = function _getScrollbarWidth() {\\n        // thx d.walsh\\n        var scrollDiv = document.createElement('div');\\n        scrollDiv.className = ClassName.SCROLLBAR_MEASURER;\\n        document.body.appendChild(scrollDiv);\\n        var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;\\n        document.body.removeChild(scrollDiv);\\n        return scrollbarWidth;\\n      }; // Static\\n\\n\\n      Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {\\n        return this.each(function () {\\n          var data = $$$1(this).data(DATA_KEY);\\n\\n          var _config = _objectSpread({}, Default, $$$1(this).data(), typeof config === 'object' && config ? config : {});\\n\\n          if (!data) {\\n            data = new Modal(this, _config);\\n            $$$1(this).data(DATA_KEY, data);\\n          }\\n\\n          if (typeof config === 'string') {\\n            if (typeof data[config] === 'undefined') {\\n              throw new TypeError(\\\"No method named \\\\\\\"\\\" + config + \\\"\\\\\\\"\\\");\\n            }\\n\\n            data[config](relatedTarget);\\n          } else if (_config.show) {\\n            data.show(relatedTarget);\\n          }\\n        });\\n      };\\n\\n      _createClass(Modal, null, [{\\n        key: \\\"VERSION\\\",\\n        get: function get() {\\n          return VERSION;\\n        }\\n      }, {\\n        key: \\\"Default\\\",\\n        get: function get() {\\n          return Default;\\n        }\\n      }]);\\n\\n      return Modal;\\n    }();\\n    /**\\n     * ------------------------------------------------------------------------\\n     * Data Api implementation\\n     * ------------------------------------------------------------------------\\n     */\\n\\n\\n    $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\\n      var _this10 = this;\\n\\n      var target;\\n      var selector = Util.getSelectorFromElement(this);\\n\\n      if (selector) {\\n        target = document.querySelector(selector);\\n      }\\n\\n      var config = $$$1(target).data(DATA_KEY) ? 'toggle' : _objectSpread({}, $$$1(target).data(), $$$1(this).data());\\n\\n      if (this.tagName === 'A' || this.tagName === 'AREA') {\\n        event.preventDefault();\\n      }\\n\\n      var $target = $$$1(target).one(Event.SHOW, function (showEvent) {\\n        if (showEvent.isDefaultPrevented()) {\\n          // Only register focus restorer if modal will actually get shown\\n          return;\\n        }\\n\\n        $target.one(Event.HIDDEN, function () {\\n          if ($$$1(_this10).is(':visible')) {\\n            _this10.focus();\\n          }\\n        });\\n      });\\n\\n      Modal._jQueryInterface.call($$$1(target), config, this);\\n    });\\n    /**\\n     * ------------------------------------------------------------------------\\n     * jQuery\\n     * ------------------------------------------------------------------------\\n     */\\n\\n    $$$1.fn[NAME] = Modal._jQueryInterface;\\n    $$$1.fn[NAME].Constructor = Modal;\\n\\n    $$$1.fn[NAME].noConflict = function () {\\n      $$$1.fn[NAME] = JQUERY_NO_CONFLICT;\\n      return Modal._jQueryInterface;\\n    };\\n\\n    return Modal;\\n  }($);\\n\\n  return Modal;\\n\\n})));\\n//# sourceMappingURL=modal.js.map\\n\\n\\n//# sourceURL=webpack:///./node_modules/bootstrap/js/dist/modal.js?\")},\"./node_modules/bootstrap/js/dist/tab.js\":function(module,exports,__webpack_require__){eval(\"(function (global, factory) {\\n   true ? module.exports = factory(__webpack_require__(/*! jquery */ \\\"./node_modules/jquery/dist/jquery.js\\\"), __webpack_require__(/*! ./util.js */ \\\"./node_modules/bootstrap/js/dist/util.js\\\")) :\\n  undefined;\\n}(this, (function ($,Util) { 'use strict';\\n\\n  $ = $ && $.hasOwnProperty('default') ? $['default'] : $;\\n  Util = Util && Util.hasOwnProperty('default') ? Util['default'] : Util;\\n\\n  function _defineProperties(target, props) {\\n    for (var i = 0; i < props.length; i++) {\\n      var descriptor = props[i];\\n      descriptor.enumerable = descriptor.enumerable || false;\\n      descriptor.configurable = true;\\n      if (\\\"value\\\" in descriptor) descriptor.writable = true;\\n      Object.defineProperty(target, descriptor.key, descriptor);\\n    }\\n  }\\n\\n  function _createClass(Constructor, protoProps, staticProps) {\\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\\n    if (staticProps) _defineProperties(Constructor, staticProps);\\n    return Constructor;\\n  }\\n\\n  /**\\n   * --------------------------------------------------------------------------\\n   * Bootstrap (v4.1.3): tab.js\\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n   * --------------------------------------------------------------------------\\n   */\\n\\n  var Tab = function ($$$1) {\\n    /**\\n     * ------------------------------------------------------------------------\\n     * Constants\\n     * ------------------------------------------------------------------------\\n     */\\n    var NAME = 'tab';\\n    var VERSION = '4.1.3';\\n    var DATA_KEY = 'bs.tab';\\n    var EVENT_KEY = \\\".\\\" + DATA_KEY;\\n    var DATA_API_KEY = '.data-api';\\n    var JQUERY_NO_CONFLICT = $$$1.fn[NAME];\\n    var Event = {\\n      HIDE: \\\"hide\\\" + EVENT_KEY,\\n      HIDDEN: \\\"hidden\\\" + EVENT_KEY,\\n      SHOW: \\\"show\\\" + EVENT_KEY,\\n      SHOWN: \\\"shown\\\" + EVENT_KEY,\\n      CLICK_DATA_API: \\\"click\\\" + EVENT_KEY + DATA_API_KEY\\n    };\\n    var ClassName = {\\n      DROPDOWN_MENU: 'dropdown-menu',\\n      ACTIVE: 'active',\\n      DISABLED: 'disabled',\\n      FADE: 'fade',\\n      SHOW: 'show'\\n    };\\n    var Selector = {\\n      DROPDOWN: '.dropdown',\\n      NAV_LIST_GROUP: '.nav, .list-group',\\n      ACTIVE: '.active',\\n      ACTIVE_UL: '> li > .active',\\n      DATA_TOGGLE: '[data-toggle=\\\"tab\\\"], [data-toggle=\\\"pill\\\"], [data-toggle=\\\"list\\\"]',\\n      DROPDOWN_TOGGLE: '.dropdown-toggle',\\n      DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'\\n      /**\\n       * ------------------------------------------------------------------------\\n       * Class Definition\\n       * ------------------------------------------------------------------------\\n       */\\n\\n    };\\n\\n    var Tab =\\n    /*#__PURE__*/\\n    function () {\\n      function Tab(element) {\\n        this._element = element;\\n      } // Getters\\n\\n\\n      var _proto = Tab.prototype;\\n\\n      // Public\\n      _proto.show = function show() {\\n        var _this = this;\\n\\n        if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $$$1(this._element).hasClass(ClassName.ACTIVE) || $$$1(this._element).hasClass(ClassName.DISABLED)) {\\n          return;\\n        }\\n\\n        var target;\\n        var previous;\\n        var listElement = $$$1(this._element).closest(Selector.NAV_LIST_GROUP)[0];\\n        var selector = Util.getSelectorFromElement(this._element);\\n\\n        if (listElement) {\\n          var itemSelector = listElement.nodeName === 'UL' ? Selector.ACTIVE_UL : Selector.ACTIVE;\\n          previous = $$$1.makeArray($$$1(listElement).find(itemSelector));\\n          previous = previous[previous.length - 1];\\n        }\\n\\n        var hideEvent = $$$1.Event(Event.HIDE, {\\n          relatedTarget: this._element\\n        });\\n        var showEvent = $$$1.Event(Event.SHOW, {\\n          relatedTarget: previous\\n        });\\n\\n        if (previous) {\\n          $$$1(previous).trigger(hideEvent);\\n        }\\n\\n        $$$1(this._element).trigger(showEvent);\\n\\n        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {\\n          return;\\n        }\\n\\n        if (selector) {\\n          target = document.querySelector(selector);\\n        }\\n\\n        this._activate(this._element, listElement);\\n\\n        var complete = function complete() {\\n          var hiddenEvent = $$$1.Event(Event.HIDDEN, {\\n            relatedTarget: _this._element\\n          });\\n          var shownEvent = $$$1.Event(Event.SHOWN, {\\n            relatedTarget: previous\\n          });\\n          $$$1(previous).trigger(hiddenEvent);\\n          $$$1(_this._element).trigger(shownEvent);\\n        };\\n\\n        if (target) {\\n          this._activate(target, target.parentNode, complete);\\n        } else {\\n          complete();\\n        }\\n      };\\n\\n      _proto.dispose = function dispose() {\\n        $$$1.removeData(this._element, DATA_KEY);\\n        this._element = null;\\n      }; // Private\\n\\n\\n      _proto._activate = function _activate(element, container, callback) {\\n        var _this2 = this;\\n\\n        var activeElements;\\n\\n        if (container.nodeName === 'UL') {\\n          activeElements = $$$1(container).find(Selector.ACTIVE_UL);\\n        } else {\\n          activeElements = $$$1(container).children(Selector.ACTIVE);\\n        }\\n\\n        var active = activeElements[0];\\n        var isTransitioning = callback && active && $$$1(active).hasClass(ClassName.FADE);\\n\\n        var complete = function complete() {\\n          return _this2._transitionComplete(element, active, callback);\\n        };\\n\\n        if (active && isTransitioning) {\\n          var transitionDuration = Util.getTransitionDurationFromElement(active);\\n          $$$1(active).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\\n        } else {\\n          complete();\\n        }\\n      };\\n\\n      _proto._transitionComplete = function _transitionComplete(element, active, callback) {\\n        if (active) {\\n          $$$1(active).removeClass(ClassName.SHOW + \\\" \\\" + ClassName.ACTIVE);\\n          var dropdownChild = $$$1(active.parentNode).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];\\n\\n          if (dropdownChild) {\\n            $$$1(dropdownChild).removeClass(ClassName.ACTIVE);\\n          }\\n\\n          if (active.getAttribute('role') === 'tab') {\\n            active.setAttribute('aria-selected', false);\\n          }\\n        }\\n\\n        $$$1(element).addClass(ClassName.ACTIVE);\\n\\n        if (element.getAttribute('role') === 'tab') {\\n          element.setAttribute('aria-selected', true);\\n        }\\n\\n        Util.reflow(element);\\n        $$$1(element).addClass(ClassName.SHOW);\\n\\n        if (element.parentNode && $$$1(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {\\n          var dropdownElement = $$$1(element).closest(Selector.DROPDOWN)[0];\\n\\n          if (dropdownElement) {\\n            var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(Selector.DROPDOWN_TOGGLE));\\n            $$$1(dropdownToggleList).addClass(ClassName.ACTIVE);\\n          }\\n\\n          element.setAttribute('aria-expanded', true);\\n        }\\n\\n        if (callback) {\\n          callback();\\n        }\\n      }; // Static\\n\\n\\n      Tab._jQueryInterface = function _jQueryInterface(config) {\\n        return this.each(function () {\\n          var $this = $$$1(this);\\n          var data = $this.data(DATA_KEY);\\n\\n          if (!data) {\\n            data = new Tab(this);\\n            $this.data(DATA_KEY, data);\\n          }\\n\\n          if (typeof config === 'string') {\\n            if (typeof data[config] === 'undefined') {\\n              throw new TypeError(\\\"No method named \\\\\\\"\\\" + config + \\\"\\\\\\\"\\\");\\n            }\\n\\n            data[config]();\\n          }\\n        });\\n      };\\n\\n      _createClass(Tab, null, [{\\n        key: \\\"VERSION\\\",\\n        get: function get() {\\n          return VERSION;\\n        }\\n      }]);\\n\\n      return Tab;\\n    }();\\n    /**\\n     * ------------------------------------------------------------------------\\n     * Data Api implementation\\n     * ------------------------------------------------------------------------\\n     */\\n\\n\\n    $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {\\n      event.preventDefault();\\n\\n      Tab._jQueryInterface.call($$$1(this), 'show');\\n    });\\n    /**\\n     * ------------------------------------------------------------------------\\n     * jQuery\\n     * ------------------------------------------------------------------------\\n     */\\n\\n    $$$1.fn[NAME] = Tab._jQueryInterface;\\n    $$$1.fn[NAME].Constructor = Tab;\\n\\n    $$$1.fn[NAME].noConflict = function () {\\n      $$$1.fn[NAME] = JQUERY_NO_CONFLICT;\\n      return Tab._jQueryInterface;\\n    };\\n\\n    return Tab;\\n  }($);\\n\\n  return Tab;\\n\\n})));\\n//# sourceMappingURL=tab.js.map\\n\\n\\n//# sourceURL=webpack:///./node_modules/bootstrap/js/dist/tab.js?\")},\"./node_modules/bootstrap/js/dist/util.js\":function(module,exports,__webpack_require__){eval(\"(function (global, factory) {\\n   true ? module.exports = factory(__webpack_require__(/*! jquery */ \\\"./node_modules/jquery/dist/jquery.js\\\")) :\\n  undefined;\\n}(this, (function ($) { 'use strict';\\n\\n  $ = $ && $.hasOwnProperty('default') ? $['default'] : $;\\n\\n  /**\\n   * --------------------------------------------------------------------------\\n   * Bootstrap (v4.1.3): util.js\\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n   * --------------------------------------------------------------------------\\n   */\\n\\n  var Util = function ($$$1) {\\n    /**\\n     * ------------------------------------------------------------------------\\n     * Private TransitionEnd Helpers\\n     * ------------------------------------------------------------------------\\n     */\\n    var TRANSITION_END = 'transitionend';\\n    var MAX_UID = 1000000;\\n    var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)\\n\\n    function toType(obj) {\\n      return {}.toString.call(obj).match(/\\\\s([a-z]+)/i)[1].toLowerCase();\\n    }\\n\\n    function getSpecialTransitionEndEvent() {\\n      return {\\n        bindType: TRANSITION_END,\\n        delegateType: TRANSITION_END,\\n        handle: function handle(event) {\\n          if ($$$1(event.target).is(this)) {\\n            return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params\\n          }\\n\\n          return undefined; // eslint-disable-line no-undefined\\n        }\\n      };\\n    }\\n\\n    function transitionEndEmulator(duration) {\\n      var _this = this;\\n\\n      var called = false;\\n      $$$1(this).one(Util.TRANSITION_END, function () {\\n        called = true;\\n      });\\n      setTimeout(function () {\\n        if (!called) {\\n          Util.triggerTransitionEnd(_this);\\n        }\\n      }, duration);\\n      return this;\\n    }\\n\\n    function setTransitionEndSupport() {\\n      $$$1.fn.emulateTransitionEnd = transitionEndEmulator;\\n      $$$1.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();\\n    }\\n    /**\\n     * --------------------------------------------------------------------------\\n     * Public Util Api\\n     * --------------------------------------------------------------------------\\n     */\\n\\n\\n    var Util = {\\n      TRANSITION_END: 'bsTransitionEnd',\\n      getUID: function getUID(prefix) {\\n        do {\\n          // eslint-disable-next-line no-bitwise\\n          prefix += ~~(Math.random() * MAX_UID); // \\\"~~\\\" acts like a faster Math.floor() here\\n        } while (document.getElementById(prefix));\\n\\n        return prefix;\\n      },\\n      getSelectorFromElement: function getSelectorFromElement(element) {\\n        var selector = element.getAttribute('data-target');\\n\\n        if (!selector || selector === '#') {\\n          selector = element.getAttribute('href') || '';\\n        }\\n\\n        try {\\n          return document.querySelector(selector) ? selector : null;\\n        } catch (err) {\\n          return null;\\n        }\\n      },\\n      getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {\\n        if (!element) {\\n          return 0;\\n        } // Get transition-duration of the element\\n\\n\\n        var transitionDuration = $$$1(element).css('transition-duration');\\n        var floatTransitionDuration = parseFloat(transitionDuration); // Return 0 if element or transition duration is not found\\n\\n        if (!floatTransitionDuration) {\\n          return 0;\\n        } // If multiple durations are defined, take the first\\n\\n\\n        transitionDuration = transitionDuration.split(',')[0];\\n        return parseFloat(transitionDuration) * MILLISECONDS_MULTIPLIER;\\n      },\\n      reflow: function reflow(element) {\\n        return element.offsetHeight;\\n      },\\n      triggerTransitionEnd: function triggerTransitionEnd(element) {\\n        $$$1(element).trigger(TRANSITION_END);\\n      },\\n      // TODO: Remove in v5\\n      supportsTransitionEnd: function supportsTransitionEnd() {\\n        return Boolean(TRANSITION_END);\\n      },\\n      isElement: function isElement(obj) {\\n        return (obj[0] || obj).nodeType;\\n      },\\n      typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {\\n        for (var property in configTypes) {\\n          if (Object.prototype.hasOwnProperty.call(configTypes, property)) {\\n            var expectedTypes = configTypes[property];\\n            var value = config[property];\\n            var valueType = value && Util.isElement(value) ? 'element' : toType(value);\\n\\n            if (!new RegExp(expectedTypes).test(valueType)) {\\n              throw new Error(componentName.toUpperCase() + \\\": \\\" + (\\\"Option \\\\\\\"\\\" + property + \\\"\\\\\\\" provided type \\\\\\\"\\\" + valueType + \\\"\\\\\\\" \\\") + (\\\"but expected type \\\\\\\"\\\" + expectedTypes + \\\"\\\\\\\".\\\"));\\n            }\\n          }\\n        }\\n      }\\n    };\\n    setTransitionEndSupport();\\n    return Util;\\n  }($);\\n\\n  return Util;\\n\\n})));\\n//# sourceMappingURL=util.js.map\\n\\n\\n//# sourceURL=webpack:///./node_modules/bootstrap/js/dist/util.js?\")},\"./node_modules/inputmask/dist/inputmask/dependencyLibs/inputmask.dependencyLib.js\":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\\n* dependencyLibs/inputmask.dependencyLib.js\\n* https://github.com/RobinHerbots/Inputmask\\n* Copyright (c) 2010 - 2018 Robin Herbots\\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\\n* Version: 4.0.4\\n*/\\n\\n(function(factory) {\\n    if (true) {\\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! ../global/window */ \"./node_modules/inputmask/dist/inputmask/global/window.js\") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \\'function\\' ?\\n\\t\\t\\t\\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n    } else {}\\n})(function(window) {\\n    var document = window.document;\\n    function indexOf(list, elem) {\\n        var i = 0, len = list.length;\\n        for (;i < len; i++) {\\n            if (list[i] === elem) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    function isWindow(obj) {\\n        return obj != null && obj === obj.window;\\n    }\\n    function isArraylike(obj) {\\n        var length = \"length\" in obj && obj.length, ltype = typeof obj;\\n        if (ltype === \"function\" || isWindow(obj)) {\\n            return false;\\n        }\\n        if (obj.nodeType === 1 && length) {\\n            return true;\\n        }\\n        return ltype === \"array\" || length === 0 || typeof length === \"number\" && length > 0 && length - 1 in obj;\\n    }\\n    function isValidElement(elem) {\\n        return elem instanceof Element;\\n    }\\n    function DependencyLib(elem) {\\n        if (elem instanceof DependencyLib) {\\n            return elem;\\n        }\\n        if (!(this instanceof DependencyLib)) {\\n            return new DependencyLib(elem);\\n        }\\n        if (elem !== undefined && elem !== null && elem !== window) {\\n            this[0] = elem.nodeName ? elem : elem[0] !== undefined && elem[0].nodeName ? elem[0] : document.querySelector(elem);\\n            if (this[0] !== undefined && this[0] !== null) {\\n                this[0].eventRegistry = this[0].eventRegistry || {};\\n            }\\n        }\\n    }\\n    function getWindow(elem) {\\n        return isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;\\n    }\\n    DependencyLib.prototype = {\\n        on: function(events, handler) {\\n            if (isValidElement(this[0])) {\\n                var eventRegistry = this[0].eventRegistry, elem = this[0];\\n                function addEvent(ev, namespace) {\\n                    if (elem.addEventListener) {\\n                        elem.addEventListener(ev, handler, false);\\n                    } else if (elem.attachEvent) {\\n                        elem.attachEvent(\"on\" + ev, handler);\\n                    }\\n                    eventRegistry[ev] = eventRegistry[ev] || {};\\n                    eventRegistry[ev][namespace] = eventRegistry[ev][namespace] || [];\\n                    eventRegistry[ev][namespace].push(handler);\\n                }\\n                var _events = events.split(\" \");\\n                for (var endx = 0; endx < _events.length; endx++) {\\n                    var nsEvent = _events[endx].split(\".\"), ev = nsEvent[0], namespace = nsEvent[1] || \"global\";\\n                    addEvent(ev, namespace);\\n                }\\n            }\\n            return this;\\n        },\\n        off: function(events, handler) {\\n            if (isValidElement(this[0])) {\\n                var eventRegistry = this[0].eventRegistry, elem = this[0];\\n                function removeEvent(ev, namespace, handler) {\\n                    if (ev in eventRegistry === true) {\\n                        if (elem.removeEventListener) {\\n                            elem.removeEventListener(ev, handler, false);\\n                        } else if (elem.detachEvent) {\\n                            elem.detachEvent(\"on\" + ev, handler);\\n                        }\\n                        if (namespace === \"global\") {\\n                            for (var nmsp in eventRegistry[ev]) {\\n                                eventRegistry[ev][nmsp].splice(eventRegistry[ev][nmsp].indexOf(handler), 1);\\n                            }\\n                        } else {\\n                            eventRegistry[ev][namespace].splice(eventRegistry[ev][namespace].indexOf(handler), 1);\\n                        }\\n                    }\\n                }\\n                function resolveNamespace(ev, namespace) {\\n                    var evts = [], hndx, hndL;\\n                    if (ev.length > 0) {\\n                        if (handler === undefined) {\\n                            for (hndx = 0, hndL = eventRegistry[ev][namespace].length; hndx < hndL; hndx++) {\\n                                evts.push({\\n                                    ev: ev,\\n                                    namespace: namespace && namespace.length > 0 ? namespace : \"global\",\\n                                    handler: eventRegistry[ev][namespace][hndx]\\n                                });\\n                            }\\n                        } else {\\n                            evts.push({\\n                                ev: ev,\\n                                namespace: namespace && namespace.length > 0 ? namespace : \"global\",\\n                                handler: handler\\n                            });\\n                        }\\n                    } else if (namespace.length > 0) {\\n                        for (var evNdx in eventRegistry) {\\n                            for (var nmsp in eventRegistry[evNdx]) {\\n                                if (nmsp === namespace) {\\n                                    if (handler === undefined) {\\n                                        for (hndx = 0, hndL = eventRegistry[evNdx][nmsp].length; hndx < hndL; hndx++) {\\n                                            evts.push({\\n                                                ev: evNdx,\\n                                                namespace: nmsp,\\n                                                handler: eventRegistry[evNdx][nmsp][hndx]\\n                                            });\\n                                        }\\n                                    } else {\\n                                        evts.push({\\n                                            ev: evNdx,\\n                                            namespace: nmsp,\\n                                            handler: handler\\n                                        });\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                    return evts;\\n                }\\n                var _events = events.split(\" \");\\n                for (var endx = 0; endx < _events.length; endx++) {\\n                    var nsEvent = _events[endx].split(\".\"), offEvents = resolveNamespace(nsEvent[0], nsEvent[1]);\\n                    for (var i = 0, offEventsL = offEvents.length; i < offEventsL; i++) {\\n                        removeEvent(offEvents[i].ev, offEvents[i].namespace, offEvents[i].handler);\\n                    }\\n                }\\n            }\\n            return this;\\n        },\\n        trigger: function(events) {\\n            if (isValidElement(this[0])) {\\n                var eventRegistry = this[0].eventRegistry, elem = this[0];\\n                var _events = typeof events === \"string\" ? events.split(\" \") : [ events.type ];\\n                for (var endx = 0; endx < _events.length; endx++) {\\n                    var nsEvent = _events[endx].split(\".\"), ev = nsEvent[0], namespace = nsEvent[1] || \"global\";\\n                    if (document !== undefined && namespace === \"global\") {\\n                        var evnt, i, params = {\\n                            bubbles: true,\\n                            cancelable: true,\\n                            detail: arguments[1]\\n                        };\\n                        if (document.createEvent) {\\n                            try {\\n                                evnt = new CustomEvent(ev, params);\\n                            } catch (e) {\\n                                evnt = document.createEvent(\"CustomEvent\");\\n                                evnt.initCustomEvent(ev, params.bubbles, params.cancelable, params.detail);\\n                            }\\n                            if (events.type) DependencyLib.extend(evnt, events);\\n                            elem.dispatchEvent(evnt);\\n                        } else {\\n                            evnt = document.createEventObject();\\n                            evnt.eventType = ev;\\n                            evnt.detail = arguments[1];\\n                            if (events.type) DependencyLib.extend(evnt, events);\\n                            elem.fireEvent(\"on\" + evnt.eventType, evnt);\\n                        }\\n                    } else if (eventRegistry[ev] !== undefined) {\\n                        arguments[0] = arguments[0].type ? arguments[0] : DependencyLib.Event(arguments[0]);\\n                        if (namespace === \"global\") {\\n                            for (var nmsp in eventRegistry[ev]) {\\n                                for (i = 0; i < eventRegistry[ev][nmsp].length; i++) {\\n                                    eventRegistry[ev][nmsp][i].apply(elem, arguments);\\n                                }\\n                            }\\n                        } else {\\n                            for (i = 0; i < eventRegistry[ev][namespace].length; i++) {\\n                                eventRegistry[ev][namespace][i].apply(elem, arguments);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            return this;\\n        }\\n    };\\n    DependencyLib.isFunction = function(obj) {\\n        return typeof obj === \"function\";\\n    };\\n    DependencyLib.noop = function() {};\\n    DependencyLib.isArray = Array.isArray;\\n    DependencyLib.inArray = function(elem, arr, i) {\\n        return arr == null ? -1 : indexOf(arr, elem, i);\\n    };\\n    DependencyLib.valHooks = undefined;\\n    DependencyLib.isPlainObject = function(obj) {\\n        if (typeof obj !== \"object\" || obj.nodeType || isWindow(obj)) {\\n            return false;\\n        }\\n        if (obj.constructor && !Object.hasOwnProperty.call(obj.constructor.prototype, \"isPrototypeOf\")) {\\n            return false;\\n        }\\n        return true;\\n    };\\n    DependencyLib.extend = function() {\\n        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;\\n        if (typeof target === \"boolean\") {\\n            deep = target;\\n            target = arguments[i] || {};\\n            i++;\\n        }\\n        if (typeof target !== \"object\" && !DependencyLib.isFunction(target)) {\\n            target = {};\\n        }\\n        if (i === length) {\\n            target = this;\\n            i--;\\n        }\\n        for (;i < length; i++) {\\n            if ((options = arguments[i]) != null) {\\n                for (name in options) {\\n                    src = target[name];\\n                    copy = options[name];\\n                    if (target === copy) {\\n                        continue;\\n                    }\\n                    if (deep && copy && (DependencyLib.isPlainObject(copy) || (copyIsArray = DependencyLib.isArray(copy)))) {\\n                        if (copyIsArray) {\\n                            copyIsArray = false;\\n                            clone = src && DependencyLib.isArray(src) ? src : [];\\n                        } else {\\n                            clone = src && DependencyLib.isPlainObject(src) ? src : {};\\n                        }\\n                        target[name] = DependencyLib.extend(deep, clone, copy);\\n                    } else if (copy !== undefined) {\\n                        target[name] = copy;\\n                    }\\n                }\\n            }\\n        }\\n        return target;\\n    };\\n    DependencyLib.each = function(obj, callback) {\\n        var value, i = 0;\\n        if (isArraylike(obj)) {\\n            for (var length = obj.length; i < length; i++) {\\n                value = callback.call(obj[i], i, obj[i]);\\n                if (value === false) {\\n                    break;\\n                }\\n            }\\n        } else {\\n            for (i in obj) {\\n                value = callback.call(obj[i], i, obj[i]);\\n                if (value === false) {\\n                    break;\\n                }\\n            }\\n        }\\n        return obj;\\n    };\\n    DependencyLib.data = function(owner, key, value) {\\n        if (value === undefined) {\\n            return owner.__data ? owner.__data[key] : null;\\n        } else {\\n            owner.__data = owner.__data || {};\\n            owner.__data[key] = value;\\n        }\\n    };\\n    if (typeof window.CustomEvent === \"function\") {\\n        DependencyLib.Event = window.CustomEvent;\\n    } else {\\n        DependencyLib.Event = function(event, params) {\\n            params = params || {\\n                bubbles: false,\\n                cancelable: false,\\n                detail: undefined\\n            };\\n            var evt = document.createEvent(\"CustomEvent\");\\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\\n            return evt;\\n        };\\n        DependencyLib.Event.prototype = window.Event.prototype;\\n    }\\n    return DependencyLib;\\n});\\n\\n//# sourceURL=webpack:///./node_modules/inputmask/dist/inputmask/dependencyLibs/inputmask.dependencyLib.js?')},\"./node_modules/inputmask/dist/inputmask/global/window.js\":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_RESULT__;/*!\\n* global/window.js\\n* https://github.com/RobinHerbots/Inputmask\\n* Copyright (c) 2010 - 2018 Robin Herbots\\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\\n* Version: 4.0.4\\n*/\\n\\nif (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\\n    return typeof window !== \"undefined\" ? window : new (eval(\"require(\\'jsdom\\').JSDOM\"))(\"\").window;\\n}).call(exports, __webpack_require__, exports, module),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else {}\\n\\n//# sourceURL=webpack:///./node_modules/inputmask/dist/inputmask/global/window.js?')},\"./node_modules/inputmask/dist/inputmask/inputmask.date.extensions.js\":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\\n* inputmask.date.extensions.js\\n* https://github.com/RobinHerbots/Inputmask\\n* Copyright (c) 2010 - 2018 Robin Herbots\\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\\n* Version: 4.0.4\\n*/\\n\\n(function(factory) {\\n    if (true) {\\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! ./inputmask */ \"./node_modules/inputmask/dist/inputmask/inputmask.js\") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \\'function\\' ?\\n\\t\\t\\t\\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n    } else {}\\n})(function(Inputmask) {\\n    var $ = Inputmask.dependencyLib;\\n    var formatCode = {\\n        d: [ \"[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", Date.prototype.getDate ],\\n        dd: [ \"0[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", function() {\\n            return pad(Date.prototype.getDate.call(this), 2);\\n        } ],\\n        ddd: [ \"\" ],\\n        dddd: [ \"\" ],\\n        m: [ \"[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function() {\\n            return Date.prototype.getMonth.call(this) + 1;\\n        } ],\\n        mm: [ \"0[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function() {\\n            return pad(Date.prototype.getMonth.call(this) + 1, 2);\\n        } ],\\n        mmm: [ \"\" ],\\n        mmmm: [ \"\" ],\\n        yy: [ \"[0-9]{2}\", Date.prototype.setFullYear, \"year\", function() {\\n            return pad(Date.prototype.getFullYear.call(this), 2);\\n        } ],\\n        yyyy: [ \"[0-9]{4}\", Date.prototype.setFullYear, \"year\", function() {\\n            return pad(Date.prototype.getFullYear.call(this), 4);\\n        } ],\\n        h: [ \"[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours ],\\n        hh: [ \"0[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", function() {\\n            return pad(Date.prototype.getHours.call(this), 2);\\n        } ],\\n        hhh: [ \"[0-9]+\", Date.prototype.setHours, \"hours\", Date.prototype.getHours ],\\n        H: [ \"1?[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours ],\\n        HH: [ \"[01][0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", function() {\\n            return pad(Date.prototype.getHours.call(this), 2);\\n        } ],\\n        HHH: [ \"[0-9]+\", Date.prototype.setHours, \"hours\", Date.prototype.getHours ],\\n        M: [ \"[1-5]?[0-9]\", Date.prototype.setMinutes, \"minutes\", Date.prototype.getMinutes ],\\n        MM: [ \"[0-5][0-9]\", Date.prototype.setMinutes, \"minutes\", function() {\\n            return pad(Date.prototype.getMinutes.call(this), 2);\\n        } ],\\n        s: [ \"[1-5]?[0-9]\", Date.prototype.setSeconds, \"seconds\", Date.prototype.getSeconds ],\\n        ss: [ \"[0-5][0-9]\", Date.prototype.setSeconds, \"seconds\", function() {\\n            return pad(Date.prototype.getSeconds.call(this), 2);\\n        } ],\\n        l: [ \"[0-9]{3}\", Date.prototype.setMilliseconds, \"milliseconds\", function() {\\n            return pad(Date.prototype.getMilliseconds.call(this), 3);\\n        } ],\\n        L: [ \"[0-9]{2}\", Date.prototype.setMilliseconds, \"milliseconds\", function() {\\n            return pad(Date.prototype.getMilliseconds.call(this), 2);\\n        } ],\\n        t: [ \"[ap]\" ],\\n        tt: [ \"[ap]m\" ],\\n        T: [ \"[AP]\" ],\\n        TT: [ \"[AP]M\" ],\\n        Z: [ \"\" ],\\n        o: [ \"\" ],\\n        S: [ \"\" ]\\n    }, formatAlias = {\\n        isoDate: \"yyyy-mm-dd\",\\n        isoTime: \"HH:MM:ss\",\\n        isoDateTime: \"yyyy-mm-dd\\'T\\'HH:MM:ss\",\\n        isoUtcDateTime: \"UTC:yyyy-mm-dd\\'T\\'HH:MM:ss\\'Z\\'\"\\n    };\\n    function getTokenizer(opts) {\\n        if (!opts.tokenizer) {\\n            var tokens = [];\\n            for (var ndx in formatCode) {\\n                if (tokens.indexOf(ndx[0]) === -1) tokens.push(ndx[0]);\\n            }\\n            opts.tokenizer = \"(\" + tokens.join(\"+|\") + \")+?|.\";\\n            opts.tokenizer = new RegExp(opts.tokenizer, \"g\");\\n        }\\n        return opts.tokenizer;\\n    }\\n    function isValidDate(dateParts, currentResult) {\\n        return !isFinite(dateParts.rawday) || dateParts.day == \"29\" && !isFinite(dateParts.rawyear) || new Date(dateParts.date.getFullYear(), isFinite(dateParts.rawmonth) ? dateParts.month : dateParts.date.getMonth() + 1, 0).getDate() >= dateParts.day ? currentResult : false;\\n    }\\n    function isDateInRange(dateParts, opts) {\\n        var result = true;\\n        if (opts.min) {\\n            if (dateParts[\"rawyear\"]) {\\n                var rawYear = dateParts[\"rawyear\"].replace(/[^0-9]/g, \"\"), minYear = opts.min.year.substr(0, rawYear.length);\\n                result = minYear <= rawYear;\\n            }\\n            if (dateParts[\"year\"] === dateParts[\"rawyear\"]) {\\n                if (opts.min.date.getTime() === opts.min.date.getTime()) {\\n                    result = opts.min.date.getTime() <= dateParts.date.getTime();\\n                }\\n            }\\n        }\\n        if (result && opts.max && opts.max.date.getTime() === opts.max.date.getTime()) {\\n            result = opts.max.date.getTime() >= dateParts.date.getTime();\\n        }\\n        return result;\\n    }\\n    function parse(format, dateObjValue, opts, raw) {\\n        var mask = \"\", match;\\n        while (match = getTokenizer(opts).exec(format)) {\\n            if (dateObjValue === undefined) {\\n                if (formatCode[match[0]]) {\\n                    mask += \"(\" + formatCode[match[0]][0] + \")\";\\n                } else {\\n                    switch (match[0]) {\\n                      case \"[\":\\n                        mask += \"(\";\\n                        break;\\n\\n                      case \"]\":\\n                        mask += \")?\";\\n                        break;\\n\\n                      default:\\n                        mask += Inputmask.escapeRegex(match[0]);\\n                    }\\n                }\\n            } else {\\n                if (formatCode[match[0]]) {\\n                    if (raw !== true && formatCode[match[0]][3]) {\\n                        var getFn = formatCode[match[0]][3];\\n                        mask += getFn.call(dateObjValue.date);\\n                    } else if (formatCode[match[0]][2]) mask += dateObjValue[\"raw\" + formatCode[match[0]][2]]; else mask += match[0];\\n                } else mask += match[0];\\n            }\\n        }\\n        return mask;\\n    }\\n    function pad(val, len) {\\n        val = String(val);\\n        len = len || 2;\\n        while (val.length < len) val = \"0\" + val;\\n        return val;\\n    }\\n    function analyseMask(maskString, format, opts) {\\n        var dateObj = {\\n            date: new Date(1, 0, 1)\\n        }, targetProp, mask = maskString, match, dateOperation, targetValidator;\\n        function extendProperty(value) {\\n            var correctedValue = value.replace(/[^0-9]/g, \"0\");\\n            if (correctedValue != value) {\\n                var enteredPart = value.replace(/[^0-9]/g, \"\"), min = (opts.min && opts.min[targetProp] || value).toString(), max = (opts.max && opts.max[targetProp] || value).toString();\\n                correctedValue = enteredPart + (enteredPart < min.slice(0, enteredPart.length) ? min.slice(enteredPart.length) : enteredPart > max.slice(0, enteredPart.length) ? max.slice(enteredPart.length) : correctedValue.toString().slice(enteredPart.length));\\n            }\\n            return correctedValue;\\n        }\\n        function setValue(dateObj, value, opts) {\\n            dateObj[targetProp] = extendProperty(value);\\n            dateObj[\"raw\" + targetProp] = value;\\n            if (dateOperation !== undefined) dateOperation.call(dateObj.date, targetProp == \"month\" ? parseInt(dateObj[targetProp]) - 1 : dateObj[targetProp]);\\n        }\\n        if (typeof mask === \"string\") {\\n            while (match = getTokenizer(opts).exec(format)) {\\n                var value = mask.slice(0, match[0].length);\\n                if (formatCode.hasOwnProperty(match[0])) {\\n                    targetValidator = formatCode[match[0]][0];\\n                    targetProp = formatCode[match[0]][2];\\n                    dateOperation = formatCode[match[0]][1];\\n                    setValue(dateObj, value, opts);\\n                }\\n                mask = mask.slice(value.length);\\n            }\\n            return dateObj;\\n        } else if (mask && typeof mask === \"object\" && mask.hasOwnProperty(\"date\")) {\\n            return mask;\\n        }\\n        return undefined;\\n    }\\n    Inputmask.extendAliases({\\n        datetime: {\\n            mask: function(opts) {\\n                formatCode.S = opts.i18n.ordinalSuffix.join(\"|\");\\n                opts.inputFormat = formatAlias[opts.inputFormat] || opts.inputFormat;\\n                opts.displayFormat = formatAlias[opts.displayFormat] || opts.displayFormat || opts.inputFormat;\\n                opts.outputFormat = formatAlias[opts.outputFormat] || opts.outputFormat || opts.inputFormat;\\n                opts.placeholder = opts.placeholder !== \"\" ? opts.placeholder : opts.inputFormat.replace(/[\\\\[\\\\]]/, \"\");\\n                opts.regex = parse(opts.inputFormat, undefined, opts);\\n                return null;\\n            },\\n            placeholder: \"\",\\n            inputFormat: \"isoDateTime\",\\n            displayFormat: undefined,\\n            outputFormat: undefined,\\n            min: null,\\n            max: null,\\n            i18n: {\\n                dayNames: [ \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\" ],\\n                monthNames: [ \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" ],\\n                ordinalSuffix: [ \"st\", \"nd\", \"rd\", \"th\" ]\\n            },\\n            postValidation: function(buffer, pos, currentResult, opts) {\\n                opts.min = analyseMask(opts.min, opts.inputFormat, opts);\\n                opts.max = analyseMask(opts.max, opts.inputFormat, opts);\\n                var result = currentResult, dateParts = analyseMask(buffer.join(\"\"), opts.inputFormat, opts);\\n                if (result && dateParts.date.getTime() === dateParts.date.getTime()) {\\n                    result = isValidDate(dateParts, result);\\n                    result = result && isDateInRange(dateParts, opts);\\n                }\\n                if (pos && result && currentResult.pos !== pos) {\\n                    return {\\n                        buffer: parse(opts.inputFormat, dateParts, opts),\\n                        refreshFromBuffer: {\\n                            start: pos,\\n                            end: currentResult.pos\\n                        }\\n                    };\\n                }\\n                return result;\\n            },\\n            onKeyDown: function(e, buffer, caretPos, opts) {\\n                var input = this;\\n                if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {\\n                    var today = new Date(), match, date = \"\";\\n                    while (match = getTokenizer(opts).exec(opts.inputFormat)) {\\n                        if (match[0].charAt(0) === \"d\") {\\n                            date += pad(today.getDate(), match[0].length);\\n                        } else if (match[0].charAt(0) === \"m\") {\\n                            date += pad(today.getMonth() + 1, match[0].length);\\n                        } else if (match[0] === \"yyyy\") {\\n                            date += today.getFullYear().toString();\\n                        } else if (match[0].charAt(0) === \"y\") {\\n                            date += pad(today.getYear(), match[0].length);\\n                        }\\n                    }\\n                    input.inputmask._valueSet(date);\\n                    $(input).trigger(\"setvalue\");\\n                }\\n            },\\n            onUnMask: function(maskedValue, unmaskedValue, opts) {\\n                return parse(opts.outputFormat, analyseMask(maskedValue, opts.inputFormat, opts), opts, true);\\n            },\\n            casing: function(elem, test, pos, validPositions) {\\n                if (test.nativeDef.indexOf(\"[ap]\") == 0) return elem.toLowerCase();\\n                if (test.nativeDef.indexOf(\"[AP]\") == 0) return elem.toUpperCase();\\n                return elem;\\n            },\\n            insertMode: false,\\n            shiftPositions: false\\n        }\\n    });\\n    return Inputmask;\\n});\\n\\n//# sourceURL=webpack:///./node_modules/inputmask/dist/inputmask/inputmask.date.extensions.js?')},\"./node_modules/inputmask/dist/inputmask/inputmask.extensions.js\":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\\n* inputmask.extensions.js\\n* https://github.com/RobinHerbots/Inputmask\\n* Copyright (c) 2010 - 2018 Robin Herbots\\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\\n* Version: 4.0.4\\n*/\\n\\n(function(factory) {\\n    if (true) {\\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! ./inputmask */ \"./node_modules/inputmask/dist/inputmask/inputmask.js\") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \\'function\\' ?\\n\\t\\t\\t\\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n    } else {}\\n})(function(Inputmask) {\\n    Inputmask.extendDefinitions({\\n        A: {\\n            validator: \"[A-Za-z\\\\u0410-\\\\u044f\\\\u0401\\\\u0451\\\\xc0-\\\\xff\\\\xb5]\",\\n            casing: \"upper\"\\n        },\\n        \"&\": {\\n            validator: \"[0-9A-Za-z\\\\u0410-\\\\u044f\\\\u0401\\\\u0451\\\\xc0-\\\\xff\\\\xb5]\",\\n            casing: \"upper\"\\n        },\\n        \"#\": {\\n            validator: \"[0-9A-Fa-f]\",\\n            casing: \"upper\"\\n        }\\n    });\\n    Inputmask.extendAliases({\\n        cssunit: {\\n            regex: \"[+-]?[0-9]+\\\\\\\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)\"\\n        },\\n        url: {\\n            regex: \"(https?|ftp)//.*\",\\n            autoUnmask: false\\n        },\\n        ip: {\\n            mask: \"i[i[i]].i[i[i]].i[i[i]].i[i[i]]\",\\n            definitions: {\\n                i: {\\n                    validator: function(chrs, maskset, pos, strict, opts) {\\n                        if (pos - 1 > -1 && maskset.buffer[pos - 1] !== \".\") {\\n                            chrs = maskset.buffer[pos - 1] + chrs;\\n                            if (pos - 2 > -1 && maskset.buffer[pos - 2] !== \".\") {\\n                                chrs = maskset.buffer[pos - 2] + chrs;\\n                            } else chrs = \"0\" + chrs;\\n                        } else chrs = \"00\" + chrs;\\n                        return new RegExp(\"25[0-5]|2[0-4][0-9]|[01][0-9][0-9]\").test(chrs);\\n                    }\\n                }\\n            },\\n            onUnMask: function(maskedValue, unmaskedValue, opts) {\\n                return maskedValue;\\n            },\\n            inputmode: \"numeric\"\\n        },\\n        email: {\\n            mask: \"*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]\",\\n            greedy: false,\\n            casing: \"lower\",\\n            onBeforePaste: function(pastedValue, opts) {\\n                pastedValue = pastedValue.toLowerCase();\\n                return pastedValue.replace(\"mailto:\", \"\");\\n            },\\n            definitions: {\\n                \"*\": {\\n                    validator: \"[0-9\\\\uff11-\\\\uff19A-Za-z\\\\u0410-\\\\u044f\\\\u0401\\\\u0451\\\\xc0-\\\\xff\\\\xb5!#$%&\\'*+/=?^_`{|}~-]\"\\n                },\\n                \"-\": {\\n                    validator: \"[0-9A-Za-z-]\"\\n                }\\n            },\\n            onUnMask: function(maskedValue, unmaskedValue, opts) {\\n                return maskedValue;\\n            },\\n            inputmode: \"email\"\\n        },\\n        mac: {\\n            mask: \"##:##:##:##:##:##\"\\n        },\\n        vin: {\\n            mask: \"V{13}9{4}\",\\n            definitions: {\\n                V: {\\n                    validator: \"[A-HJ-NPR-Za-hj-npr-z\\\\\\\\d]\",\\n                    casing: \"upper\"\\n                }\\n            },\\n            clearIncomplete: true,\\n            autoUnmask: true\\n        }\\n    });\\n    return Inputmask;\\n});\\n\\n//# sourceURL=webpack:///./node_modules/inputmask/dist/inputmask/inputmask.extensions.js?')},\"./node_modules/inputmask/dist/inputmask/inputmask.js\":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\\n* inputmask.js\\n* https://github.com/RobinHerbots/Inputmask\\n* Copyright (c) 2010 - 2018 Robin Herbots\\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\\n* Version: 4.0.4\\n*/\\n\\n(function(factory) {\\n    if (true) {\\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! ./dependencyLibs/inputmask.dependencyLib */ \"./node_modules/inputmask/dist/inputmask/dependencyLibs/inputmask.dependencyLib.js\"), __webpack_require__(/*! ./global/window */ \"./node_modules/inputmask/dist/inputmask/global/window.js\") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \\'function\\' ?\\n\\t\\t\\t\\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n    } else {}\\n})(function($, window, undefined) {\\n    var document = window.document, ua = navigator.userAgent, ie = ua.indexOf(\"MSIE \") > 0 || ua.indexOf(\"Trident/\") > 0, mobile = isInputEventSupported(\"touchstart\"), iemobile = /iemobile/i.test(ua), iphone = /iphone/i.test(ua) && !iemobile;\\n    function Inputmask(alias, options, internal) {\\n        if (!(this instanceof Inputmask)) {\\n            return new Inputmask(alias, options, internal);\\n        }\\n        this.el = undefined;\\n        this.events = {};\\n        this.maskset = undefined;\\n        this.refreshValue = false;\\n        if (internal !== true) {\\n            if ($.isPlainObject(alias)) {\\n                options = alias;\\n            } else {\\n                options = options || {};\\n                if (alias) options.alias = alias;\\n            }\\n            this.opts = $.extend(true, {}, this.defaults, options);\\n            this.noMasksCache = options && options.definitions !== undefined;\\n            this.userOptions = options || {};\\n            this.isRTL = this.opts.numericInput;\\n            resolveAlias(this.opts.alias, options, this.opts);\\n        }\\n    }\\n    Inputmask.prototype = {\\n        dataAttribute: \"data-inputmask\",\\n        defaults: {\\n            placeholder: \"_\",\\n            optionalmarker: [ \"[\", \"]\" ],\\n            quantifiermarker: [ \"{\", \"}\" ],\\n            groupmarker: [ \"(\", \")\" ],\\n            alternatormarker: \"|\",\\n            escapeChar: \"\\\\\\\\\",\\n            mask: null,\\n            regex: null,\\n            oncomplete: $.noop,\\n            onincomplete: $.noop,\\n            oncleared: $.noop,\\n            repeat: 0,\\n            greedy: false,\\n            autoUnmask: false,\\n            removeMaskOnSubmit: false,\\n            clearMaskOnLostFocus: true,\\n            insertMode: true,\\n            clearIncomplete: false,\\n            alias: null,\\n            onKeyDown: $.noop,\\n            onBeforeMask: null,\\n            onBeforePaste: function(pastedValue, opts) {\\n                return $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(this, pastedValue, opts) : pastedValue;\\n            },\\n            onBeforeWrite: null,\\n            onUnMask: null,\\n            showMaskOnFocus: true,\\n            showMaskOnHover: true,\\n            onKeyValidation: $.noop,\\n            skipOptionalPartCharacter: \" \",\\n            numericInput: false,\\n            rightAlign: false,\\n            undoOnEscape: true,\\n            radixPoint: \"\",\\n            _radixDance: false,\\n            groupSeparator: \"\",\\n            keepStatic: null,\\n            positionCaretOnTab: true,\\n            tabThrough: false,\\n            supportsInputType: [ \"text\", \"tel\", \"url\", \"password\", \"search\" ],\\n            ignorables: [ 8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229 ],\\n            isComplete: null,\\n            preValidation: null,\\n            postValidation: null,\\n            staticDefinitionSymbol: undefined,\\n            jitMasking: false,\\n            nullable: true,\\n            inputEventOnly: false,\\n            noValuePatching: false,\\n            positionCaretOnClick: \"lvp\",\\n            casing: null,\\n            inputmode: \"verbatim\",\\n            colorMask: false,\\n            disablePredictiveText: false,\\n            importDataAttributes: true,\\n            shiftPositions: true\\n        },\\n        definitions: {\\n            9: {\\n                validator: \"[0-9\\\\uff11-\\\\uff19]\",\\n                definitionSymbol: \"*\"\\n            },\\n            a: {\\n                validator: \"[A-Za-z\\\\u0410-\\\\u044f\\\\u0401\\\\u0451\\\\xc0-\\\\xff\\\\xb5]\",\\n                definitionSymbol: \"*\"\\n            },\\n            \"*\": {\\n                validator: \"[0-9\\\\uff11-\\\\uff19A-Za-z\\\\u0410-\\\\u044f\\\\u0401\\\\u0451\\\\xc0-\\\\xff\\\\xb5]\"\\n            }\\n        },\\n        aliases: {},\\n        masksCache: {},\\n        mask: function(elems) {\\n            var that = this;\\n            function importAttributeOptions(npt, opts, userOptions, dataAttribute) {\\n                if (opts.importDataAttributes === true) {\\n                    var attrOptions = npt.getAttribute(dataAttribute), option, dataoptions, optionData, p;\\n                    function importOption(option, optionData) {\\n                        optionData = optionData !== undefined ? optionData : npt.getAttribute(dataAttribute + \"-\" + option);\\n                        if (optionData !== null) {\\n                            if (typeof optionData === \"string\") {\\n                                if (option.indexOf(\"on\") === 0) optionData = window[optionData]; else if (optionData === \"false\") optionData = false; else if (optionData === \"true\") optionData = true;\\n                            }\\n                            userOptions[option] = optionData;\\n                        }\\n                    }\\n                    if (attrOptions && attrOptions !== \"\") {\\n                        attrOptions = attrOptions.replace(/\\'/g, \\'\"\\');\\n                        dataoptions = JSON.parse(\"{\" + attrOptions + \"}\");\\n                    }\\n                    if (dataoptions) {\\n                        optionData = undefined;\\n                        for (p in dataoptions) {\\n                            if (p.toLowerCase() === \"alias\") {\\n                                optionData = dataoptions[p];\\n                                break;\\n                            }\\n                        }\\n                    }\\n                    importOption(\"alias\", optionData);\\n                    if (userOptions.alias) {\\n                        resolveAlias(userOptions.alias, userOptions, opts);\\n                    }\\n                    for (option in opts) {\\n                        if (dataoptions) {\\n                            optionData = undefined;\\n                            for (p in dataoptions) {\\n                                if (p.toLowerCase() === option.toLowerCase()) {\\n                                    optionData = dataoptions[p];\\n                                    break;\\n                                }\\n                            }\\n                        }\\n                        importOption(option, optionData);\\n                    }\\n                }\\n                $.extend(true, opts, userOptions);\\n                if (npt.dir === \"rtl\" || opts.rightAlign) {\\n                    npt.style.textAlign = \"right\";\\n                }\\n                if (npt.dir === \"rtl\" || opts.numericInput) {\\n                    npt.dir = \"ltr\";\\n                    npt.removeAttribute(\"dir\");\\n                    opts.isRTL = true;\\n                }\\n                return Object.keys(userOptions).length;\\n            }\\n            if (typeof elems === \"string\") {\\n                elems = document.getElementById(elems) || document.querySelectorAll(elems);\\n            }\\n            elems = elems.nodeName ? [ elems ] : elems;\\n            $.each(elems, function(ndx, el) {\\n                var scopedOpts = $.extend(true, {}, that.opts);\\n                if (importAttributeOptions(el, scopedOpts, $.extend(true, {}, that.userOptions), that.dataAttribute)) {\\n                    var maskset = generateMaskSet(scopedOpts, that.noMasksCache);\\n                    if (maskset !== undefined) {\\n                        if (el.inputmask !== undefined) {\\n                            el.inputmask.opts.autoUnmask = true;\\n                            el.inputmask.remove();\\n                        }\\n                        el.inputmask = new Inputmask(undefined, undefined, true);\\n                        el.inputmask.opts = scopedOpts;\\n                        el.inputmask.noMasksCache = that.noMasksCache;\\n                        el.inputmask.userOptions = $.extend(true, {}, that.userOptions);\\n                        el.inputmask.isRTL = scopedOpts.isRTL || scopedOpts.numericInput;\\n                        el.inputmask.el = el;\\n                        el.inputmask.maskset = maskset;\\n                        $.data(el, \"_inputmask_opts\", scopedOpts);\\n                        maskScope.call(el.inputmask, {\\n                            action: \"mask\"\\n                        });\\n                    }\\n                }\\n            });\\n            return elems && elems[0] ? elems[0].inputmask || this : this;\\n        },\\n        option: function(options, noremask) {\\n            if (typeof options === \"string\") {\\n                return this.opts[options];\\n            } else if (typeof options === \"object\") {\\n                $.extend(this.userOptions, options);\\n                if (this.el && noremask !== true) {\\n                    this.mask(this.el);\\n                }\\n                return this;\\n            }\\n        },\\n        unmaskedvalue: function(value) {\\n            this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\\n            return maskScope.call(this, {\\n                action: \"unmaskedvalue\",\\n                value: value\\n            });\\n        },\\n        remove: function() {\\n            return maskScope.call(this, {\\n                action: \"remove\"\\n            });\\n        },\\n        getemptymask: function() {\\n            this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\\n            return maskScope.call(this, {\\n                action: \"getemptymask\"\\n            });\\n        },\\n        hasMaskedValue: function() {\\n            return !this.opts.autoUnmask;\\n        },\\n        isComplete: function() {\\n            this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\\n            return maskScope.call(this, {\\n                action: \"isComplete\"\\n            });\\n        },\\n        getmetadata: function() {\\n            this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\\n            return maskScope.call(this, {\\n                action: \"getmetadata\"\\n            });\\n        },\\n        isValid: function(value) {\\n            this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\\n            return maskScope.call(this, {\\n                action: \"isValid\",\\n                value: value\\n            });\\n        },\\n        format: function(value, metadata) {\\n            this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\\n            return maskScope.call(this, {\\n                action: \"format\",\\n                value: value,\\n                metadata: metadata\\n            });\\n        },\\n        setValue: function(value) {\\n            if (this.el) {\\n                $(this.el).trigger(\"setvalue\", [ value ]);\\n            }\\n        },\\n        analyseMask: function(mask, regexMask, opts) {\\n            var tokenizer = /(?:[?*+]|\\\\{[0-9\\\\+\\\\*]+(?:,[0-9\\\\+\\\\*]*)?(?:\\\\|[0-9\\\\+\\\\*]*)?\\\\})|[^.?*+^${[]()|\\\\\\\\]+|./g, regexTokenizer = /\\\\[\\\\^?]?(?:[^\\\\\\\\\\\\]]+|\\\\\\\\[\\\\S\\\\s]?)*]?|\\\\\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\\\\S\\\\s]?)|\\\\((?:\\\\?[:=!]?)?|(?:[?*+]|\\\\{[0-9]+(?:,[0-9]*)?\\\\})\\\\??|[^.?*+^${[()|\\\\\\\\]+|./g, escaped = false, currentToken = new MaskToken(), match, m, openenings = [], maskTokens = [], openingToken, currentOpeningToken, alternator, lastMatch, groupToken;\\n            function MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {\\n                this.matches = [];\\n                this.openGroup = isGroup || false;\\n                this.alternatorGroup = false;\\n                this.isGroup = isGroup || false;\\n                this.isOptional = isOptional || false;\\n                this.isQuantifier = isQuantifier || false;\\n                this.isAlternator = isAlternator || false;\\n                this.quantifier = {\\n                    min: 1,\\n                    max: 1\\n                };\\n            }\\n            function insertTestDefinition(mtoken, element, position) {\\n                position = position !== undefined ? position : mtoken.matches.length;\\n                var prevMatch = mtoken.matches[position - 1];\\n                if (regexMask) {\\n                    if (element.indexOf(\"[\") === 0 || escaped && /\\\\\\\\d|\\\\\\\\s|\\\\\\\\w]/i.test(element) || element === \".\") {\\n                        mtoken.matches.splice(position++, 0, {\\n                            fn: new RegExp(element, opts.casing ? \"i\" : \"\"),\\n                            optionality: false,\\n                            newBlockMarker: prevMatch === undefined ? \"master\" : prevMatch.def !== element,\\n                            casing: null,\\n                            def: element,\\n                            placeholder: undefined,\\n                            nativeDef: element\\n                        });\\n                    } else {\\n                        if (escaped) element = element[element.length - 1];\\n                        $.each(element.split(\"\"), function(ndx, lmnt) {\\n                            prevMatch = mtoken.matches[position - 1];\\n                            mtoken.matches.splice(position++, 0, {\\n                                fn: null,\\n                                optionality: false,\\n                                newBlockMarker: prevMatch === undefined ? \"master\" : prevMatch.def !== lmnt && prevMatch.fn !== null,\\n                                casing: null,\\n                                def: opts.staticDefinitionSymbol || lmnt,\\n                                placeholder: opts.staticDefinitionSymbol !== undefined ? lmnt : undefined,\\n                                nativeDef: (escaped ? \"\\'\" : \"\") + lmnt\\n                            });\\n                        });\\n                    }\\n                    escaped = false;\\n                } else {\\n                    var maskdef = (opts.definitions ? opts.definitions[element] : undefined) || Inputmask.prototype.definitions[element];\\n                    if (maskdef && !escaped) {\\n                        mtoken.matches.splice(position++, 0, {\\n                            fn: maskdef.validator ? typeof maskdef.validator == \"string\" ? new RegExp(maskdef.validator, opts.casing ? \"i\" : \"\") : new function() {\\n                                this.test = maskdef.validator;\\n                            }() : new RegExp(\".\"),\\n                            optionality: false,\\n                            newBlockMarker: prevMatch === undefined ? \"master\" : prevMatch.def !== (maskdef.definitionSymbol || element),\\n                            casing: maskdef.casing,\\n                            def: maskdef.definitionSymbol || element,\\n                            placeholder: maskdef.placeholder,\\n                            nativeDef: element\\n                        });\\n                    } else {\\n                        mtoken.matches.splice(position++, 0, {\\n                            fn: null,\\n                            optionality: false,\\n                            newBlockMarker: prevMatch === undefined ? \"master\" : prevMatch.def !== element && prevMatch.fn !== null,\\n                            casing: null,\\n                            def: opts.staticDefinitionSymbol || element,\\n                            placeholder: opts.staticDefinitionSymbol !== undefined ? element : undefined,\\n                            nativeDef: (escaped ? \"\\'\" : \"\") + element\\n                        });\\n                        escaped = false;\\n                    }\\n                }\\n            }\\n            function verifyGroupMarker(maskToken) {\\n                if (maskToken && maskToken.matches) {\\n                    $.each(maskToken.matches, function(ndx, token) {\\n                        var nextToken = maskToken.matches[ndx + 1];\\n                        if ((nextToken === undefined || (nextToken.matches === undefined || nextToken.isQuantifier === false)) && token && token.isGroup) {\\n                            token.isGroup = false;\\n                            if (!regexMask) {\\n                                insertTestDefinition(token, opts.groupmarker[0], 0);\\n                                if (token.openGroup !== true) {\\n                                    insertTestDefinition(token, opts.groupmarker[1]);\\n                                }\\n                            }\\n                        }\\n                        verifyGroupMarker(token);\\n                    });\\n                }\\n            }\\n            function defaultCase() {\\n                if (openenings.length > 0) {\\n                    currentOpeningToken = openenings[openenings.length - 1];\\n                    insertTestDefinition(currentOpeningToken, m);\\n                    if (currentOpeningToken.isAlternator) {\\n                        alternator = openenings.pop();\\n                        for (var mndx = 0; mndx < alternator.matches.length; mndx++) {\\n                            if (alternator.matches[mndx].isGroup) alternator.matches[mndx].isGroup = false;\\n                        }\\n                        if (openenings.length > 0) {\\n                            currentOpeningToken = openenings[openenings.length - 1];\\n                            currentOpeningToken.matches.push(alternator);\\n                        } else {\\n                            currentToken.matches.push(alternator);\\n                        }\\n                    }\\n                } else {\\n                    insertTestDefinition(currentToken, m);\\n                }\\n            }\\n            function reverseTokens(maskToken) {\\n                function reverseStatic(st) {\\n                    if (st === opts.optionalmarker[0]) st = opts.optionalmarker[1]; else if (st === opts.optionalmarker[1]) st = opts.optionalmarker[0]; else if (st === opts.groupmarker[0]) st = opts.groupmarker[1]; else if (st === opts.groupmarker[1]) st = opts.groupmarker[0];\\n                    return st;\\n                }\\n                maskToken.matches = maskToken.matches.reverse();\\n                for (var match in maskToken.matches) {\\n                    if (maskToken.matches.hasOwnProperty(match)) {\\n                        var intMatch = parseInt(match);\\n                        if (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) {\\n                            var qt = maskToken.matches[match];\\n                            maskToken.matches.splice(match, 1);\\n                            maskToken.matches.splice(intMatch + 1, 0, qt);\\n                        }\\n                        if (maskToken.matches[match].matches !== undefined) {\\n                            maskToken.matches[match] = reverseTokens(maskToken.matches[match]);\\n                        } else {\\n                            maskToken.matches[match] = reverseStatic(maskToken.matches[match]);\\n                        }\\n                    }\\n                }\\n                return maskToken;\\n            }\\n            function groupify(matches) {\\n                var groupToken = new MaskToken(true);\\n                groupToken.openGroup = false;\\n                groupToken.matches = matches;\\n                return groupToken;\\n            }\\n            if (regexMask) {\\n                opts.optionalmarker[0] = undefined;\\n                opts.optionalmarker[1] = undefined;\\n            }\\n            while (match = regexMask ? regexTokenizer.exec(mask) : tokenizer.exec(mask)) {\\n                m = match[0];\\n                if (regexMask) {\\n                    switch (m.charAt(0)) {\\n                      case \"?\":\\n                        m = \"{0,1}\";\\n                        break;\\n\\n                      case \"+\":\\n                      case \"*\":\\n                        m = \"{\" + m + \"}\";\\n                        break;\\n                    }\\n                }\\n                if (escaped) {\\n                    defaultCase();\\n                    continue;\\n                }\\n                switch (m.charAt(0)) {\\n                  case \"(?=\":\\n                    break;\\n\\n                  case \"(?!\":\\n                    break;\\n\\n                  case \"(?<=\":\\n                    break;\\n\\n                  case \"(?<!\":\\n                    break;\\n\\n                  case opts.escapeChar:\\n                    escaped = true;\\n                    if (regexMask) {\\n                        defaultCase();\\n                    }\\n                    break;\\n\\n                  case opts.optionalmarker[1]:\\n                  case opts.groupmarker[1]:\\n                    openingToken = openenings.pop();\\n                    openingToken.openGroup = false;\\n                    if (openingToken !== undefined) {\\n                        if (openenings.length > 0) {\\n                            currentOpeningToken = openenings[openenings.length - 1];\\n                            currentOpeningToken.matches.push(openingToken);\\n                            if (currentOpeningToken.isAlternator) {\\n                                alternator = openenings.pop();\\n                                for (var mndx = 0; mndx < alternator.matches.length; mndx++) {\\n                                    alternator.matches[mndx].isGroup = false;\\n                                    alternator.matches[mndx].alternatorGroup = false;\\n                                }\\n                                if (openenings.length > 0) {\\n                                    currentOpeningToken = openenings[openenings.length - 1];\\n                                    currentOpeningToken.matches.push(alternator);\\n                                } else {\\n                                    currentToken.matches.push(alternator);\\n                                }\\n                            }\\n                        } else {\\n                            currentToken.matches.push(openingToken);\\n                        }\\n                    } else defaultCase();\\n                    break;\\n\\n                  case opts.optionalmarker[0]:\\n                    openenings.push(new MaskToken(false, true));\\n                    break;\\n\\n                  case opts.groupmarker[0]:\\n                    openenings.push(new MaskToken(true));\\n                    break;\\n\\n                  case opts.quantifiermarker[0]:\\n                    var quantifier = new MaskToken(false, false, true);\\n                    m = m.replace(/[{}]/g, \"\");\\n                    var mqj = m.split(\"|\"), mq = mqj[0].split(\",\"), mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]), mq1 = mq.length === 1 ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);\\n                    if (mq0 === \"*\" || mq0 === \"+\") {\\n                        mq0 = mq1 === \"*\" ? 0 : 1;\\n                    }\\n                    quantifier.quantifier = {\\n                        min: mq0,\\n                        max: mq1,\\n                        jit: mqj[1]\\n                    };\\n                    var matches = openenings.length > 0 ? openenings[openenings.length - 1].matches : currentToken.matches;\\n                    match = matches.pop();\\n                    if (match.isAlternator) {\\n                        matches.push(match);\\n                        matches = match.matches;\\n                        var groupToken = new MaskToken(true);\\n                        var tmpMatch = matches.pop();\\n                        matches.push(groupToken);\\n                        matches = groupToken.matches;\\n                        match = tmpMatch;\\n                    }\\n                    if (!match.isGroup) {\\n                        match = groupify([ match ]);\\n                    }\\n                    matches.push(match);\\n                    matches.push(quantifier);\\n                    break;\\n\\n                  case opts.alternatormarker:\\n                    function groupQuantifier(matches) {\\n                        var lastMatch = matches.pop();\\n                        if (lastMatch.isQuantifier) {\\n                            lastMatch = groupify([ matches.pop(), lastMatch ]);\\n                        }\\n                        return lastMatch;\\n                    }\\n                    if (openenings.length > 0) {\\n                        currentOpeningToken = openenings[openenings.length - 1];\\n                        var subToken = currentOpeningToken.matches[currentOpeningToken.matches.length - 1];\\n                        if (currentOpeningToken.openGroup && (subToken.matches === undefined || subToken.isGroup === false && subToken.isAlternator === false)) {\\n                            lastMatch = openenings.pop();\\n                        } else {\\n                            lastMatch = groupQuantifier(currentOpeningToken.matches);\\n                        }\\n                    } else {\\n                        lastMatch = groupQuantifier(currentToken.matches);\\n                    }\\n                    if (lastMatch.isAlternator) {\\n                        openenings.push(lastMatch);\\n                    } else {\\n                        if (lastMatch.alternatorGroup) {\\n                            alternator = openenings.pop();\\n                            lastMatch.alternatorGroup = false;\\n                        } else {\\n                            alternator = new MaskToken(false, false, false, true);\\n                        }\\n                        alternator.matches.push(lastMatch);\\n                        openenings.push(alternator);\\n                        if (lastMatch.openGroup) {\\n                            lastMatch.openGroup = false;\\n                            var alternatorGroup = new MaskToken(true);\\n                            alternatorGroup.alternatorGroup = true;\\n                            openenings.push(alternatorGroup);\\n                        }\\n                    }\\n                    break;\\n\\n                  default:\\n                    defaultCase();\\n                }\\n            }\\n            while (openenings.length > 0) {\\n                openingToken = openenings.pop();\\n                currentToken.matches.push(openingToken);\\n            }\\n            if (currentToken.matches.length > 0) {\\n                verifyGroupMarker(currentToken);\\n                maskTokens.push(currentToken);\\n            }\\n            if (opts.numericInput || opts.isRTL) {\\n                reverseTokens(maskTokens[0]);\\n            }\\n            return maskTokens;\\n        }\\n    };\\n    Inputmask.extendDefaults = function(options) {\\n        $.extend(true, Inputmask.prototype.defaults, options);\\n    };\\n    Inputmask.extendDefinitions = function(definition) {\\n        $.extend(true, Inputmask.prototype.definitions, definition);\\n    };\\n    Inputmask.extendAliases = function(alias) {\\n        $.extend(true, Inputmask.prototype.aliases, alias);\\n    };\\n    Inputmask.format = function(value, options, metadata) {\\n        return Inputmask(options).format(value, metadata);\\n    };\\n    Inputmask.unmask = function(value, options) {\\n        return Inputmask(options).unmaskedvalue(value);\\n    };\\n    Inputmask.isValid = function(value, options) {\\n        return Inputmask(options).isValid(value);\\n    };\\n    Inputmask.remove = function(elems) {\\n        if (typeof elems === \"string\") {\\n            elems = document.getElementById(elems) || document.querySelectorAll(elems);\\n        }\\n        elems = elems.nodeName ? [ elems ] : elems;\\n        $.each(elems, function(ndx, el) {\\n            if (el.inputmask) el.inputmask.remove();\\n        });\\n    };\\n    Inputmask.setValue = function(elems, value) {\\n        if (typeof elems === \"string\") {\\n            elems = document.getElementById(elems) || document.querySelectorAll(elems);\\n        }\\n        elems = elems.nodeName ? [ elems ] : elems;\\n        $.each(elems, function(ndx, el) {\\n            if (el.inputmask) el.inputmask.setValue(value); else $(el).trigger(\"setvalue\", [ value ]);\\n        });\\n    };\\n    Inputmask.escapeRegex = function(str) {\\n        var specials = [ \"/\", \".\", \"*\", \"+\", \"?\", \"|\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", \"\\\\\\\\\", \"$\", \"^\" ];\\n        return str.replace(new RegExp(\"(\\\\\\\\\" + specials.join(\"|\\\\\\\\\") + \")\", \"gim\"), \"\\\\\\\\$1\");\\n    };\\n    Inputmask.keyCode = {\\n        BACKSPACE: 8,\\n        BACKSPACE_SAFARI: 127,\\n        DELETE: 46,\\n        DOWN: 40,\\n        END: 35,\\n        ENTER: 13,\\n        ESCAPE: 27,\\n        HOME: 36,\\n        INSERT: 45,\\n        LEFT: 37,\\n        PAGE_DOWN: 34,\\n        PAGE_UP: 33,\\n        RIGHT: 39,\\n        SPACE: 32,\\n        TAB: 9,\\n        UP: 38,\\n        X: 88,\\n        CONTROL: 17\\n    };\\n    Inputmask.dependencyLib = $;\\n    function resolveAlias(aliasStr, options, opts) {\\n        var aliasDefinition = Inputmask.prototype.aliases[aliasStr];\\n        if (aliasDefinition) {\\n            if (aliasDefinition.alias) resolveAlias(aliasDefinition.alias, undefined, opts);\\n            $.extend(true, opts, aliasDefinition);\\n            $.extend(true, opts, options);\\n            return true;\\n        } else if (opts.mask === null) {\\n            opts.mask = aliasStr;\\n        }\\n        return false;\\n    }\\n    function generateMaskSet(opts, nocache) {\\n        function generateMask(mask, metadata, opts) {\\n            var regexMask = false;\\n            if (mask === null || mask === \"\") {\\n                regexMask = opts.regex !== null;\\n                if (regexMask) {\\n                    mask = opts.regex;\\n                    mask = mask.replace(/^(\\\\^)(.*)(\\\\$)$/, \"$2\");\\n                } else {\\n                    regexMask = true;\\n                    mask = \".*\";\\n                }\\n            }\\n            if (mask.length === 1 && opts.greedy === false && opts.repeat !== 0) {\\n                opts.placeholder = \"\";\\n            }\\n            if (opts.repeat > 0 || opts.repeat === \"*\" || opts.repeat === \"+\") {\\n                var repeatStart = opts.repeat === \"*\" ? 0 : opts.repeat === \"+\" ? 1 : opts.repeat;\\n                mask = opts.groupmarker[0] + mask + opts.groupmarker[1] + opts.quantifiermarker[0] + repeatStart + \",\" + opts.repeat + opts.quantifiermarker[1];\\n            }\\n            var masksetDefinition, maskdefKey = regexMask ? \"regex_\" + opts.regex : opts.numericInput ? mask.split(\"\").reverse().join(\"\") : mask;\\n            if (Inputmask.prototype.masksCache[maskdefKey] === undefined || nocache === true) {\\n                masksetDefinition = {\\n                    mask: mask,\\n                    maskToken: Inputmask.prototype.analyseMask(mask, regexMask, opts),\\n                    validPositions: {},\\n                    _buffer: undefined,\\n                    buffer: undefined,\\n                    tests: {},\\n                    excludes: {},\\n                    metadata: metadata,\\n                    maskLength: undefined,\\n                    jitOffset: {}\\n                };\\n                if (nocache !== true) {\\n                    Inputmask.prototype.masksCache[maskdefKey] = masksetDefinition;\\n                    masksetDefinition = $.extend(true, {}, Inputmask.prototype.masksCache[maskdefKey]);\\n                }\\n            } else masksetDefinition = $.extend(true, {}, Inputmask.prototype.masksCache[maskdefKey]);\\n            return masksetDefinition;\\n        }\\n        var ms;\\n        if ($.isFunction(opts.mask)) {\\n            opts.mask = opts.mask(opts);\\n        }\\n        if ($.isArray(opts.mask)) {\\n            if (opts.mask.length > 1) {\\n                if (opts.keepStatic === null) {\\n                    opts.keepStatic = \"auto\";\\n                    for (var i = 0; i < opts.mask.length; i++) {\\n                        if (opts.mask[i].charAt(0) !== opts.mask[0].charAt(0)) {\\n                            opts.keepStatic = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n                var altMask = opts.groupmarker[0];\\n                $.each(opts.isRTL ? opts.mask.reverse() : opts.mask, function(ndx, msk) {\\n                    if (altMask.length > 1) {\\n                        altMask += opts.groupmarker[1] + opts.alternatormarker + opts.groupmarker[0];\\n                    }\\n                    if (msk.mask !== undefined && !$.isFunction(msk.mask)) {\\n                        altMask += msk.mask;\\n                    } else {\\n                        altMask += msk;\\n                    }\\n                });\\n                altMask += opts.groupmarker[1];\\n                return generateMask(altMask, opts.mask, opts);\\n            } else opts.mask = opts.mask.pop();\\n        }\\n        if (opts.mask && opts.mask.mask !== undefined && !$.isFunction(opts.mask.mask)) {\\n            ms = generateMask(opts.mask.mask, opts.mask, opts);\\n        } else {\\n            ms = generateMask(opts.mask, opts.mask, opts);\\n        }\\n        return ms;\\n    }\\n    function isInputEventSupported(eventName) {\\n        var el = document.createElement(\"input\"), evName = \"on\" + eventName, isSupported = evName in el;\\n        if (!isSupported) {\\n            el.setAttribute(evName, \"return;\");\\n            isSupported = typeof el[evName] === \"function\";\\n        }\\n        el = null;\\n        return isSupported;\\n    }\\n    function maskScope(actionObj, maskset, opts) {\\n        maskset = maskset || this.maskset;\\n        opts = opts || this.opts;\\n        var inputmask = this, el = this.el, isRTL = this.isRTL, undoValue, $el, skipKeyPressEvent = false, skipInputEvent = false, ignorable = false, maxLength, mouseEnter = false, colorMask, originalPlaceholder;\\n        function getMaskTemplate(baseOnInput, minimalPos, includeMode, noJit, clearOptionalTail) {\\n            var greedy = opts.greedy;\\n            if (clearOptionalTail) opts.greedy = false;\\n            minimalPos = minimalPos || 0;\\n            var maskTemplate = [], ndxIntlzr, pos = 0, test, testPos, lvp = getLastValidPosition();\\n            do {\\n                if (baseOnInput === true && getMaskSet().validPositions[pos]) {\\n                    testPos = clearOptionalTail && getMaskSet().validPositions[pos].match.optionality === true && getMaskSet().validPositions[pos + 1] === undefined && (getMaskSet().validPositions[pos].generatedInput === true || getMaskSet().validPositions[pos].input == opts.skipOptionalPartCharacter && pos > 0) ? determineTestTemplate(pos, getTests(pos, ndxIntlzr, pos - 1)) : getMaskSet().validPositions[pos];\\n                    test = testPos.match;\\n                    ndxIntlzr = testPos.locator.slice();\\n                    maskTemplate.push(includeMode === true ? testPos.input : includeMode === false ? test.nativeDef : getPlaceholder(pos, test));\\n                } else {\\n                    testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);\\n                    test = testPos.match;\\n                    ndxIntlzr = testPos.locator.slice();\\n                    var jitMasking = noJit === true ? false : opts.jitMasking !== false ? opts.jitMasking : test.jit;\\n                    if (jitMasking === false || jitMasking === undefined || typeof jitMasking === \"number\" && isFinite(jitMasking) && jitMasking > pos) {\\n                        maskTemplate.push(includeMode === false ? test.nativeDef : getPlaceholder(pos, test));\\n                    }\\n                }\\n                if (opts.keepStatic === \"auto\") {\\n                    if (test.newBlockMarker && test.fn !== null) {\\n                        opts.keepStatic = pos - 1;\\n                    }\\n                }\\n                pos++;\\n            } while ((maxLength === undefined || pos < maxLength) && (test.fn !== null || test.def !== \"\") || minimalPos > pos);\\n            if (maskTemplate[maskTemplate.length - 1] === \"\") {\\n                maskTemplate.pop();\\n            }\\n            if (includeMode !== false || getMaskSet().maskLength === undefined) getMaskSet().maskLength = pos - 1;\\n            opts.greedy = greedy;\\n            return maskTemplate;\\n        }\\n        function getMaskSet() {\\n            return maskset;\\n        }\\n        function resetMaskSet(soft) {\\n            var maskset = getMaskSet();\\n            maskset.buffer = undefined;\\n            if (soft !== true) {\\n                maskset.validPositions = {};\\n                maskset.p = 0;\\n            }\\n        }\\n        function getLastValidPosition(closestTo, strict, validPositions) {\\n            var before = -1, after = -1, valids = validPositions || getMaskSet().validPositions;\\n            if (closestTo === undefined) closestTo = -1;\\n            for (var posNdx in valids) {\\n                var psNdx = parseInt(posNdx);\\n                if (valids[psNdx] && (strict || valids[psNdx].generatedInput !== true)) {\\n                    if (psNdx <= closestTo) before = psNdx;\\n                    if (psNdx >= closestTo) after = psNdx;\\n                }\\n            }\\n            return before === -1 || before == closestTo ? after : after == -1 ? before : closestTo - before < after - closestTo ? before : after;\\n        }\\n        function getDecisionTaker(tst) {\\n            var decisionTaker = tst.locator[tst.alternation];\\n            if (typeof decisionTaker == \"string\" && decisionTaker.length > 0) {\\n                decisionTaker = decisionTaker.split(\",\")[0];\\n            }\\n            return decisionTaker !== undefined ? decisionTaker.toString() : \"\";\\n        }\\n        function getLocator(tst, align) {\\n            var locator = (tst.alternation != undefined ? tst.mloc[getDecisionTaker(tst)] : tst.locator).join(\"\");\\n            if (locator !== \"\") while (locator.length < align) locator += \"0\";\\n            return locator;\\n        }\\n        function determineTestTemplate(pos, tests) {\\n            pos = pos > 0 ? pos - 1 : 0;\\n            var altTest = getTest(pos), targetLocator = getLocator(altTest), tstLocator, closest, bestMatch;\\n            for (var ndx = 0; ndx < tests.length; ndx++) {\\n                var tst = tests[ndx];\\n                tstLocator = getLocator(tst, targetLocator.length);\\n                var distance = Math.abs(tstLocator - targetLocator);\\n                if (closest === undefined || tstLocator !== \"\" && distance < closest || bestMatch && !opts.greedy && bestMatch.match.optionality && bestMatch.match.newBlockMarker === \"master\" && (!tst.match.optionality || !tst.match.newBlockMarker) || bestMatch && bestMatch.match.optionalQuantifier && !tst.match.optionalQuantifier) {\\n                    closest = distance;\\n                    bestMatch = tst;\\n                }\\n            }\\n            return bestMatch;\\n        }\\n        function getTestTemplate(pos, ndxIntlzr, tstPs) {\\n            return getMaskSet().validPositions[pos] || determineTestTemplate(pos, getTests(pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs));\\n        }\\n        function getTest(pos, tests) {\\n            if (getMaskSet().validPositions[pos]) {\\n                return getMaskSet().validPositions[pos];\\n            }\\n            return (tests || getTests(pos))[0];\\n        }\\n        function positionCanMatchDefinition(pos, def) {\\n            var valid = false, tests = getTests(pos);\\n            for (var tndx = 0; tndx < tests.length; tndx++) {\\n                if (tests[tndx].match && tests[tndx].match.def === def) {\\n                    valid = true;\\n                    break;\\n                }\\n            }\\n            return valid;\\n        }\\n        function getTests(pos, ndxIntlzr, tstPs) {\\n            var maskTokens = getMaskSet().maskToken, testPos = ndxIntlzr ? tstPs : 0, ndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [ 0 ], matches = [], insertStop = false, latestMatch, cacheDependency = ndxIntlzr ? ndxIntlzr.join(\"\") : \"\";\\n            function resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) {\\n                function handleMatch(match, loopNdx, quantifierRecurse) {\\n                    function isFirstMatch(latestMatch, tokenGroup) {\\n                        var firstMatch = $.inArray(latestMatch, tokenGroup.matches) === 0;\\n                        if (!firstMatch) {\\n                            $.each(tokenGroup.matches, function(ndx, match) {\\n                                if (match.isQuantifier === true) firstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]); else if (match.hasOwnProperty(\"matches\")) firstMatch = isFirstMatch(latestMatch, match);\\n                                if (firstMatch) return false;\\n                            });\\n                        }\\n                        return firstMatch;\\n                    }\\n                    function resolveNdxInitializer(pos, alternateNdx, targetAlternation) {\\n                        var bestMatch, indexPos;\\n                        if (getMaskSet().tests[pos] || getMaskSet().validPositions[pos]) {\\n                            $.each(getMaskSet().tests[pos] || [ getMaskSet().validPositions[pos] ], function(ndx, lmnt) {\\n                                if (lmnt.mloc[alternateNdx]) {\\n                                    bestMatch = lmnt;\\n                                    return false;\\n                                }\\n                                var alternation = targetAlternation !== undefined ? targetAlternation : lmnt.alternation, ndxPos = lmnt.locator[alternation] !== undefined ? lmnt.locator[alternation].toString().indexOf(alternateNdx) : -1;\\n                                if ((indexPos === undefined || ndxPos < indexPos) && ndxPos !== -1) {\\n                                    bestMatch = lmnt;\\n                                    indexPos = ndxPos;\\n                                }\\n                            });\\n                        }\\n                        if (bestMatch) {\\n                            var bestMatchAltIndex = bestMatch.locator[bestMatch.alternation];\\n                            var locator = bestMatch.mloc[alternateNdx] || bestMatch.mloc[bestMatchAltIndex] || bestMatch.locator;\\n                            return locator.slice((targetAlternation !== undefined ? targetAlternation : bestMatch.alternation) + 1);\\n                        } else {\\n                            return targetAlternation !== undefined ? resolveNdxInitializer(pos, alternateNdx) : undefined;\\n                        }\\n                    }\\n                    function isSubsetOf(source, target) {\\n                        function expand(pattern) {\\n                            var expanded = [], start, end;\\n                            for (var i = 0, l = pattern.length; i < l; i++) {\\n                                if (pattern.charAt(i) === \"-\") {\\n                                    end = pattern.charCodeAt(i + 1);\\n                                    while (++start < end) expanded.push(String.fromCharCode(start));\\n                                } else {\\n                                    start = pattern.charCodeAt(i);\\n                                    expanded.push(pattern.charAt(i));\\n                                }\\n                            }\\n                            return expanded.join(\"\");\\n                        }\\n                        if (opts.regex && source.match.fn !== null && target.match.fn !== null) {\\n                            return expand(target.match.def.replace(/[\\\\[\\\\]]/g, \"\")).indexOf(expand(source.match.def.replace(/[\\\\[\\\\]]/g, \"\"))) !== -1;\\n                        }\\n                        return source.match.def === target.match.nativeDef;\\n                    }\\n                    function staticCanMatchDefinition(source, target) {\\n                        var sloc = source.locator.slice(source.alternation).join(\"\"), tloc = target.locator.slice(target.alternation).join(\"\"), canMatch = sloc == tloc;\\n                        canMatch = canMatch && source.match.fn === null && target.match.fn !== null ? target.match.fn.test(source.match.def, getMaskSet(), pos, false, opts, false) : false;\\n                        return canMatch;\\n                    }\\n                    function setMergeLocators(targetMatch, altMatch) {\\n                        if (altMatch === undefined || targetMatch.alternation === altMatch.alternation && targetMatch.locator[targetMatch.alternation].toString().indexOf(altMatch.locator[altMatch.alternation]) === -1) {\\n                            targetMatch.mloc = targetMatch.mloc || {};\\n                            var locNdx = targetMatch.locator[targetMatch.alternation];\\n                            if (locNdx === undefined) targetMatch.alternation = undefined; else {\\n                                if (typeof locNdx === \"string\") locNdx = locNdx.split(\",\")[0];\\n                                if (targetMatch.mloc[locNdx] === undefined) targetMatch.mloc[locNdx] = targetMatch.locator.slice();\\n                                if (altMatch !== undefined) {\\n                                    for (var ndx in altMatch.mloc) {\\n                                        if (typeof ndx === \"string\") ndx = ndx.split(\",\")[0];\\n                                        if (targetMatch.mloc[ndx] === undefined) targetMatch.mloc[ndx] = altMatch.mloc[ndx];\\n                                    }\\n                                    targetMatch.locator[targetMatch.alternation] = Object.keys(targetMatch.mloc).join(\",\");\\n                                }\\n                                return true;\\n                            }\\n                        }\\n                        return false;\\n                    }\\n                    if (testPos > 500 && quantifierRecurse !== undefined) {\\n                        throw \"Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. \" + getMaskSet().mask;\\n                    }\\n                    if (testPos === pos && match.matches === undefined) {\\n                        matches.push({\\n                            match: match,\\n                            locator: loopNdx.reverse(),\\n                            cd: cacheDependency,\\n                            mloc: {}\\n                        });\\n                        return true;\\n                    } else if (match.matches !== undefined) {\\n                        if (match.isGroup && quantifierRecurse !== match) {\\n                            match = handleMatch(maskToken.matches[$.inArray(match, maskToken.matches) + 1], loopNdx, quantifierRecurse);\\n                            if (match) return true;\\n                        } else if (match.isOptional) {\\n                            var optionalToken = match;\\n                            match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);\\n                            if (match) {\\n                                $.each(matches, function(ndx, mtch) {\\n                                    mtch.match.optionality = true;\\n                                });\\n                                latestMatch = matches[matches.length - 1].match;\\n                                if (quantifierRecurse === undefined && isFirstMatch(latestMatch, optionalToken)) {\\n                                    insertStop = true;\\n                                    testPos = pos;\\n                                } else return true;\\n                            }\\n                        } else if (match.isAlternator) {\\n                            var alternateToken = match, malternateMatches = [], maltMatches, currentMatches = matches.slice(), loopNdxCnt = loopNdx.length;\\n                            var altIndex = ndxInitializer.length > 0 ? ndxInitializer.shift() : -1;\\n                            if (altIndex === -1 || typeof altIndex === \"string\") {\\n                                var currentPos = testPos, ndxInitializerClone = ndxInitializer.slice(), altIndexArr = [], amndx;\\n                                if (typeof altIndex == \"string\") {\\n                                    altIndexArr = altIndex.split(\",\");\\n                                } else {\\n                                    for (amndx = 0; amndx < alternateToken.matches.length; amndx++) {\\n                                        altIndexArr.push(amndx.toString());\\n                                    }\\n                                }\\n                                if (getMaskSet().excludes[pos]) {\\n                                    var altIndexArrClone = altIndexArr.slice();\\n                                    for (var i = 0, el = getMaskSet().excludes[pos].length; i < el; i++) {\\n                                        altIndexArr.splice(altIndexArr.indexOf(getMaskSet().excludes[pos][i].toString()), 1);\\n                                    }\\n                                    if (altIndexArr.length === 0) {\\n                                        getMaskSet().excludes[pos] = undefined;\\n                                        altIndexArr = altIndexArrClone;\\n                                    }\\n                                }\\n                                if (opts.keepStatic === true || isFinite(parseInt(opts.keepStatic)) && currentPos >= opts.keepStatic) altIndexArr = altIndexArr.slice(0, 1);\\n                                var unMatchedAlternation = false;\\n                                for (var ndx = 0; ndx < altIndexArr.length; ndx++) {\\n                                    amndx = parseInt(altIndexArr[ndx]);\\n                                    matches = [];\\n                                    ndxInitializer = typeof altIndex === \"string\" ? resolveNdxInitializer(testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice() : ndxInitializerClone.slice();\\n                                    if (alternateToken.matches[amndx] && handleMatch(alternateToken.matches[amndx], [ amndx ].concat(loopNdx), quantifierRecurse)) match = true; else if (ndx === 0) {\\n                                        unMatchedAlternation = true;\\n                                    }\\n                                    maltMatches = matches.slice();\\n                                    testPos = currentPos;\\n                                    matches = [];\\n                                    for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {\\n                                        var altMatch = maltMatches[ndx1], dropMatch = false;\\n                                        altMatch.match.jit = altMatch.match.jit || unMatchedAlternation;\\n                                        altMatch.alternation = altMatch.alternation || loopNdxCnt;\\n                                        setMergeLocators(altMatch);\\n                                        for (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {\\n                                            var altMatch2 = malternateMatches[ndx2];\\n                                            if (typeof altIndex !== \"string\" || altMatch.alternation !== undefined && $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr) !== -1) {\\n                                                if (altMatch.match.nativeDef === altMatch2.match.nativeDef) {\\n                                                    dropMatch = true;\\n                                                    setMergeLocators(altMatch2, altMatch);\\n                                                    break;\\n                                                } else if (isSubsetOf(altMatch, altMatch2)) {\\n                                                    if (setMergeLocators(altMatch, altMatch2)) {\\n                                                        dropMatch = true;\\n                                                        malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch);\\n                                                    }\\n                                                    break;\\n                                                } else if (isSubsetOf(altMatch2, altMatch)) {\\n                                                    setMergeLocators(altMatch2, altMatch);\\n                                                    break;\\n                                                } else if (staticCanMatchDefinition(altMatch, altMatch2)) {\\n                                                    if (setMergeLocators(altMatch, altMatch2)) {\\n                                                        dropMatch = true;\\n                                                        malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch);\\n                                                    }\\n                                                    break;\\n                                                }\\n                                            }\\n                                        }\\n                                        if (!dropMatch) {\\n                                            malternateMatches.push(altMatch);\\n                                        }\\n                                    }\\n                                }\\n                                matches = currentMatches.concat(malternateMatches);\\n                                testPos = pos;\\n                                insertStop = matches.length > 0;\\n                                match = malternateMatches.length > 0;\\n                                ndxInitializer = ndxInitializerClone.slice();\\n                            } else match = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [ altIndex ].concat(loopNdx), quantifierRecurse);\\n                            if (match) return true;\\n                        } else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1]) {\\n                            var qt = match;\\n                            for (var qndx = ndxInitializer.length > 0 ? ndxInitializer.shift() : 0; qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max) && testPos <= pos; qndx++) {\\n                                var tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];\\n                                match = handleMatch(tokenGroup, [ qndx ].concat(loopNdx), tokenGroup);\\n                                if (match) {\\n                                    latestMatch = matches[matches.length - 1].match;\\n                                    latestMatch.optionalQuantifier = qndx >= qt.quantifier.min;\\n                                    latestMatch.jit = (qndx || 1) * tokenGroup.matches.indexOf(latestMatch) >= qt.quantifier.jit;\\n                                    if (latestMatch.optionalQuantifier && isFirstMatch(latestMatch, tokenGroup)) {\\n                                        insertStop = true;\\n                                        testPos = pos;\\n                                        break;\\n                                    }\\n                                    if (latestMatch.jit) {\\n                                        getMaskSet().jitOffset[pos] = tokenGroup.matches.indexOf(latestMatch);\\n                                    }\\n                                    return true;\\n                                }\\n                            }\\n                        } else {\\n                            match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);\\n                            if (match) return true;\\n                        }\\n                    } else {\\n                        testPos++;\\n                    }\\n                }\\n                for (var tndx = ndxInitializer.length > 0 ? ndxInitializer.shift() : 0; tndx < maskToken.matches.length; tndx++) {\\n                    if (maskToken.matches[tndx].isQuantifier !== true) {\\n                        var match = handleMatch(maskToken.matches[tndx], [ tndx ].concat(loopNdx), quantifierRecurse);\\n                        if (match && testPos === pos) {\\n                            return match;\\n                        } else if (testPos > pos) {\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            function mergeLocators(pos, tests) {\\n                var locator = [];\\n                if (!$.isArray(tests)) tests = [ tests ];\\n                if (tests.length > 0) {\\n                    if (tests[0].alternation === undefined) {\\n                        locator = determineTestTemplate(pos, tests.slice()).locator.slice();\\n                        if (locator.length === 0) locator = tests[0].locator.slice();\\n                    } else {\\n                        $.each(tests, function(ndx, tst) {\\n                            if (tst.def !== \"\") {\\n                                if (locator.length === 0) locator = tst.locator.slice(); else {\\n                                    for (var i = 0; i < locator.length; i++) {\\n                                        if (tst.locator[i] && locator[i].toString().indexOf(tst.locator[i]) === -1) {\\n                                            locator[i] += \",\" + tst.locator[i];\\n                                        }\\n                                    }\\n                                }\\n                            }\\n                        });\\n                    }\\n                }\\n                return locator;\\n            }\\n            if (pos > -1) {\\n                if (ndxIntlzr === undefined) {\\n                    var previousPos = pos - 1, test;\\n                    while ((test = getMaskSet().validPositions[previousPos] || getMaskSet().tests[previousPos]) === undefined && previousPos > -1) {\\n                        previousPos--;\\n                    }\\n                    if (test !== undefined && previousPos > -1) {\\n                        ndxInitializer = mergeLocators(previousPos, test);\\n                        cacheDependency = ndxInitializer.join(\"\");\\n                        testPos = previousPos;\\n                    }\\n                }\\n                if (getMaskSet().tests[pos] && getMaskSet().tests[pos][0].cd === cacheDependency) {\\n                    return getMaskSet().tests[pos];\\n                }\\n                for (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {\\n                    var match = resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [ mtndx ]);\\n                    if (match && testPos === pos || testPos > pos) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if (matches.length === 0 || insertStop) {\\n                matches.push({\\n                    match: {\\n                        fn: null,\\n                        optionality: false,\\n                        casing: null,\\n                        def: \"\",\\n                        placeholder: \"\"\\n                    },\\n                    locator: [],\\n                    mloc: {},\\n                    cd: cacheDependency\\n                });\\n            }\\n            if (ndxIntlzr !== undefined && getMaskSet().tests[pos]) {\\n                return $.extend(true, [], matches);\\n            }\\n            getMaskSet().tests[pos] = $.extend(true, [], matches);\\n            return getMaskSet().tests[pos];\\n        }\\n        function getBufferTemplate() {\\n            if (getMaskSet()._buffer === undefined) {\\n                getMaskSet()._buffer = getMaskTemplate(false, 1);\\n                if (getMaskSet().buffer === undefined) getMaskSet().buffer = getMaskSet()._buffer.slice();\\n            }\\n            return getMaskSet()._buffer;\\n        }\\n        function getBuffer(noCache) {\\n            if (getMaskSet().buffer === undefined || noCache === true) {\\n                getMaskSet().buffer = getMaskTemplate(true, getLastValidPosition(), true);\\n                if (getMaskSet()._buffer === undefined) getMaskSet()._buffer = getMaskSet().buffer.slice();\\n            }\\n            return getMaskSet().buffer;\\n        }\\n        function refreshFromBuffer(start, end, buffer) {\\n            var i, p;\\n            if (start === true) {\\n                resetMaskSet();\\n                start = 0;\\n                end = buffer.length;\\n            } else {\\n                for (i = start; i < end; i++) {\\n                    delete getMaskSet().validPositions[i];\\n                }\\n            }\\n            p = start;\\n            for (i = start; i < end; i++) {\\n                resetMaskSet(true);\\n                if (buffer[i] !== opts.skipOptionalPartCharacter) {\\n                    var valResult = isValid(p, buffer[i], true, true);\\n                    if (valResult !== false) {\\n                        resetMaskSet(true);\\n                        p = valResult.caret !== undefined ? valResult.caret : valResult.pos + 1;\\n                    }\\n                }\\n            }\\n        }\\n        function casing(elem, test, pos) {\\n            switch (opts.casing || test.casing) {\\n              case \"upper\":\\n                elem = elem.toUpperCase();\\n                break;\\n\\n              case \"lower\":\\n                elem = elem.toLowerCase();\\n                break;\\n\\n              case \"title\":\\n                var posBefore = getMaskSet().validPositions[pos - 1];\\n                if (pos === 0 || posBefore && posBefore.input === String.fromCharCode(Inputmask.keyCode.SPACE)) {\\n                    elem = elem.toUpperCase();\\n                } else {\\n                    elem = elem.toLowerCase();\\n                }\\n                break;\\n\\n              default:\\n                if ($.isFunction(opts.casing)) {\\n                    var args = Array.prototype.slice.call(arguments);\\n                    args.push(getMaskSet().validPositions);\\n                    elem = opts.casing.apply(this, args);\\n                }\\n            }\\n            return elem;\\n        }\\n        function checkAlternationMatch(altArr1, altArr2, na) {\\n            var altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1), isMatch = false, naArr = na !== undefined ? na.split(\",\") : [], naNdx;\\n            for (var i = 0; i < naArr.length; i++) {\\n                if ((naNdx = altArr1.indexOf(naArr[i])) !== -1) {\\n                    altArr1.splice(naNdx, 1);\\n                }\\n            }\\n            for (var alndx = 0; alndx < altArr1.length; alndx++) {\\n                if ($.inArray(altArr1[alndx], altArrC) !== -1) {\\n                    isMatch = true;\\n                    break;\\n                }\\n            }\\n            return isMatch;\\n        }\\n        function alternate(pos, c, strict, fromSetValid, rAltPos) {\\n            var validPsClone = $.extend(true, {}, getMaskSet().validPositions), lastAlt, alternation, isValidRslt = false, altPos, prevAltPos, i, validPos, decisionPos, lAltPos = rAltPos !== undefined ? rAltPos : getLastValidPosition();\\n            if (lAltPos === -1 && rAltPos === undefined) {\\n                lastAlt = 0;\\n                prevAltPos = getTest(lastAlt);\\n                alternation = prevAltPos.alternation;\\n            } else {\\n                for (;lAltPos >= 0; lAltPos--) {\\n                    altPos = getMaskSet().validPositions[lAltPos];\\n                    if (altPos && altPos.alternation !== undefined) {\\n                        if (prevAltPos && prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) {\\n                            break;\\n                        }\\n                        lastAlt = lAltPos;\\n                        alternation = getMaskSet().validPositions[lastAlt].alternation;\\n                        prevAltPos = altPos;\\n                    }\\n                }\\n            }\\n            if (alternation !== undefined) {\\n                decisionPos = parseInt(lastAlt);\\n                getMaskSet().excludes[decisionPos] = getMaskSet().excludes[decisionPos] || [];\\n                if (pos !== true) {\\n                    getMaskSet().excludes[decisionPos].push(getDecisionTaker(prevAltPos));\\n                }\\n                var validInputsClone = [], staticInputsBeforePos = 0;\\n                for (i = decisionPos; i < getLastValidPosition(undefined, true) + 1; i++) {\\n                    validPos = getMaskSet().validPositions[i];\\n                    if (validPos && validPos.generatedInput !== true) {\\n                        validInputsClone.push(validPos.input);\\n                    } else if (i < pos) staticInputsBeforePos++;\\n                    delete getMaskSet().validPositions[i];\\n                }\\n                while (getMaskSet().excludes[decisionPos] && getMaskSet().excludes[decisionPos].length < 10) {\\n                    var posOffset = staticInputsBeforePos * -1, validInputs = validInputsClone.slice();\\n                    getMaskSet().tests[decisionPos] = undefined;\\n                    resetMaskSet(true);\\n                    isValidRslt = true;\\n                    while (validInputs.length > 0) {\\n                        var input = validInputs.shift();\\n                        if (!(isValidRslt = isValid(getLastValidPosition(undefined, true) + 1, input, false, fromSetValid, true))) {\\n                            break;\\n                        }\\n                    }\\n                    if (isValidRslt && c !== undefined) {\\n                        var targetLvp = getLastValidPosition(pos) + 1;\\n                        for (i = decisionPos; i < getLastValidPosition() + 1; i++) {\\n                            validPos = getMaskSet().validPositions[i];\\n                            if ((validPos === undefined || validPos.match.fn == null) && i < pos + posOffset) {\\n                                posOffset++;\\n                            }\\n                        }\\n                        pos = pos + posOffset;\\n                        isValidRslt = isValid(pos > targetLvp ? targetLvp : pos, c, strict, fromSetValid, true);\\n                    }\\n                    if (!isValidRslt) {\\n                        resetMaskSet();\\n                        prevAltPos = getTest(decisionPos);\\n                        getMaskSet().validPositions = $.extend(true, {}, validPsClone);\\n                        if (getMaskSet().excludes[decisionPos]) {\\n                            var decisionTaker = getDecisionTaker(prevAltPos);\\n                            if (getMaskSet().excludes[decisionPos].indexOf(decisionTaker) !== -1) {\\n                                isValidRslt = alternate(pos, c, strict, fromSetValid, decisionPos - 1);\\n                                break;\\n                            }\\n                            getMaskSet().excludes[decisionPos].push(decisionTaker);\\n                            for (i = decisionPos; i < getLastValidPosition(undefined, true) + 1; i++) delete getMaskSet().validPositions[i];\\n                        } else {\\n                            isValidRslt = alternate(pos, c, strict, fromSetValid, decisionPos - 1);\\n                            break;\\n                        }\\n                    } else break;\\n                }\\n            }\\n            getMaskSet().excludes[decisionPos] = undefined;\\n            return isValidRslt;\\n        }\\n        function isValid(pos, c, strict, fromSetValid, fromAlternate, validateOnly) {\\n            function isSelection(posObj) {\\n                return isRTL ? posObj.begin - posObj.end > 1 || posObj.begin - posObj.end === 1 : posObj.end - posObj.begin > 1 || posObj.end - posObj.begin === 1;\\n            }\\n            strict = strict === true;\\n            var maskPos = pos;\\n            if (pos.begin !== undefined) {\\n                maskPos = isRTL ? pos.end : pos.begin;\\n            }\\n            function _isValid(position, c, strict) {\\n                var rslt = false;\\n                $.each(getTests(position), function(ndx, tst) {\\n                    var test = tst.match;\\n                    getBuffer(true);\\n                    rslt = test.fn != null ? test.fn.test(c, getMaskSet(), position, strict, opts, isSelection(pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && test.def !== \"\" ? {\\n                        c: getPlaceholder(position, test, true) || test.def,\\n                        pos: position\\n                    } : false;\\n                    if (rslt !== false) {\\n                        var elem = rslt.c !== undefined ? rslt.c : c, validatedPos = position;\\n                        elem = elem === opts.skipOptionalPartCharacter && test.fn === null ? getPlaceholder(position, test, true) || test.def : elem;\\n                        if (rslt.remove !== undefined) {\\n                            if (!$.isArray(rslt.remove)) rslt.remove = [ rslt.remove ];\\n                            $.each(rslt.remove.sort(function(a, b) {\\n                                return b - a;\\n                            }), function(ndx, lmnt) {\\n                                revalidateMask({\\n                                    begin: lmnt,\\n                                    end: lmnt + 1\\n                                });\\n                            });\\n                        }\\n                        if (rslt.insert !== undefined) {\\n                            if (!$.isArray(rslt.insert)) rslt.insert = [ rslt.insert ];\\n                            $.each(rslt.insert.sort(function(a, b) {\\n                                return a - b;\\n                            }), function(ndx, lmnt) {\\n                                isValid(lmnt.pos, lmnt.c, true, fromSetValid);\\n                            });\\n                        }\\n                        if (rslt !== true && rslt.pos !== undefined && rslt.pos !== position) {\\n                            validatedPos = rslt.pos;\\n                        }\\n                        if (rslt !== true && rslt.pos === undefined && rslt.c === undefined) {\\n                            return false;\\n                        }\\n                        if (!revalidateMask(pos, $.extend({}, tst, {\\n                            input: casing(elem, test, validatedPos)\\n                        }), fromSetValid, validatedPos)) {\\n                            rslt = false;\\n                        }\\n                        return false;\\n                    }\\n                });\\n                return rslt;\\n            }\\n            var result = true, positionsClone = $.extend(true, {}, getMaskSet().validPositions);\\n            if ($.isFunction(opts.preValidation) && !strict && fromSetValid !== true && validateOnly !== true) {\\n                result = opts.preValidation(getBuffer(), maskPos, c, isSelection(pos), opts, getMaskSet());\\n            }\\n            if (result === true) {\\n                trackbackPositions(undefined, maskPos, true);\\n                if (maxLength === undefined || maskPos < maxLength) {\\n                    result = _isValid(maskPos, c, strict);\\n                    if ((!strict || fromSetValid === true) && result === false && validateOnly !== true) {\\n                        var currentPosValid = getMaskSet().validPositions[maskPos];\\n                        if (currentPosValid && currentPosValid.match.fn === null && (currentPosValid.match.def === c || c === opts.skipOptionalPartCharacter)) {\\n                            result = {\\n                                caret: seekNext(maskPos)\\n                            };\\n                        } else {\\n                            if ((opts.insertMode || getMaskSet().validPositions[seekNext(maskPos)] === undefined) && (!isMask(maskPos, true) || getMaskSet().jitOffset[maskPos])) {\\n                                if (getMaskSet().jitOffset[maskPos] && getMaskSet().validPositions[seekNext(maskPos)] === undefined) {\\n                                    result = isValid(maskPos + getMaskSet().jitOffset[maskPos], c, strict);\\n                                    if (result !== false) result.caret = maskPos;\\n                                } else for (var nPos = maskPos + 1, snPos = seekNext(maskPos); nPos <= snPos; nPos++) {\\n                                    result = _isValid(nPos, c, strict);\\n                                    if (result !== false) {\\n                                        result = trackbackPositions(maskPos, result.pos !== undefined ? result.pos : nPos) || result;\\n                                        maskPos = nPos;\\n                                        break;\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                if (result === false && opts.keepStatic !== false && (opts.regex == null || isComplete(getBuffer())) && !strict && fromAlternate !== true) {\\n                    result = alternate(maskPos, c, strict, fromSetValid);\\n                }\\n                if (result === true) {\\n                    result = {\\n                        pos: maskPos\\n                    };\\n                }\\n            }\\n            if ($.isFunction(opts.postValidation) && result !== false && !strict && fromSetValid !== true && validateOnly !== true) {\\n                var postResult = opts.postValidation(getBuffer(true), pos.begin !== undefined ? isRTL ? pos.end : pos.begin : pos, result, opts);\\n                if (postResult !== undefined) {\\n                    if (postResult.refreshFromBuffer && postResult.buffer) {\\n                        var refresh = postResult.refreshFromBuffer;\\n                        refreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, postResult.buffer);\\n                    }\\n                    result = postResult === true ? result : postResult;\\n                }\\n            }\\n            if (result && result.pos === undefined) {\\n                result.pos = maskPos;\\n            }\\n            if (result === false || validateOnly === true) {\\n                resetMaskSet(true);\\n                getMaskSet().validPositions = $.extend(true, {}, positionsClone);\\n            }\\n            return result;\\n        }\\n        function trackbackPositions(originalPos, newPos, fillOnly) {\\n            var result;\\n            if (originalPos === undefined) {\\n                for (originalPos = newPos - 1; originalPos > 0; originalPos--) {\\n                    if (getMaskSet().validPositions[originalPos]) break;\\n                }\\n            }\\n            for (var ps = originalPos; ps < newPos; ps++) {\\n                if (getMaskSet().validPositions[ps] === undefined && !isMask(ps, true)) {\\n                    var vp = ps == 0 ? getTest(ps) : getMaskSet().validPositions[ps - 1];\\n                    if (vp) {\\n                        var tests = getTests(ps).slice();\\n                        if (tests[tests.length - 1].match.def === \"\") tests.pop();\\n                        var bestMatch = determineTestTemplate(ps, tests);\\n                        bestMatch = $.extend({}, bestMatch, {\\n                            input: getPlaceholder(ps, bestMatch.match, true) || bestMatch.match.def\\n                        });\\n                        bestMatch.generatedInput = true;\\n                        revalidateMask(ps, bestMatch, true);\\n                        if (fillOnly !== true) {\\n                            var cvpInput = getMaskSet().validPositions[newPos].input;\\n                            getMaskSet().validPositions[newPos] = undefined;\\n                            result = isValid(newPos, cvpInput, true, true);\\n                        }\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n        function revalidateMask(pos, validTest, fromSetValid, validatedPos) {\\n            function IsEnclosedStatic(pos, valids, selection) {\\n                var posMatch = valids[pos];\\n                if (posMatch !== undefined && (posMatch.match.fn === null && posMatch.match.optionality !== true || posMatch.input === opts.radixPoint)) {\\n                    var prevMatch = selection.begin <= pos - 1 ? valids[pos - 1] && valids[pos - 1].match.fn === null && valids[pos - 1] : valids[pos - 1], nextMatch = selection.end > pos + 1 ? valids[pos + 1] && valids[pos + 1].match.fn === null && valids[pos + 1] : valids[pos + 1];\\n                    return prevMatch && nextMatch;\\n                }\\n                return false;\\n            }\\n            var begin = pos.begin !== undefined ? pos.begin : pos, end = pos.end !== undefined ? pos.end : pos;\\n            if (pos.begin > pos.end) {\\n                begin = pos.end;\\n                end = pos.begin;\\n            }\\n            validatedPos = validatedPos !== undefined ? validatedPos : begin;\\n            if (begin !== end || opts.insertMode && getMaskSet().validPositions[validatedPos] !== undefined && fromSetValid === undefined) {\\n                var positionsClone = $.extend(true, {}, getMaskSet().validPositions), lvp = getLastValidPosition(undefined, true), i;\\n                getMaskSet().p = begin;\\n                for (i = lvp; i >= begin; i--) {\\n                    if (getMaskSet().validPositions[i] && getMaskSet().validPositions[i].match.nativeDef === \"+\") {\\n                        opts.isNegative = false;\\n                    }\\n                    delete getMaskSet().validPositions[i];\\n                }\\n                var valid = true, j = validatedPos, vps = getMaskSet().validPositions, needsValidation = false, posMatch = j, i = j;\\n                if (validTest) {\\n                    getMaskSet().validPositions[validatedPos] = $.extend(true, {}, validTest);\\n                    posMatch++;\\n                    j++;\\n                    if (begin < end) i++;\\n                }\\n                for (;i <= lvp; i++) {\\n                    var t = positionsClone[i];\\n                    if (t !== undefined && (i >= end || i >= begin && t.generatedInput !== true && IsEnclosedStatic(i, positionsClone, {\\n                        begin: begin,\\n                        end: end\\n                    }))) {\\n                        while (getTest(posMatch).match.def !== \"\") {\\n                            if (needsValidation === false && positionsClone[posMatch] && positionsClone[posMatch].match.nativeDef === t.match.nativeDef) {\\n                                getMaskSet().validPositions[posMatch] = $.extend(true, {}, positionsClone[posMatch]);\\n                                getMaskSet().validPositions[posMatch].input = t.input;\\n                                trackbackPositions(undefined, posMatch, true);\\n                                j = posMatch + 1;\\n                                valid = true;\\n                            } else if (opts.shiftPositions && positionCanMatchDefinition(posMatch, t.match.def)) {\\n                                var result = isValid(posMatch, t.input, true, true);\\n                                valid = result !== false;\\n                                j = result.caret || result.insert ? getLastValidPosition() : posMatch + 1;\\n                                needsValidation = true;\\n                            } else {\\n                                valid = t.generatedInput === true || t.input === opts.radixPoint && opts.numericInput === true;\\n                            }\\n                            if (valid) break;\\n                            if (!valid && posMatch > end && isMask(posMatch, true) && (t.match.fn !== null || posMatch > getMaskSet().maskLength)) {\\n                                break;\\n                            }\\n                            posMatch++;\\n                        }\\n                        if (getTest(posMatch).match.def == \"\") valid = false;\\n                        posMatch = j;\\n                    }\\n                    if (!valid) break;\\n                }\\n                if (!valid) {\\n                    getMaskSet().validPositions = $.extend(true, {}, positionsClone);\\n                    resetMaskSet(true);\\n                    return false;\\n                }\\n            } else if (validTest) {\\n                getMaskSet().validPositions[validatedPos] = $.extend(true, {}, validTest);\\n            }\\n            resetMaskSet(true);\\n            return true;\\n        }\\n        function isMask(pos, strict) {\\n            var test = getTestTemplate(pos).match;\\n            if (test.def === \"\") test = getTest(pos).match;\\n            if (test.fn != null) {\\n                return test.fn;\\n            }\\n            if (strict !== true && pos > -1) {\\n                var tests = getTests(pos);\\n                return tests.length > 1 + (tests[tests.length - 1].match.def === \"\" ? 1 : 0);\\n            }\\n            return false;\\n        }\\n        function seekNext(pos, newBlock) {\\n            var position = pos + 1;\\n            while (getTest(position).match.def !== \"\" && (newBlock === true && (getTest(position).match.newBlockMarker !== true || !isMask(position)) || newBlock !== true && !isMask(position))) {\\n                position++;\\n            }\\n            return position;\\n        }\\n        function seekPrevious(pos, newBlock) {\\n            var position = pos, tests;\\n            if (position <= 0) return 0;\\n            while (--position > 0 && (newBlock === true && getTest(position).match.newBlockMarker !== true || newBlock !== true && !isMask(position) && (tests = getTests(position), \\n            tests.length < 2 || tests.length === 2 && tests[1].match.def === \"\"))) {}\\n            return position;\\n        }\\n        function writeBuffer(input, buffer, caretPos, event, triggerEvents) {\\n            if (event && $.isFunction(opts.onBeforeWrite)) {\\n                var result = opts.onBeforeWrite.call(inputmask, event, buffer, caretPos, opts);\\n                if (result) {\\n                    if (result.refreshFromBuffer) {\\n                        var refresh = result.refreshFromBuffer;\\n                        refreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, result.buffer || buffer);\\n                        buffer = getBuffer(true);\\n                    }\\n                    if (caretPos !== undefined) caretPos = result.caret !== undefined ? result.caret : caretPos;\\n                }\\n            }\\n            if (input !== undefined) {\\n                input.inputmask._valueSet(buffer.join(\"\"));\\n                if (caretPos !== undefined && (event === undefined || event.type !== \"blur\")) {\\n                    caret(input, caretPos);\\n                } else renderColorMask(input, caretPos, buffer.length === 0);\\n                if (triggerEvents === true) {\\n                    var $input = $(input), nptVal = input.inputmask._valueGet();\\n                    skipInputEvent = true;\\n                    $input.trigger(\"input\");\\n                    setTimeout(function() {\\n                        if (nptVal === getBufferTemplate().join(\"\")) {\\n                            $input.trigger(\"cleared\");\\n                        } else if (isComplete(buffer) === true) {\\n                            $input.trigger(\"complete\");\\n                        }\\n                    }, 0);\\n                }\\n            }\\n        }\\n        function getPlaceholder(pos, test, returnPL) {\\n            test = test || getTest(pos).match;\\n            if (test.placeholder !== undefined || returnPL === true) {\\n                return $.isFunction(test.placeholder) ? test.placeholder(opts) : test.placeholder;\\n            } else if (test.fn === null) {\\n                if (pos > -1 && getMaskSet().validPositions[pos] === undefined) {\\n                    var tests = getTests(pos), staticAlternations = [], prevTest;\\n                    if (tests.length > 1 + (tests[tests.length - 1].match.def === \"\" ? 1 : 0)) {\\n                        for (var i = 0; i < tests.length; i++) {\\n                            if (tests[i].match.optionality !== true && tests[i].match.optionalQuantifier !== true && (tests[i].match.fn === null || (prevTest === undefined || tests[i].match.fn.test(prevTest.match.def, getMaskSet(), pos, true, opts) !== false))) {\\n                                staticAlternations.push(tests[i]);\\n                                if (tests[i].match.fn === null) prevTest = tests[i];\\n                                if (staticAlternations.length > 1) {\\n                                    if (/[0-9a-bA-Z]/.test(staticAlternations[0].match.def)) {\\n                                        return opts.placeholder.charAt(pos % opts.placeholder.length);\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                return test.def;\\n            }\\n            return opts.placeholder.charAt(pos % opts.placeholder.length);\\n        }\\n        function HandleNativePlaceholder(npt, value) {\\n            if (ie) {\\n                if (npt.inputmask._valueGet() !== value) {\\n                    var buffer = getBuffer().slice(), nptValue = npt.inputmask._valueGet();\\n                    if (nptValue !== value) {\\n                        var lvp = getLastValidPosition();\\n                        if (lvp === -1 && nptValue === getBufferTemplate().join(\"\")) {\\n                            buffer = [];\\n                        } else if (lvp !== -1) {\\n                            clearOptionalTail(buffer);\\n                        }\\n                        writeBuffer(npt, buffer);\\n                    }\\n                }\\n            } else if (npt.placeholder !== value) {\\n                npt.placeholder = value;\\n                if (npt.placeholder === \"\") npt.removeAttribute(\"placeholder\");\\n            }\\n        }\\n        var EventRuler = {\\n            on: function(input, eventName, eventHandler) {\\n                var ev = function(e) {\\n                    var that = this;\\n                    if (that.inputmask === undefined && this.nodeName !== \"FORM\") {\\n                        var imOpts = $.data(that, \"_inputmask_opts\");\\n                        if (imOpts) new Inputmask(imOpts).mask(that); else EventRuler.off(that);\\n                    } else if (e.type !== \"setvalue\" && this.nodeName !== \"FORM\" && (that.disabled || that.readOnly && !(e.type === \"keydown\" && (e.ctrlKey && e.keyCode === 67) || opts.tabThrough === false && e.keyCode === Inputmask.keyCode.TAB))) {\\n                        e.preventDefault();\\n                    } else {\\n                        switch (e.type) {\\n                          case \"input\":\\n                            if (skipInputEvent === true) {\\n                                skipInputEvent = false;\\n                                return e.preventDefault();\\n                            }\\n                            if (mobile) {\\n                                var args = arguments;\\n                                setTimeout(function() {\\n                                    eventHandler.apply(that, args);\\n                                    caret(that, that.inputmask.caretPos, undefined, true);\\n                                }, 0);\\n                                return false;\\n                            }\\n                            break;\\n\\n                          case \"keydown\":\\n                            skipKeyPressEvent = false;\\n                            skipInputEvent = false;\\n                            break;\\n\\n                          case \"keypress\":\\n                            if (skipKeyPressEvent === true) {\\n                                return e.preventDefault();\\n                            }\\n                            skipKeyPressEvent = true;\\n                            break;\\n\\n                          case \"click\":\\n                            if (iemobile || iphone) {\\n                                var args = arguments;\\n                                setTimeout(function() {\\n                                    eventHandler.apply(that, args);\\n                                }, 0);\\n                                return false;\\n                            }\\n                            break;\\n                        }\\n                        var returnVal = eventHandler.apply(that, arguments);\\n                        if (returnVal === false) {\\n                            e.preventDefault();\\n                            e.stopPropagation();\\n                        }\\n                        return returnVal;\\n                    }\\n                };\\n                input.inputmask.events[eventName] = input.inputmask.events[eventName] || [];\\n                input.inputmask.events[eventName].push(ev);\\n                if ($.inArray(eventName, [ \"submit\", \"reset\" ]) !== -1) {\\n                    if (input.form !== null) $(input.form).on(eventName, ev);\\n                } else {\\n                    $(input).on(eventName, ev);\\n                }\\n            },\\n            off: function(input, event) {\\n                if (input.inputmask && input.inputmask.events) {\\n                    var events;\\n                    if (event) {\\n                        events = [];\\n                        events[event] = input.inputmask.events[event];\\n                    } else {\\n                        events = input.inputmask.events;\\n                    }\\n                    $.each(events, function(eventName, evArr) {\\n                        while (evArr.length > 0) {\\n                            var ev = evArr.pop();\\n                            if ($.inArray(eventName, [ \"submit\", \"reset\" ]) !== -1) {\\n                                if (input.form !== null) $(input.form).off(eventName, ev);\\n                            } else {\\n                                $(input).off(eventName, ev);\\n                            }\\n                        }\\n                        delete input.inputmask.events[eventName];\\n                    });\\n                }\\n            }\\n        };\\n        var EventHandlers = {\\n            keydownEvent: function(e) {\\n                var input = this, $input = $(input), k = e.keyCode, pos = caret(input);\\n                if (k === Inputmask.keyCode.BACKSPACE || k === Inputmask.keyCode.DELETE || iphone && k === Inputmask.keyCode.BACKSPACE_SAFARI || e.ctrlKey && k === Inputmask.keyCode.X && !isInputEventSupported(\"cut\")) {\\n                    e.preventDefault();\\n                    handleRemove(input, k, pos);\\n                    writeBuffer(input, getBuffer(true), getMaskSet().p, e, input.inputmask._valueGet() !== getBuffer().join(\"\"));\\n                } else if (k === Inputmask.keyCode.END || k === Inputmask.keyCode.PAGE_DOWN) {\\n                    e.preventDefault();\\n                    var caretPos = seekNext(getLastValidPosition());\\n                    caret(input, e.shiftKey ? pos.begin : caretPos, caretPos, true);\\n                } else if (k === Inputmask.keyCode.HOME && !e.shiftKey || k === Inputmask.keyCode.PAGE_UP) {\\n                    e.preventDefault();\\n                    caret(input, 0, e.shiftKey ? pos.begin : 0, true);\\n                } else if ((opts.undoOnEscape && k === Inputmask.keyCode.ESCAPE || k === 90 && e.ctrlKey) && e.altKey !== true) {\\n                    checkVal(input, true, false, undoValue.split(\"\"));\\n                    $input.trigger(\"click\");\\n                } else if (k === Inputmask.keyCode.INSERT && !(e.shiftKey || e.ctrlKey)) {\\n                    opts.insertMode = !opts.insertMode;\\n                    input.setAttribute(\"im-insert\", opts.insertMode);\\n                } else if (opts.tabThrough === true && k === Inputmask.keyCode.TAB) {\\n                    if (e.shiftKey === true) {\\n                        if (getTest(pos.begin).match.fn === null) {\\n                            pos.begin = seekNext(pos.begin);\\n                        }\\n                        pos.end = seekPrevious(pos.begin, true);\\n                        pos.begin = seekPrevious(pos.end, true);\\n                    } else {\\n                        pos.begin = seekNext(pos.begin, true);\\n                        pos.end = seekNext(pos.begin, true);\\n                        if (pos.end < getMaskSet().maskLength) pos.end--;\\n                    }\\n                    if (pos.begin < getMaskSet().maskLength) {\\n                        e.preventDefault();\\n                        caret(input, pos.begin, pos.end);\\n                    }\\n                }\\n                opts.onKeyDown.call(this, e, getBuffer(), caret(input).begin, opts);\\n                ignorable = $.inArray(k, opts.ignorables) !== -1;\\n            },\\n            keypressEvent: function(e, checkval, writeOut, strict, ndx) {\\n                var input = this, $input = $(input), k = e.which || e.charCode || e.keyCode;\\n                if (checkval !== true && (!(e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable))) {\\n                    if (k === Inputmask.keyCode.ENTER && undoValue !== getBuffer().join(\"\")) {\\n                        undoValue = getBuffer().join(\"\");\\n                        setTimeout(function() {\\n                            $input.trigger(\"change\");\\n                        }, 0);\\n                    }\\n                    return true;\\n                } else {\\n                    if (k) {\\n                        if (k === 46 && e.shiftKey === false && opts.radixPoint !== \"\") k = opts.radixPoint.charCodeAt(0);\\n                        var pos = checkval ? {\\n                            begin: ndx,\\n                            end: ndx\\n                        } : caret(input), forwardPosition, c = String.fromCharCode(k), offset = 0;\\n                        if (opts._radixDance && opts.numericInput) {\\n                            var caretPos = getBuffer().indexOf(opts.radixPoint.charAt(0)) + 1;\\n                            if (pos.begin <= caretPos) {\\n                                if (k === opts.radixPoint.charCodeAt(0)) offset = 1;\\n                                pos.begin -= 1;\\n                                pos.end -= 1;\\n                            }\\n                        }\\n                        getMaskSet().writeOutBuffer = true;\\n                        var valResult = isValid(pos, c, strict);\\n                        if (valResult !== false) {\\n                            resetMaskSet(true);\\n                            forwardPosition = valResult.caret !== undefined ? valResult.caret : seekNext(valResult.pos.begin ? valResult.pos.begin : valResult.pos);\\n                            getMaskSet().p = forwardPosition;\\n                        }\\n                        forwardPosition = (opts.numericInput && valResult.caret === undefined ? seekPrevious(forwardPosition) : forwardPosition) + offset;\\n                        if (writeOut !== false) {\\n                            setTimeout(function() {\\n                                opts.onKeyValidation.call(input, k, valResult, opts);\\n                            }, 0);\\n                            if (getMaskSet().writeOutBuffer && valResult !== false) {\\n                                var buffer = getBuffer();\\n                                writeBuffer(input, buffer, forwardPosition, e, checkval !== true);\\n                            }\\n                        }\\n                        e.preventDefault();\\n                        if (checkval) {\\n                            if (valResult !== false) valResult.forwardPosition = forwardPosition;\\n                            return valResult;\\n                        }\\n                    }\\n                }\\n            },\\n            pasteEvent: function(e) {\\n                var input = this, ev = e.originalEvent || e, $input = $(input), inputValue = input.inputmask._valueGet(true), caretPos = caret(input), tempValue;\\n                if (isRTL) {\\n                    tempValue = caretPos.end;\\n                    caretPos.end = caretPos.begin;\\n                    caretPos.begin = tempValue;\\n                }\\n                var valueBeforeCaret = inputValue.substr(0, caretPos.begin), valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);\\n                if (valueBeforeCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(0, caretPos.begin).join(\"\")) valueBeforeCaret = \"\";\\n                if (valueAfterCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(caretPos.end).join(\"\")) valueAfterCaret = \"\";\\n                if (window.clipboardData && window.clipboardData.getData) {\\n                    inputValue = valueBeforeCaret + window.clipboardData.getData(\"Text\") + valueAfterCaret;\\n                } else if (ev.clipboardData && ev.clipboardData.getData) {\\n                    inputValue = valueBeforeCaret + ev.clipboardData.getData(\"text/plain\") + valueAfterCaret;\\n                } else return true;\\n                var pasteValue = inputValue;\\n                if ($.isFunction(opts.onBeforePaste)) {\\n                    pasteValue = opts.onBeforePaste.call(inputmask, inputValue, opts);\\n                    if (pasteValue === false) {\\n                        return e.preventDefault();\\n                    }\\n                    if (!pasteValue) {\\n                        pasteValue = inputValue;\\n                    }\\n                }\\n                checkVal(input, false, false, pasteValue.toString().split(\"\"));\\n                writeBuffer(input, getBuffer(), seekNext(getLastValidPosition()), e, undoValue !== getBuffer().join(\"\"));\\n                return e.preventDefault();\\n            },\\n            inputFallBackEvent: function(e) {\\n                function radixPointHandler(input, inputValue, caretPos) {\\n                    if (inputValue.charAt(caretPos.begin - 1) === \".\" && opts.radixPoint !== \"\") {\\n                        inputValue = inputValue.split(\"\");\\n                        inputValue[caretPos.begin - 1] = opts.radixPoint.charAt(0);\\n                        inputValue = inputValue.join(\"\");\\n                    }\\n                    return inputValue;\\n                }\\n                function ieMobileHandler(input, inputValue, caretPos) {\\n                    if (iemobile) {\\n                        var inputChar = inputValue.replace(getBuffer().join(\"\"), \"\");\\n                        if (inputChar.length === 1) {\\n                            var iv = inputValue.split(\"\");\\n                            iv.splice(caretPos.begin, 0, inputChar);\\n                            inputValue = iv.join(\"\");\\n                        }\\n                    }\\n                    return inputValue;\\n                }\\n                var input = this, inputValue = input.inputmask._valueGet();\\n                if (getBuffer().join(\"\") !== inputValue) {\\n                    var caretPos = caret(input);\\n                    inputValue = radixPointHandler(input, inputValue, caretPos);\\n                    inputValue = ieMobileHandler(input, inputValue, caretPos);\\n                    if (getBuffer().join(\"\") !== inputValue) {\\n                        var buffer = getBuffer().join(\"\"), offset = !opts.numericInput && inputValue.length > buffer.length ? -1 : 0, frontPart = inputValue.substr(0, caretPos.begin), backPart = inputValue.substr(caretPos.begin), frontBufferPart = buffer.substr(0, caretPos.begin + offset), backBufferPart = buffer.substr(caretPos.begin + offset);\\n                        var selection = caretPos, entries = \"\", isEntry = false;\\n                        if (frontPart !== frontBufferPart) {\\n                            var fpl = (isEntry = frontPart.length >= frontBufferPart.length) ? frontPart.length : frontBufferPart.length, i;\\n                            for (i = 0; frontPart.charAt(i) === frontBufferPart.charAt(i) && i < fpl; i++) ;\\n                            if (isEntry) {\\n                                selection.begin = i - offset;\\n                                entries += frontPart.slice(i, selection.end);\\n                            }\\n                        }\\n                        if (backPart !== backBufferPart) {\\n                            if (backPart.length > backBufferPart.length) {\\n                                entries += backPart.slice(0, 1);\\n                            } else {\\n                                if (backPart.length < backBufferPart.length) {\\n                                    selection.end += backBufferPart.length - backPart.length;\\n                                    if (!isEntry && opts.radixPoint !== \"\" && backPart === \"\" && frontPart.charAt(selection.begin + offset - 1) === opts.radixPoint) {\\n                                        selection.begin--;\\n                                        entries = opts.radixPoint;\\n                                    }\\n                                }\\n                            }\\n                        }\\n                        writeBuffer(input, getBuffer(), {\\n                            begin: selection.begin + offset,\\n                            end: selection.end + offset\\n                        });\\n                        if (entries.length > 0) {\\n                            $.each(entries.split(\"\"), function(ndx, entry) {\\n                                var keypress = new $.Event(\"keypress\");\\n                                keypress.which = entry.charCodeAt(0);\\n                                ignorable = false;\\n                                EventHandlers.keypressEvent.call(input, keypress);\\n                            });\\n                        } else {\\n                            if (selection.begin === selection.end - 1) {\\n                                selection.begin = seekPrevious(selection.begin + 1);\\n                                if (selection.begin === selection.end - 1) {\\n                                    caret(input, selection.begin);\\n                                } else {\\n                                    caret(input, selection.begin, selection.end);\\n                                }\\n                            }\\n                            var keydown = new $.Event(\"keydown\");\\n                            keydown.keyCode = opts.numericInput ? Inputmask.keyCode.BACKSPACE : Inputmask.keyCode.DELETE;\\n                            EventHandlers.keydownEvent.call(input, keydown);\\n                        }\\n                        e.preventDefault();\\n                    }\\n                }\\n            },\\n            beforeInputEvent: function(e) {\\n                if (e.cancelable) {\\n                    var input = this;\\n                    switch (e.inputType) {\\n                      case \"insertText\":\\n                        $.each(e.data.split(\"\"), function(ndx, entry) {\\n                            var keypress = new $.Event(\"keypress\");\\n                            keypress.which = entry.charCodeAt(0);\\n                            ignorable = false;\\n                            EventHandlers.keypressEvent.call(input, keypress);\\n                        });\\n                        return e.preventDefault();\\n\\n                      case \"deleteContentBackward\":\\n                        var keydown = new $.Event(\"keydown\");\\n                        keydown.keyCode = Inputmask.keyCode.BACKSPACE;\\n                        EventHandlers.keydownEvent.call(input, keydown);\\n                        return e.preventDefault();\\n\\n                      case \"deleteContentForward\":\\n                        var keydown = new $.Event(\"keydown\");\\n                        keydown.keyCode = Inputmask.keyCode.DELETE;\\n                        EventHandlers.keydownEvent.call(input, keydown);\\n                        return e.preventDefault();\\n                    }\\n                }\\n            },\\n            setValueEvent: function(e) {\\n                this.inputmask.refreshValue = false;\\n                var input = this, value = e && e.detail ? e.detail[0] : arguments[1], value = value || input.inputmask._valueGet(true);\\n                if ($.isFunction(opts.onBeforeMask)) value = opts.onBeforeMask.call(inputmask, value, opts) || value;\\n                value = value.split(\"\");\\n                checkVal(input, true, false, value);\\n                undoValue = getBuffer().join(\"\");\\n                if ((opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === getBufferTemplate().join(\"\")) {\\n                    input.inputmask._valueSet(\"\");\\n                }\\n            },\\n            focusEvent: function(e) {\\n                var input = this, nptValue = input.inputmask._valueGet();\\n                if (opts.showMaskOnFocus) {\\n                    if (nptValue !== getBuffer().join(\"\")) {\\n                        writeBuffer(input, getBuffer(), seekNext(getLastValidPosition()));\\n                    } else if (mouseEnter === false) {\\n                        caret(input, seekNext(getLastValidPosition()));\\n                    }\\n                }\\n                if (opts.positionCaretOnTab === true && mouseEnter === false) {\\n                    EventHandlers.clickEvent.apply(input, [ e, true ]);\\n                }\\n                undoValue = getBuffer().join(\"\");\\n            },\\n            mouseleaveEvent: function(e) {\\n                var input = this;\\n                mouseEnter = false;\\n                if (opts.clearMaskOnLostFocus && document.activeElement !== input) {\\n                    HandleNativePlaceholder(input, originalPlaceholder);\\n                }\\n            },\\n            clickEvent: function(e, tabbed) {\\n                function doRadixFocus(clickPos) {\\n                    if (opts.radixPoint !== \"\") {\\n                        var vps = getMaskSet().validPositions;\\n                        if (vps[clickPos] === undefined || vps[clickPos].input === getPlaceholder(clickPos)) {\\n                            if (clickPos < seekNext(-1)) return true;\\n                            var radixPos = $.inArray(opts.radixPoint, getBuffer());\\n                            if (radixPos !== -1) {\\n                                for (var vp in vps) {\\n                                    if (radixPos < vp && vps[vp].input !== getPlaceholder(vp)) {\\n                                        return false;\\n                                    }\\n                                }\\n                                return true;\\n                            }\\n                        }\\n                    }\\n                    return false;\\n                }\\n                var input = this;\\n                setTimeout(function() {\\n                    if (document.activeElement === input) {\\n                        var selectedCaret = caret(input);\\n                        if (tabbed) {\\n                            if (isRTL) {\\n                                selectedCaret.end = selectedCaret.begin;\\n                            } else {\\n                                selectedCaret.begin = selectedCaret.end;\\n                            }\\n                        }\\n                        if (selectedCaret.begin === selectedCaret.end) {\\n                            switch (opts.positionCaretOnClick) {\\n                              case \"none\":\\n                                break;\\n\\n                              case \"select\":\\n                                caret(input, 0, getBuffer().length);\\n                                break;\\n\\n                              case \"ignore\":\\n                                caret(input, seekNext(getLastValidPosition()));\\n                                break;\\n\\n                              case \"radixFocus\":\\n                                if (doRadixFocus(selectedCaret.begin)) {\\n                                    var radixPos = getBuffer().join(\"\").indexOf(opts.radixPoint);\\n                                    caret(input, opts.numericInput ? seekNext(radixPos) : radixPos);\\n                                    break;\\n                                }\\n\\n                              default:\\n                                var clickPosition = selectedCaret.begin, lvclickPosition = getLastValidPosition(clickPosition, true), lastPosition = seekNext(lvclickPosition);\\n                                if (clickPosition < lastPosition) {\\n                                    caret(input, !isMask(clickPosition, true) && !isMask(clickPosition - 1, true) ? seekNext(clickPosition) : clickPosition);\\n                                } else {\\n                                    var lvp = getMaskSet().validPositions[lvclickPosition], tt = getTestTemplate(lastPosition, lvp ? lvp.match.locator : undefined, lvp), placeholder = getPlaceholder(lastPosition, tt.match);\\n                                    if (placeholder !== \"\" && getBuffer()[lastPosition] !== placeholder && tt.match.optionalQuantifier !== true && tt.match.newBlockMarker !== true || !isMask(lastPosition, opts.keepStatic) && tt.match.def === placeholder) {\\n                                        var newPos = seekNext(lastPosition);\\n                                        if (clickPosition >= newPos || clickPosition === lastPosition) {\\n                                            lastPosition = newPos;\\n                                        }\\n                                    }\\n                                    caret(input, lastPosition);\\n                                }\\n                                break;\\n                            }\\n                        }\\n                    }\\n                }, 0);\\n            },\\n            cutEvent: function(e) {\\n                var input = this, $input = $(input), pos = caret(input), ev = e.originalEvent || e;\\n                var clipboardData = window.clipboardData || ev.clipboardData, clipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);\\n                clipboardData.setData(\"text\", isRTL ? clipData.reverse().join(\"\") : clipData.join(\"\"));\\n                if (document.execCommand) document.execCommand(\"copy\");\\n                handleRemove(input, Inputmask.keyCode.DELETE, pos);\\n                writeBuffer(input, getBuffer(), getMaskSet().p, e, undoValue !== getBuffer().join(\"\"));\\n            },\\n            blurEvent: function(e) {\\n                var $input = $(this), input = this;\\n                if (input.inputmask) {\\n                    HandleNativePlaceholder(input, originalPlaceholder);\\n                    var nptValue = input.inputmask._valueGet(), buffer = getBuffer().slice();\\n                    if (nptValue !== \"\" || colorMask !== undefined) {\\n                        if (opts.clearMaskOnLostFocus) {\\n                            if (getLastValidPosition() === -1 && nptValue === getBufferTemplate().join(\"\")) {\\n                                buffer = [];\\n                            } else {\\n                                clearOptionalTail(buffer);\\n                            }\\n                        }\\n                        if (isComplete(buffer) === false) {\\n                            setTimeout(function() {\\n                                $input.trigger(\"incomplete\");\\n                            }, 0);\\n                            if (opts.clearIncomplete) {\\n                                resetMaskSet();\\n                                if (opts.clearMaskOnLostFocus) {\\n                                    buffer = [];\\n                                } else {\\n                                    buffer = getBufferTemplate().slice();\\n                                }\\n                            }\\n                        }\\n                        writeBuffer(input, buffer, undefined, e);\\n                    }\\n                    if (undoValue !== getBuffer().join(\"\")) {\\n                        undoValue = buffer.join(\"\");\\n                        $input.trigger(\"change\");\\n                    }\\n                }\\n            },\\n            mouseenterEvent: function(e) {\\n                var input = this;\\n                mouseEnter = true;\\n                if (document.activeElement !== input && opts.showMaskOnHover) {\\n                    HandleNativePlaceholder(input, (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(\"\"));\\n                }\\n            },\\n            submitEvent: function(e) {\\n                if (undoValue !== getBuffer().join(\"\")) {\\n                    $el.trigger(\"change\");\\n                }\\n                if (opts.clearMaskOnLostFocus && getLastValidPosition() === -1 && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join(\"\")) {\\n                    el.inputmask._valueSet(\"\");\\n                }\\n                if (opts.clearIncomplete && isComplete(getBuffer()) === false) {\\n                    el.inputmask._valueSet(\"\");\\n                }\\n                if (opts.removeMaskOnSubmit) {\\n                    el.inputmask._valueSet(el.inputmask.unmaskedvalue(), true);\\n                    setTimeout(function() {\\n                        writeBuffer(el, getBuffer());\\n                    }, 0);\\n                }\\n            },\\n            resetEvent: function(e) {\\n                el.inputmask.refreshValue = true;\\n                setTimeout(function() {\\n                    $el.trigger(\"setvalue\");\\n                }, 0);\\n            }\\n        };\\n        function checkVal(input, writeOut, strict, nptvl, initiatingEvent) {\\n            var inputmask = this || input.inputmask, inputValue = nptvl.slice(), charCodes = \"\", initialNdx = -1, result = undefined;\\n            function isTemplateMatch(ndx, charCodes) {\\n                var charCodeNdx = getMaskTemplate(true, 0, false).slice(ndx, seekNext(ndx)).join(\"\").replace(/\\'/g, \"\").indexOf(charCodes);\\n                return charCodeNdx !== -1 && !isMask(ndx) && (getTest(ndx).match.nativeDef === charCodes.charAt(0) || getTest(ndx).match.fn === null && getTest(ndx).match.nativeDef === \"\\'\" + charCodes.charAt(0) || getTest(ndx).match.nativeDef === \" \" && (getTest(ndx + 1).match.nativeDef === charCodes.charAt(0) || getTest(ndx + 1).match.fn === null && getTest(ndx + 1).match.nativeDef === \"\\'\" + charCodes.charAt(0)));\\n            }\\n            resetMaskSet();\\n            if (!strict && opts.autoUnmask !== true) {\\n                var staticInput = getBufferTemplate().slice(0, seekNext(-1)).join(\"\"), matches = inputValue.join(\"\").match(new RegExp(\"^\" + Inputmask.escapeRegex(staticInput), \"g\"));\\n                if (matches && matches.length > 0) {\\n                    inputValue.splice(0, matches.length * staticInput.length);\\n                    initialNdx = seekNext(initialNdx);\\n                }\\n            } else {\\n                initialNdx = seekNext(initialNdx);\\n            }\\n            if (initialNdx === -1) {\\n                getMaskSet().p = seekNext(initialNdx);\\n                initialNdx = 0;\\n            } else getMaskSet().p = initialNdx;\\n            inputmask.caretPos = {\\n                begin: initialNdx\\n            };\\n            $.each(inputValue, function(ndx, charCode) {\\n                if (charCode !== undefined) {\\n                    if (getMaskSet().validPositions[ndx] === undefined && inputValue[ndx] === getPlaceholder(ndx) && isMask(ndx, true) && isValid(ndx, inputValue[ndx], true, undefined, undefined, true) === false) {\\n                        getMaskSet().p++;\\n                    } else {\\n                        var keypress = new $.Event(\"_checkval\");\\n                        keypress.which = charCode.charCodeAt(0);\\n                        charCodes += charCode;\\n                        var lvp = getLastValidPosition(undefined, true);\\n                        if (!isTemplateMatch(initialNdx, charCodes)) {\\n                            result = EventHandlers.keypressEvent.call(input, keypress, true, false, strict, inputmask.caretPos.begin);\\n                            if (result) {\\n                                initialNdx = inputmask.caretPos.begin + 1;\\n                                charCodes = \"\";\\n                            }\\n                        } else {\\n                            result = EventHandlers.keypressEvent.call(input, keypress, true, false, strict, lvp + 1);\\n                        }\\n                        if (result) {\\n                            writeBuffer(undefined, getBuffer(), result.forwardPosition, keypress, false);\\n                            inputmask.caretPos = {\\n                                begin: result.forwardPosition,\\n                                end: result.forwardPosition\\n                            };\\n                        }\\n                    }\\n                }\\n            });\\n            if (writeOut) writeBuffer(input, getBuffer(), result ? result.forwardPosition : undefined, initiatingEvent || new $.Event(\"checkval\"), initiatingEvent && initiatingEvent.type === \"input\");\\n        }\\n        function unmaskedvalue(input) {\\n            if (input) {\\n                if (input.inputmask === undefined) {\\n                    return input.value;\\n                }\\n                if (input.inputmask && input.inputmask.refreshValue) {\\n                    EventHandlers.setValueEvent.call(input);\\n                }\\n            }\\n            var umValue = [], vps = getMaskSet().validPositions;\\n            for (var pndx in vps) {\\n                if (vps[pndx].match && vps[pndx].match.fn != null) {\\n                    umValue.push(vps[pndx].input);\\n                }\\n            }\\n            var unmaskedValue = umValue.length === 0 ? \"\" : (isRTL ? umValue.reverse() : umValue).join(\"\");\\n            if ($.isFunction(opts.onUnMask)) {\\n                var bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(\"\");\\n                unmaskedValue = opts.onUnMask.call(inputmask, bufferValue, unmaskedValue, opts);\\n            }\\n            return unmaskedValue;\\n        }\\n        function caret(input, begin, end, notranslate) {\\n            function translatePosition(pos) {\\n                if (isRTL && typeof pos === \"number\" && (!opts.greedy || opts.placeholder !== \"\") && el) {\\n                    pos = el.inputmask._valueGet().length - pos;\\n                }\\n                return pos;\\n            }\\n            var range;\\n            if (begin !== undefined) {\\n                if ($.isArray(begin)) {\\n                    end = isRTL ? begin[0] : begin[1];\\n                    begin = isRTL ? begin[1] : begin[0];\\n                }\\n                if (begin.begin !== undefined) {\\n                    end = isRTL ? begin.begin : begin.end;\\n                    begin = isRTL ? begin.end : begin.begin;\\n                }\\n                if (typeof begin === \"number\") {\\n                    begin = notranslate ? begin : translatePosition(begin);\\n                    end = notranslate ? end : translatePosition(end);\\n                    end = typeof end == \"number\" ? end : begin;\\n                    var scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;\\n                    input.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0;\\n                    input.inputmask.caretPos = {\\n                        begin: begin,\\n                        end: end\\n                    };\\n                    if (input === document.activeElement) {\\n                        if (\"selectionStart\" in input) {\\n                            input.selectionStart = begin;\\n                            input.selectionEnd = end;\\n                        } else if (window.getSelection) {\\n                            range = document.createRange();\\n                            if (input.firstChild === undefined || input.firstChild === null) {\\n                                var textNode = document.createTextNode(\"\");\\n                                input.appendChild(textNode);\\n                            }\\n                            range.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length);\\n                            range.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length);\\n                            range.collapse(true);\\n                            var sel = window.getSelection();\\n                            sel.removeAllRanges();\\n                            sel.addRange(range);\\n                        } else if (input.createTextRange) {\\n                            range = input.createTextRange();\\n                            range.collapse(true);\\n                            range.moveEnd(\"character\", end);\\n                            range.moveStart(\"character\", begin);\\n                            range.select();\\n                        }\\n                        renderColorMask(input, {\\n                            begin: begin,\\n                            end: end\\n                        });\\n                    }\\n                }\\n            } else {\\n                if (\"selectionStart\" in input) {\\n                    begin = input.selectionStart;\\n                    end = input.selectionEnd;\\n                } else if (window.getSelection) {\\n                    range = window.getSelection().getRangeAt(0);\\n                    if (range.commonAncestorContainer.parentNode === input || range.commonAncestorContainer === input) {\\n                        begin = range.startOffset;\\n                        end = range.endOffset;\\n                    }\\n                } else if (document.selection && document.selection.createRange) {\\n                    range = document.selection.createRange();\\n                    begin = 0 - range.duplicate().moveStart(\"character\", -input.inputmask._valueGet().length);\\n                    end = begin + range.text.length;\\n                }\\n                return {\\n                    begin: notranslate ? begin : translatePosition(begin),\\n                    end: notranslate ? end : translatePosition(end)\\n                };\\n            }\\n        }\\n        function determineLastRequiredPosition(returnDefinition) {\\n            var buffer = getMaskTemplate(true, getLastValidPosition(), true, true), bl = buffer.length, pos, lvp = getLastValidPosition(), positions = {}, lvTest = getMaskSet().validPositions[lvp], ndxIntlzr = lvTest !== undefined ? lvTest.locator.slice() : undefined, testPos;\\n            for (pos = lvp + 1; pos < buffer.length; pos++) {\\n                testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);\\n                ndxIntlzr = testPos.locator.slice();\\n                positions[pos] = $.extend(true, {}, testPos);\\n            }\\n            var lvTestAlt = lvTest && lvTest.alternation !== undefined ? lvTest.locator[lvTest.alternation] : undefined;\\n            for (pos = bl - 1; pos > lvp; pos--) {\\n                testPos = positions[pos];\\n                if ((testPos.match.optionality || testPos.match.optionalQuantifier && testPos.match.newBlockMarker || lvTestAlt && (lvTestAlt !== positions[pos].locator[lvTest.alternation] && testPos.match.fn != null || testPos.match.fn === null && testPos.locator[lvTest.alternation] && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(\",\"), lvTestAlt.toString().split(\",\")) && getTests(pos)[0].def !== \"\")) && buffer[pos] === getPlaceholder(pos, testPos.match)) {\\n                    bl--;\\n                } else break;\\n            }\\n            return returnDefinition ? {\\n                l: bl,\\n                def: positions[bl] ? positions[bl].match : undefined\\n            } : bl;\\n        }\\n        function clearOptionalTail(buffer) {\\n            buffer.length = 0;\\n            var template = getMaskTemplate(true, 0, true, undefined, true), lmnt, validPos;\\n            while (lmnt = template.shift(), lmnt !== undefined) buffer.push(lmnt);\\n            return buffer;\\n        }\\n        function isComplete(buffer) {\\n            if ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts);\\n            if (opts.repeat === \"*\") return undefined;\\n            var complete = false, lrp = determineLastRequiredPosition(true), aml = seekPrevious(lrp.l);\\n            if (lrp.def === undefined || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {\\n                complete = true;\\n                for (var i = 0; i <= aml; i++) {\\n                    var test = getTestTemplate(i).match;\\n                    if (test.fn !== null && getMaskSet().validPositions[i] === undefined && test.optionality !== true && test.optionalQuantifier !== true || test.fn === null && buffer[i] !== getPlaceholder(i, test)) {\\n                        complete = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            return complete;\\n        }\\n        function handleRemove(input, k, pos, strict, fromIsValid) {\\n            if (opts.numericInput || isRTL) {\\n                if (k === Inputmask.keyCode.BACKSPACE) {\\n                    k = Inputmask.keyCode.DELETE;\\n                } else if (k === Inputmask.keyCode.DELETE) {\\n                    k = Inputmask.keyCode.BACKSPACE;\\n                }\\n                if (isRTL) {\\n                    var pend = pos.end;\\n                    pos.end = pos.begin;\\n                    pos.begin = pend;\\n                }\\n            }\\n            if (k === Inputmask.keyCode.BACKSPACE && pos.end - pos.begin < 1) {\\n                pos.begin = seekPrevious(pos.begin);\\n                if (getMaskSet().validPositions[pos.begin] !== undefined && getMaskSet().validPositions[pos.begin].input === opts.groupSeparator) {\\n                    pos.begin--;\\n                }\\n            } else if (k === Inputmask.keyCode.DELETE && pos.begin === pos.end) {\\n                pos.end = isMask(pos.end, true) && (getMaskSet().validPositions[pos.end] && getMaskSet().validPositions[pos.end].input !== opts.radixPoint) ? pos.end + 1 : seekNext(pos.end) + 1;\\n                if (getMaskSet().validPositions[pos.begin] !== undefined && getMaskSet().validPositions[pos.begin].input === opts.groupSeparator) {\\n                    pos.end++;\\n                }\\n            }\\n            revalidateMask(pos);\\n            if (strict !== true && opts.keepStatic !== false || opts.regex !== null) {\\n                var result = alternate(true);\\n                if (result) {\\n                    var newPos = result.caret !== undefined ? result.caret : result.pos ? seekNext(result.pos.begin ? result.pos.begin : result.pos) : getLastValidPosition(-1, true);\\n                    if (k !== Inputmask.keyCode.DELETE || pos.begin > newPos) {\\n                        pos.begin == newPos;\\n                    }\\n                }\\n            }\\n            var lvp = getLastValidPosition(pos.begin, true);\\n            if (lvp < pos.begin || pos.begin === -1) {\\n                getMaskSet().p = seekNext(lvp);\\n            } else if (strict !== true) {\\n                getMaskSet().p = pos.begin;\\n                if (fromIsValid !== true) {\\n                    while (getMaskSet().p < lvp && getMaskSet().validPositions[getMaskSet().p] === undefined) {\\n                        getMaskSet().p++;\\n                    }\\n                }\\n            }\\n        }\\n        function initializeColorMask(input) {\\n            var computedStyle = (input.ownerDocument.defaultView || window).getComputedStyle(input, null);\\n            function findCaretPos(clientx) {\\n                var e = document.createElement(\"span\"), caretPos;\\n                for (var style in computedStyle) {\\n                    if (isNaN(style) && style.indexOf(\"font\") !== -1) {\\n                        e.style[style] = computedStyle[style];\\n                    }\\n                }\\n                e.style.textTransform = computedStyle.textTransform;\\n                e.style.letterSpacing = computedStyle.letterSpacing;\\n                e.style.position = \"absolute\";\\n                e.style.height = \"auto\";\\n                e.style.width = \"auto\";\\n                e.style.visibility = \"hidden\";\\n                e.style.whiteSpace = \"nowrap\";\\n                document.body.appendChild(e);\\n                var inputText = input.inputmask._valueGet(), previousWidth = 0, itl;\\n                for (caretPos = 0, itl = inputText.length; caretPos <= itl; caretPos++) {\\n                    e.innerHTML += inputText.charAt(caretPos) || \"_\";\\n                    if (e.offsetWidth >= clientx) {\\n                        var offset1 = clientx - previousWidth;\\n                        var offset2 = e.offsetWidth - clientx;\\n                        e.innerHTML = inputText.charAt(caretPos);\\n                        offset1 -= e.offsetWidth / 3;\\n                        caretPos = offset1 < offset2 ? caretPos - 1 : caretPos;\\n                        break;\\n                    }\\n                    previousWidth = e.offsetWidth;\\n                }\\n                document.body.removeChild(e);\\n                return caretPos;\\n            }\\n            var template = document.createElement(\"div\");\\n            template.style.width = computedStyle.width;\\n            template.style.textAlign = computedStyle.textAlign;\\n            colorMask = document.createElement(\"div\");\\n            input.inputmask.colorMask = colorMask;\\n            colorMask.className = \"im-colormask\";\\n            input.parentNode.insertBefore(colorMask, input);\\n            input.parentNode.removeChild(input);\\n            colorMask.appendChild(input);\\n            colorMask.appendChild(template);\\n            input.style.left = template.offsetLeft + \"px\";\\n            $(colorMask).on(\"mouseleave\", function(e) {\\n                return EventHandlers.mouseleaveEvent.call(input, [ e ]);\\n            });\\n            $(colorMask).on(\"mouseenter\", function(e) {\\n                return EventHandlers.mouseenterEvent.call(input, [ e ]);\\n            });\\n            $(colorMask).on(\"click\", function(e) {\\n                caret(input, findCaretPos(e.clientX));\\n                return EventHandlers.clickEvent.call(input, [ e ]);\\n            });\\n        }\\n        Inputmask.prototype.positionColorMask = function(input, template) {\\n            input.style.left = template.offsetLeft + \"px\";\\n        };\\n        function renderColorMask(input, caretPos, clear) {\\n            var maskTemplate = [], isStatic = false, test, testPos, ndxIntlzr, pos = 0;\\n            function setEntry(entry) {\\n                if (entry === undefined) entry = \"\";\\n                if (!isStatic && (test.fn === null || testPos.input === undefined)) {\\n                    isStatic = true;\\n                    maskTemplate.push(\"<span class=\\'im-static\\'>\" + entry);\\n                } else if (isStatic && (test.fn !== null && testPos.input !== undefined || test.def === \"\")) {\\n                    isStatic = false;\\n                    var mtl = maskTemplate.length;\\n                    maskTemplate[mtl - 1] = maskTemplate[mtl - 1] + \"</span>\";\\n                    maskTemplate.push(entry);\\n                } else maskTemplate.push(entry);\\n            }\\n            function setCaret() {\\n                if (document.activeElement === input) {\\n                    maskTemplate.splice(caretPos.begin, 0, caretPos.begin === caretPos.end || caretPos.end > getMaskSet().maskLength ? \\'<mark class=\"im-caret\" style=\"border-right-width: 1px;border-right-style: solid;\">\\' : \\'<mark class=\"im-caret-select\">\\');\\n                    maskTemplate.splice(caretPos.end + 1, 0, \"</mark>\");\\n                }\\n            }\\n            if (colorMask !== undefined) {\\n                var buffer = getBuffer();\\n                if (caretPos === undefined) {\\n                    caretPos = caret(input);\\n                } else if (caretPos.begin === undefined) {\\n                    caretPos = {\\n                        begin: caretPos,\\n                        end: caretPos\\n                    };\\n                }\\n                if (clear !== true) {\\n                    var lvp = getLastValidPosition();\\n                    do {\\n                        if (getMaskSet().validPositions[pos]) {\\n                            testPos = getMaskSet().validPositions[pos];\\n                            test = testPos.match;\\n                            ndxIntlzr = testPos.locator.slice();\\n                            setEntry(buffer[pos]);\\n                        } else {\\n                            testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);\\n                            test = testPos.match;\\n                            ndxIntlzr = testPos.locator.slice();\\n                            if (opts.jitMasking === false || pos < lvp || typeof opts.jitMasking === \"number\" && isFinite(opts.jitMasking) && opts.jitMasking > pos) {\\n                                setEntry(getPlaceholder(pos, test));\\n                            } else isStatic = false;\\n                        }\\n                        pos++;\\n                    } while ((maxLength === undefined || pos < maxLength) && (test.fn !== null || test.def !== \"\") || lvp > pos || isStatic);\\n                    if (isStatic) setEntry();\\n                    setCaret();\\n                }\\n                var template = colorMask.getElementsByTagName(\"div\")[0];\\n                template.innerHTML = maskTemplate.join(\"\");\\n                input.inputmask.positionColorMask(input, template);\\n            }\\n        }\\n        function mask(elem) {\\n            function isElementTypeSupported(input, opts) {\\n                function patchValueProperty(npt) {\\n                    var valueGet;\\n                    var valueSet;\\n                    function patchValhook(type) {\\n                        if ($.valHooks && ($.valHooks[type] === undefined || $.valHooks[type].inputmaskpatch !== true)) {\\n                            var valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function(elem) {\\n                                return elem.value;\\n                            };\\n                            var valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function(elem, value) {\\n                                elem.value = value;\\n                                return elem;\\n                            };\\n                            $.valHooks[type] = {\\n                                get: function(elem) {\\n                                    if (elem.inputmask) {\\n                                        if (elem.inputmask.opts.autoUnmask) {\\n                                            return elem.inputmask.unmaskedvalue();\\n                                        } else {\\n                                            var result = valhookGet(elem);\\n                                            return getLastValidPosition(undefined, undefined, elem.inputmask.maskset.validPositions) !== -1 || opts.nullable !== true ? result : \"\";\\n                                        }\\n                                    } else return valhookGet(elem);\\n                                },\\n                                set: function(elem, value) {\\n                                    var $elem = $(elem), result;\\n                                    result = valhookSet(elem, value);\\n                                    if (elem.inputmask) {\\n                                        $elem.trigger(\"setvalue\", [ value ]);\\n                                    }\\n                                    return result;\\n                                },\\n                                inputmaskpatch: true\\n                            };\\n                        }\\n                    }\\n                    function getter() {\\n                        if (this.inputmask) {\\n                            return this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : getLastValidPosition() !== -1 || opts.nullable !== true ? document.activeElement === this && opts.clearMaskOnLostFocus ? (isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join(\"\") : valueGet.call(this) : \"\";\\n                        } else return valueGet.call(this);\\n                    }\\n                    function setter(value) {\\n                        valueSet.call(this, value);\\n                        if (this.inputmask) {\\n                            $(this).trigger(\"setvalue\", [ value ]);\\n                        }\\n                    }\\n                    function installNativeValueSetFallback(npt) {\\n                        EventRuler.on(npt, \"mouseenter\", function(event) {\\n                            var $input = $(this), input = this, value = input.inputmask._valueGet();\\n                            if (value !== getBuffer().join(\"\")) {\\n                                $input.trigger(\"setvalue\");\\n                            }\\n                        });\\n                    }\\n                    if (!npt.inputmask.__valueGet) {\\n                        if (opts.noValuePatching !== true) {\\n                            if (Object.getOwnPropertyDescriptor) {\\n                                if (typeof Object.getPrototypeOf !== \"function\") {\\n                                    Object.getPrototypeOf = typeof \"test\".__proto__ === \"object\" ? function(object) {\\n                                        return object.__proto__;\\n                                    } : function(object) {\\n                                        return object.constructor.prototype;\\n                                    };\\n                                }\\n                                var valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), \"value\") : undefined;\\n                                if (valueProperty && valueProperty.get && valueProperty.set) {\\n                                    valueGet = valueProperty.get;\\n                                    valueSet = valueProperty.set;\\n                                    Object.defineProperty(npt, \"value\", {\\n                                        get: getter,\\n                                        set: setter,\\n                                        configurable: true\\n                                    });\\n                                } else if (npt.tagName !== \"INPUT\") {\\n                                    valueGet = function() {\\n                                        return this.textContent;\\n                                    };\\n                                    valueSet = function(value) {\\n                                        this.textContent = value;\\n                                    };\\n                                    Object.defineProperty(npt, \"value\", {\\n                                        get: getter,\\n                                        set: setter,\\n                                        configurable: true\\n                                    });\\n                                }\\n                            } else if (document.__lookupGetter__ && npt.__lookupGetter__(\"value\")) {\\n                                valueGet = npt.__lookupGetter__(\"value\");\\n                                valueSet = npt.__lookupSetter__(\"value\");\\n                                npt.__defineGetter__(\"value\", getter);\\n                                npt.__defineSetter__(\"value\", setter);\\n                            }\\n                            npt.inputmask.__valueGet = valueGet;\\n                            npt.inputmask.__valueSet = valueSet;\\n                        }\\n                        npt.inputmask._valueGet = function(overruleRTL) {\\n                            return isRTL && overruleRTL !== true ? valueGet.call(this.el).split(\"\").reverse().join(\"\") : valueGet.call(this.el);\\n                        };\\n                        npt.inputmask._valueSet = function(value, overruleRTL) {\\n                            valueSet.call(this.el, value === null || value === undefined ? \"\" : overruleRTL !== true && isRTL ? value.split(\"\").reverse().join(\"\") : value);\\n                        };\\n                        if (valueGet === undefined) {\\n                            valueGet = function() {\\n                                return this.value;\\n                            };\\n                            valueSet = function(value) {\\n                                this.value = value;\\n                            };\\n                            patchValhook(npt.type);\\n                            installNativeValueSetFallback(npt);\\n                        }\\n                    }\\n                }\\n                var elementType = input.getAttribute(\"type\");\\n                var isSupported = input.tagName === \"INPUT\" && $.inArray(elementType, opts.supportsInputType) !== -1 || input.isContentEditable || input.tagName === \"TEXTAREA\";\\n                if (!isSupported) {\\n                    if (input.tagName === \"INPUT\") {\\n                        var el = document.createElement(\"input\");\\n                        el.setAttribute(\"type\", elementType);\\n                        isSupported = el.type === \"text\";\\n                        el = null;\\n                    } else isSupported = \"partial\";\\n                }\\n                if (isSupported !== false) {\\n                    patchValueProperty(input);\\n                } else input.inputmask = undefined;\\n                return isSupported;\\n            }\\n            EventRuler.off(elem);\\n            var isSupported = isElementTypeSupported(elem, opts);\\n            if (isSupported !== false) {\\n                el = elem;\\n                $el = $(el);\\n                originalPlaceholder = el.placeholder;\\n                maxLength = el !== undefined ? el.maxLength : undefined;\\n                if (maxLength === -1) maxLength = undefined;\\n                if (opts.colorMask === true) {\\n                    initializeColorMask(el);\\n                }\\n                if (mobile) {\\n                    if (\"inputmode\" in el) {\\n                        el.inputmode = opts.inputmode;\\n                        el.setAttribute(\"inputmode\", opts.inputmode);\\n                    }\\n                    if (opts.disablePredictiveText === true) {\\n                        if (\"autocorrect\" in el) {\\n                            el.autocorrect = false;\\n                        } else {\\n                            if (opts.colorMask !== true) {\\n                                initializeColorMask(el);\\n                            }\\n                            el.type = \"password\";\\n                        }\\n                    }\\n                }\\n                if (isSupported === true) {\\n                    el.setAttribute(\"im-insert\", opts.insertMode);\\n                    EventRuler.on(el, \"submit\", EventHandlers.submitEvent);\\n                    EventRuler.on(el, \"reset\", EventHandlers.resetEvent);\\n                    EventRuler.on(el, \"blur\", EventHandlers.blurEvent);\\n                    EventRuler.on(el, \"focus\", EventHandlers.focusEvent);\\n                    if (opts.colorMask !== true) {\\n                        EventRuler.on(el, \"click\", EventHandlers.clickEvent);\\n                        EventRuler.on(el, \"mouseleave\", EventHandlers.mouseleaveEvent);\\n                        EventRuler.on(el, \"mouseenter\", EventHandlers.mouseenterEvent);\\n                    }\\n                    EventRuler.on(el, \"paste\", EventHandlers.pasteEvent);\\n                    EventRuler.on(el, \"cut\", EventHandlers.cutEvent);\\n                    EventRuler.on(el, \"complete\", opts.oncomplete);\\n                    EventRuler.on(el, \"incomplete\", opts.onincomplete);\\n                    EventRuler.on(el, \"cleared\", opts.oncleared);\\n                    if (!mobile && opts.inputEventOnly !== true) {\\n                        EventRuler.on(el, \"keydown\", EventHandlers.keydownEvent);\\n                        EventRuler.on(el, \"keypress\", EventHandlers.keypressEvent);\\n                    } else {\\n                        el.removeAttribute(\"maxLength\");\\n                    }\\n                    EventRuler.on(el, \"input\", EventHandlers.inputFallBackEvent);\\n                    EventRuler.on(el, \"beforeinput\", EventHandlers.beforeInputEvent);\\n                }\\n                EventRuler.on(el, \"setvalue\", EventHandlers.setValueEvent);\\n                undoValue = getBufferTemplate().join(\"\");\\n                if (el.inputmask._valueGet(true) !== \"\" || opts.clearMaskOnLostFocus === false || document.activeElement === el) {\\n                    var initialValue = $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(inputmask, el.inputmask._valueGet(true), opts) || el.inputmask._valueGet(true) : el.inputmask._valueGet(true);\\n                    if (initialValue !== \"\") checkVal(el, true, false, initialValue.split(\"\"));\\n                    var buffer = getBuffer().slice();\\n                    undoValue = buffer.join(\"\");\\n                    if (isComplete(buffer) === false) {\\n                        if (opts.clearIncomplete) {\\n                            resetMaskSet();\\n                        }\\n                    }\\n                    if (opts.clearMaskOnLostFocus && document.activeElement !== el) {\\n                        if (getLastValidPosition() === -1) {\\n                            buffer = [];\\n                        } else {\\n                            clearOptionalTail(buffer);\\n                        }\\n                    }\\n                    if (opts.clearMaskOnLostFocus === false || opts.showMaskOnFocus && document.activeElement === el || el.inputmask._valueGet(true) !== \"\") writeBuffer(el, buffer);\\n                    if (document.activeElement === el) {\\n                        caret(el, seekNext(getLastValidPosition()));\\n                    }\\n                }\\n            }\\n        }\\n        var valueBuffer;\\n        if (actionObj !== undefined) {\\n            switch (actionObj.action) {\\n              case \"isComplete\":\\n                el = actionObj.el;\\n                return isComplete(getBuffer());\\n\\n              case \"unmaskedvalue\":\\n                if (el === undefined || actionObj.value !== undefined) {\\n                    valueBuffer = actionObj.value;\\n                    valueBuffer = ($.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(inputmask, valueBuffer, opts) || valueBuffer : valueBuffer).split(\"\");\\n                    checkVal.call(this, undefined, false, false, valueBuffer);\\n                    if ($.isFunction(opts.onBeforeWrite)) opts.onBeforeWrite.call(inputmask, undefined, getBuffer(), 0, opts);\\n                }\\n                return unmaskedvalue(el);\\n\\n              case \"mask\":\\n                mask(el);\\n                break;\\n\\n              case \"format\":\\n                valueBuffer = ($.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(inputmask, actionObj.value, opts) || actionObj.value : actionObj.value).split(\"\");\\n                checkVal.call(this, undefined, true, false, valueBuffer);\\n                if (actionObj.metadata) {\\n                    return {\\n                        value: isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\"),\\n                        metadata: maskScope.call(this, {\\n                            action: \"getmetadata\"\\n                        }, maskset, opts)\\n                    };\\n                }\\n                return isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\");\\n\\n              case \"isValid\":\\n                if (actionObj.value) {\\n                    valueBuffer = actionObj.value.split(\"\");\\n                    checkVal.call(this, undefined, true, true, valueBuffer);\\n                } else {\\n                    actionObj.value = getBuffer().join(\"\");\\n                }\\n                var buffer = getBuffer();\\n                var rl = determineLastRequiredPosition(), lmib = buffer.length - 1;\\n                for (;lmib > rl; lmib--) {\\n                    if (isMask(lmib)) break;\\n                }\\n                buffer.splice(rl, lmib + 1 - rl);\\n                return isComplete(buffer) && actionObj.value === getBuffer().join(\"\");\\n\\n              case \"getemptymask\":\\n                return getBufferTemplate().join(\"\");\\n\\n              case \"remove\":\\n                if (el && el.inputmask) {\\n                    $.data(el, \"_inputmask_opts\", null);\\n                    $el = $(el);\\n                    el.inputmask._valueSet(opts.autoUnmask ? unmaskedvalue(el) : el.inputmask._valueGet(true));\\n                    EventRuler.off(el);\\n                    if (el.inputmask.colorMask) {\\n                        colorMask = el.inputmask.colorMask;\\n                        colorMask.removeChild(el);\\n                        colorMask.parentNode.insertBefore(el, colorMask);\\n                        colorMask.parentNode.removeChild(colorMask);\\n                    }\\n                    var valueProperty;\\n                    if (Object.getOwnPropertyDescriptor && Object.getPrototypeOf) {\\n                        valueProperty = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), \"value\");\\n                        if (valueProperty) {\\n                            if (el.inputmask.__valueGet) {\\n                                Object.defineProperty(el, \"value\", {\\n                                    get: el.inputmask.__valueGet,\\n                                    set: el.inputmask.__valueSet,\\n                                    configurable: true\\n                                });\\n                            }\\n                        }\\n                    } else if (document.__lookupGetter__ && el.__lookupGetter__(\"value\")) {\\n                        if (el.inputmask.__valueGet) {\\n                            el.__defineGetter__(\"value\", el.inputmask.__valueGet);\\n                            el.__defineSetter__(\"value\", el.inputmask.__valueSet);\\n                        }\\n                    }\\n                    el.inputmask = undefined;\\n                }\\n                return el;\\n                break;\\n\\n              case \"getmetadata\":\\n                if ($.isArray(maskset.metadata)) {\\n                    var maskTarget = getMaskTemplate(true, 0, false).join(\"\");\\n                    $.each(maskset.metadata, function(ndx, mtdt) {\\n                        if (mtdt.mask === maskTarget) {\\n                            maskTarget = mtdt;\\n                            return false;\\n                        }\\n                    });\\n                    return maskTarget;\\n                }\\n                return maskset.metadata;\\n            }\\n        }\\n    }\\n    return Inputmask;\\n});\\n\\n//# sourceURL=webpack:///./node_modules/inputmask/dist/inputmask/inputmask.js?')},\"./node_modules/inputmask/dist/inputmask/inputmask.numeric.extensions.js\":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\\n* inputmask.numeric.extensions.js\\n* https://github.com/RobinHerbots/Inputmask\\n* Copyright (c) 2010 - 2018 Robin Herbots\\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\\n* Version: 4.0.4\\n*/\\n\\n(function(factory) {\\n    if (true) {\\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! ./inputmask */ \"./node_modules/inputmask/dist/inputmask/inputmask.js\") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \\'function\\' ?\\n\\t\\t\\t\\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n    } else {}\\n})(function(Inputmask) {\\n    var $ = Inputmask.dependencyLib;\\n    function autoEscape(txt, opts) {\\n        var escapedTxt = \"\";\\n        for (var i = 0; i < txt.length; i++) {\\n            if (Inputmask.prototype.definitions[txt.charAt(i)] || opts.definitions[txt.charAt(i)] || opts.optionalmarker.start === txt.charAt(i) || opts.optionalmarker.end === txt.charAt(i) || opts.quantifiermarker.start === txt.charAt(i) || opts.quantifiermarker.end === txt.charAt(i) || opts.groupmarker.start === txt.charAt(i) || opts.groupmarker.end === txt.charAt(i) || opts.alternatormarker === txt.charAt(i)) {\\n                escapedTxt += \"\\\\\\\\\" + txt.charAt(i);\\n            } else escapedTxt += txt.charAt(i);\\n        }\\n        return escapedTxt;\\n    }\\n    function alignDigits(buffer, digits, opts) {\\n        if (digits > 0) {\\n            var radixPosition = $.inArray(opts.radixPoint, buffer);\\n            if (radixPosition === -1) {\\n                buffer.push(opts.radixPoint);\\n                radixPosition = buffer.length - 1;\\n            }\\n            for (var i = 1; i <= digits; i++) {\\n                buffer[radixPosition + i] = buffer[radixPosition + i] || \"0\";\\n            }\\n        }\\n        return buffer;\\n    }\\n    Inputmask.extendAliases({\\n        numeric: {\\n            mask: function(opts) {\\n                if (opts.repeat !== 0 && isNaN(opts.integerDigits)) {\\n                    opts.integerDigits = opts.repeat;\\n                }\\n                opts.repeat = 0;\\n                if (opts.groupSeparator === opts.radixPoint && opts.digits && opts.digits !== \"0\") {\\n                    if (opts.radixPoint === \".\") {\\n                        opts.groupSeparator = \",\";\\n                    } else if (opts.radixPoint === \",\") {\\n                        opts.groupSeparator = \".\";\\n                    } else opts.groupSeparator = \"\";\\n                }\\n                if (opts.groupSeparator === \" \") {\\n                    opts.skipOptionalPartCharacter = undefined;\\n                }\\n                opts.autoGroup = opts.autoGroup && opts.groupSeparator !== \"\";\\n                if (opts.autoGroup) {\\n                    if (typeof opts.groupSize == \"string\" && isFinite(opts.groupSize)) opts.groupSize = parseInt(opts.groupSize);\\n                    if (isFinite(opts.integerDigits)) {\\n                        var seps = Math.floor(opts.integerDigits / opts.groupSize);\\n                        var mod = opts.integerDigits % opts.groupSize;\\n                        opts.integerDigits = parseInt(opts.integerDigits) + (mod === 0 ? seps - 1 : seps);\\n                        if (opts.integerDigits < 1) {\\n                            opts.integerDigits = \"*\";\\n                        }\\n                    }\\n                }\\n                if (opts.placeholder.length > 1) {\\n                    opts.placeholder = opts.placeholder.charAt(0);\\n                }\\n                if (opts.positionCaretOnClick === \"radixFocus\" && (opts.placeholder === \"\" && opts.integerOptional === false)) {\\n                    opts.positionCaretOnClick = \"lvp\";\\n                }\\n                opts.definitions[\";\"] = opts.definitions[\"~\"];\\n                opts.definitions[\";\"].definitionSymbol = \"~\";\\n                if (opts.numericInput === true) {\\n                    opts.positionCaretOnClick = opts.positionCaretOnClick === \"radixFocus\" ? \"lvp\" : opts.positionCaretOnClick;\\n                    opts.digitsOptional = false;\\n                    if (isNaN(opts.digits)) opts.digits = 2;\\n                    opts.decimalProtect = false;\\n                }\\n                var mask = \"[+]\";\\n                mask += autoEscape(opts.prefix, opts);\\n                if (opts.integerOptional === true) {\\n                    mask += \"~{1,\" + opts.integerDigits + \"}\";\\n                } else mask += \"~{\" + opts.integerDigits + \"}\";\\n                if (opts.digits !== undefined) {\\n                    var radixDef = opts.decimalProtect ? \":\" : opts.radixPoint;\\n                    var dq = opts.digits.toString().split(\",\");\\n                    if (isFinite(dq[0]) && dq[1] && isFinite(dq[1])) {\\n                        mask += radixDef + \";{\" + opts.digits + \"}\";\\n                    } else if (isNaN(opts.digits) || parseInt(opts.digits) > 0) {\\n                        if (opts.digitsOptional) {\\n                            mask += \"[\" + radixDef + \";{1,\" + opts.digits + \"}]\";\\n                        } else mask += radixDef + \";{\" + opts.digits + \"}\";\\n                    }\\n                }\\n                mask += autoEscape(opts.suffix, opts);\\n                mask += \"[-]\";\\n                opts.greedy = false;\\n                return mask;\\n            },\\n            placeholder: \"\",\\n            greedy: false,\\n            digits: \"*\",\\n            digitsOptional: true,\\n            enforceDigitsOnBlur: false,\\n            radixPoint: \".\",\\n            positionCaretOnClick: \"radixFocus\",\\n            groupSize: 3,\\n            groupSeparator: \"\",\\n            autoGroup: false,\\n            allowMinus: true,\\n            negationSymbol: {\\n                front: \"-\",\\n                back: \"\"\\n            },\\n            integerDigits: \"+\",\\n            integerOptional: true,\\n            prefix: \"\",\\n            suffix: \"\",\\n            rightAlign: true,\\n            decimalProtect: true,\\n            min: null,\\n            max: null,\\n            step: 1,\\n            insertMode: true,\\n            autoUnmask: false,\\n            unmaskAsNumber: false,\\n            inputType: \"text\",\\n            inputmode: \"numeric\",\\n            preValidation: function(buffer, pos, c, isSelection, opts, maskset) {\\n                if (c === \"-\" || c === opts.negationSymbol.front) {\\n                    if (opts.allowMinus !== true) return false;\\n                    opts.isNegative = opts.isNegative === undefined ? true : !opts.isNegative;\\n                    if (buffer.join(\"\") === \"\") return true;\\n                    return {\\n                        caret: maskset.validPositions[pos] ? pos : undefined,\\n                        dopost: true\\n                    };\\n                }\\n                if (isSelection === false && c === opts.radixPoint && (opts.digits !== undefined && (isNaN(opts.digits) || parseInt(opts.digits) > 0))) {\\n                    var radixPos = $.inArray(opts.radixPoint, buffer);\\n                    if (radixPos !== -1 && maskset.validPositions[radixPos] !== undefined) {\\n                        if (opts.numericInput === true) {\\n                            return pos === radixPos;\\n                        }\\n                        return {\\n                            caret: radixPos + 1\\n                        };\\n                    }\\n                }\\n                return true;\\n            },\\n            postValidation: function(buffer, pos, currentResult, opts) {\\n                function buildPostMask(buffer, opts) {\\n                    var postMask = \"\";\\n                    postMask += \"(\" + opts.groupSeparator + \"*{\" + opts.groupSize + \"}){*}\";\\n                    if (opts.radixPoint !== \"\") {\\n                        var radixSplit = buffer.join(\"\").split(opts.radixPoint);\\n                        if (radixSplit[1]) {\\n                            postMask += opts.radixPoint + \"*{\" + radixSplit[1].match(/^\\\\d*\\\\??\\\\d*/)[0].length + \"}\";\\n                        }\\n                    }\\n                    return postMask;\\n                }\\n                var suffix = opts.suffix.split(\"\"), prefix = opts.prefix.split(\"\");\\n                if (currentResult.pos === undefined && currentResult.caret !== undefined && currentResult.dopost !== true) return currentResult;\\n                var caretPos = currentResult.caret !== undefined ? currentResult.caret : currentResult.pos;\\n                var maskedValue = buffer.slice();\\n                if (opts.numericInput) {\\n                    caretPos = maskedValue.length - caretPos - 1;\\n                    maskedValue = maskedValue.reverse();\\n                }\\n                var charAtPos = maskedValue[caretPos];\\n                if (charAtPos === opts.groupSeparator) {\\n                    caretPos += 1;\\n                    charAtPos = maskedValue[caretPos];\\n                }\\n                if (caretPos === maskedValue.length - opts.suffix.length - 1 && charAtPos === opts.radixPoint) return currentResult;\\n                if (charAtPos !== undefined) {\\n                    if (charAtPos !== opts.radixPoint && charAtPos !== opts.negationSymbol.front && charAtPos !== opts.negationSymbol.back) {\\n                        maskedValue[caretPos] = \"?\";\\n                        if (opts.prefix.length > 0 && caretPos >= (opts.isNegative === false ? 1 : 0) && caretPos < opts.prefix.length - 1 + (opts.isNegative === false ? 1 : 0)) {\\n                            prefix[caretPos - (opts.isNegative === false ? 1 : 0)] = \"?\";\\n                        } else if (opts.suffix.length > 0 && caretPos >= maskedValue.length - opts.suffix.length - (opts.isNegative === false ? 1 : 0)) {\\n                            suffix[caretPos - (maskedValue.length - opts.suffix.length - (opts.isNegative === false ? 1 : 0))] = \"?\";\\n                        }\\n                    }\\n                }\\n                prefix = prefix.join(\"\");\\n                suffix = suffix.join(\"\");\\n                var processValue = maskedValue.join(\"\").replace(prefix, \"\");\\n                processValue = processValue.replace(suffix, \"\");\\n                processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\\n                processValue = processValue.replace(new RegExp(\"[-\" + Inputmask.escapeRegex(opts.negationSymbol.front) + \"]\", \"g\"), \"\");\\n                processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\");\\n                if (isNaN(opts.placeholder)) {\\n                    processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.placeholder), \"g\"), \"\");\\n                }\\n                if (processValue.length > 1 && processValue.indexOf(opts.radixPoint) !== 1) {\\n                    if (charAtPos === \"0\") {\\n                        processValue = processValue.replace(/^\\\\?/g, \"\");\\n                    }\\n                    processValue = processValue.replace(/^0/g, \"\");\\n                }\\n                if (processValue.charAt(0) === opts.radixPoint && opts.radixPoint !== \"\" && opts.numericInput !== true) {\\n                    processValue = \"0\" + processValue;\\n                }\\n                if (processValue !== \"\") {\\n                    processValue = processValue.split(\"\");\\n                    if ((!opts.digitsOptional || opts.enforceDigitsOnBlur && currentResult.event === \"blur\") && isFinite(opts.digits)) {\\n                        var radixPosition = $.inArray(opts.radixPoint, processValue);\\n                        var rpb = $.inArray(opts.radixPoint, maskedValue);\\n                        if (radixPosition === -1) {\\n                            processValue.push(opts.radixPoint);\\n                            radixPosition = processValue.length - 1;\\n                        }\\n                        for (var i = 1; i <= opts.digits; i++) {\\n                            if ((!opts.digitsOptional || opts.enforceDigitsOnBlur && currentResult.event === \"blur\") && (processValue[radixPosition + i] === undefined || processValue[radixPosition + i] === opts.placeholder.charAt(0))) {\\n                                processValue[radixPosition + i] = currentResult.placeholder || opts.placeholder.charAt(0);\\n                            } else if (rpb !== -1 && maskedValue[rpb + i] !== undefined) {\\n                                processValue[radixPosition + i] = processValue[radixPosition + i] || maskedValue[rpb + i];\\n                            }\\n                        }\\n                    }\\n                    if (opts.autoGroup === true && opts.groupSeparator !== \"\" && (charAtPos !== opts.radixPoint || currentResult.pos !== undefined || currentResult.dopost)) {\\n                        var addRadix = processValue[processValue.length - 1] === opts.radixPoint && currentResult.c === opts.radixPoint;\\n                        processValue = Inputmask(buildPostMask(processValue, opts), {\\n                            numericInput: true,\\n                            jitMasking: true,\\n                            definitions: {\\n                                \"*\": {\\n                                    validator: \"[0-9?]\",\\n                                    cardinality: 1\\n                                }\\n                            }\\n                        }).format(processValue.join(\"\"));\\n                        if (addRadix) processValue += opts.radixPoint;\\n                        if (processValue.charAt(0) === opts.groupSeparator) {\\n                            processValue.substr(1);\\n                        }\\n                    } else processValue = processValue.join(\"\");\\n                }\\n                if (opts.isNegative && currentResult.event === \"blur\") {\\n                    opts.isNegative = processValue !== \"0\";\\n                }\\n                processValue = prefix + processValue;\\n                processValue += suffix;\\n                if (opts.isNegative) {\\n                    processValue = opts.negationSymbol.front + processValue;\\n                    processValue += opts.negationSymbol.back;\\n                }\\n                processValue = processValue.split(\"\");\\n                if (charAtPos !== undefined) {\\n                    if (charAtPos !== opts.radixPoint && charAtPos !== opts.negationSymbol.front && charAtPos !== opts.negationSymbol.back) {\\n                        caretPos = $.inArray(\"?\", processValue);\\n                        if (caretPos > -1) {\\n                            processValue[caretPos] = charAtPos;\\n                        } else caretPos = currentResult.caret || 0;\\n                    } else if (charAtPos === opts.radixPoint || charAtPos === opts.negationSymbol.front || charAtPos === opts.negationSymbol.back) {\\n                        var newCaretPos = $.inArray(charAtPos, processValue);\\n                        if (newCaretPos !== -1) caretPos = newCaretPos;\\n                    }\\n                }\\n                if (opts.numericInput) {\\n                    caretPos = processValue.length - caretPos - 1;\\n                    processValue = processValue.reverse();\\n                }\\n                var rslt = {\\n                    caret: (charAtPos === undefined || currentResult.pos !== undefined) && caretPos !== undefined ? caretPos + (opts.numericInput ? -1 : 1) : caretPos,\\n                    buffer: processValue,\\n                    refreshFromBuffer: currentResult.dopost || buffer.join(\"\") !== processValue.join(\"\")\\n                };\\n                return rslt.refreshFromBuffer ? rslt : currentResult;\\n            },\\n            onBeforeWrite: function(e, buffer, caretPos, opts) {\\n                function parseMinMaxOptions(opts) {\\n                    if (opts.parseMinMaxOptions === undefined) {\\n                        if (opts.min !== null) {\\n                            opts.min = opts.min.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\\n                            if (opts.radixPoint === \",\") opts.min = opts.min.replace(opts.radixPoint, \".\");\\n                            opts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN;\\n                            if (isNaN(opts.min)) opts.min = Number.MIN_VALUE;\\n                        }\\n                        if (opts.max !== null) {\\n                            opts.max = opts.max.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\\n                            if (opts.radixPoint === \",\") opts.max = opts.max.replace(opts.radixPoint, \".\");\\n                            opts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN;\\n                            if (isNaN(opts.max)) opts.max = Number.MAX_VALUE;\\n                        }\\n                        opts.parseMinMaxOptions = \"done\";\\n                    }\\n                }\\n                if (e) {\\n                    switch (e.type) {\\n                      case \"keydown\":\\n                        return opts.postValidation(buffer, caretPos, {\\n                            caret: caretPos,\\n                            dopost: true\\n                        }, opts);\\n\\n                      case \"blur\":\\n                      case \"checkval\":\\n                        var unmasked;\\n                        parseMinMaxOptions(opts);\\n                        if (opts.min !== null || opts.max !== null) {\\n                            unmasked = opts.onUnMask(buffer.join(\"\"), undefined, $.extend({}, opts, {\\n                                unmaskAsNumber: true\\n                            }));\\n                            if (opts.min !== null && unmasked < opts.min) {\\n                                opts.isNegative = opts.min < 0;\\n                                return opts.postValidation(opts.min.toString().replace(\".\", opts.radixPoint).split(\"\"), caretPos, {\\n                                    caret: caretPos,\\n                                    dopost: true,\\n                                    placeholder: \"0\"\\n                                }, opts);\\n                            } else if (opts.max !== null && unmasked > opts.max) {\\n                                opts.isNegative = opts.max < 0;\\n                                return opts.postValidation(opts.max.toString().replace(\".\", opts.radixPoint).split(\"\"), caretPos, {\\n                                    caret: caretPos,\\n                                    dopost: true,\\n                                    placeholder: \"0\"\\n                                }, opts);\\n                            }\\n                        }\\n                        return opts.postValidation(buffer, caretPos, {\\n                            caret: caretPos,\\n                            placeholder: \"0\",\\n                            event: \"blur\"\\n                        }, opts);\\n\\n                      case \"_checkval\":\\n                        return {\\n                            caret: caretPos\\n                        };\\n\\n                      default:\\n                        break;\\n                    }\\n                }\\n            },\\n            regex: {\\n                integerPart: function(opts, emptyCheck) {\\n                    return emptyCheck ? new RegExp(\"[\" + Inputmask.escapeRegex(opts.negationSymbol.front) + \"+]?\") : new RegExp(\"[\" + Inputmask.escapeRegex(opts.negationSymbol.front) + \"+]?\\\\\\\\d+\");\\n                },\\n                integerNPart: function(opts) {\\n                    return new RegExp(\"[\\\\\\\\d\" + Inputmask.escapeRegex(opts.groupSeparator) + Inputmask.escapeRegex(opts.placeholder.charAt(0)) + \"]+\");\\n                }\\n            },\\n            definitions: {\\n                \"~\": {\\n                    validator: function(chrs, maskset, pos, strict, opts, isSelection) {\\n                        var isValid, l;\\n                        if (chrs === \"k\" || chrs === \"m\") {\\n                            isValid = {\\n                                insert: [],\\n                                c: 0\\n                            };\\n                            for (var i = 0, l = chrs === \"k\" ? 2 : 5; i < l; i++) {\\n                                isValid.insert.push({\\n                                    pos: pos + i,\\n                                    c: 0\\n                                });\\n                            }\\n                            isValid.pos = pos + l;\\n                            return isValid;\\n                        }\\n                        isValid = strict ? new RegExp(\"[0-9\" + Inputmask.escapeRegex(opts.groupSeparator) + \"]\").test(chrs) : new RegExp(\"[0-9]\").test(chrs);\\n                        if (isValid === true) {\\n                            if (opts.numericInput !== true && maskset.validPositions[pos] !== undefined && maskset.validPositions[pos].match.def === \"~\" && !isSelection) {\\n                                var processValue = maskset.buffer.join(\"\");\\n                                processValue = processValue.replace(new RegExp(\"[-\" + Inputmask.escapeRegex(opts.negationSymbol.front) + \"]\", \"g\"), \"\");\\n                                processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\");\\n                                var pvRadixSplit = processValue.split(opts.radixPoint);\\n                                if (pvRadixSplit.length > 1) {\\n                                    pvRadixSplit[1] = pvRadixSplit[1].replace(/0/g, opts.placeholder.charAt(0));\\n                                }\\n                                if (pvRadixSplit[0] === \"0\") {\\n                                    pvRadixSplit[0] = pvRadixSplit[0].replace(/0/g, opts.placeholder.charAt(0));\\n                                }\\n                                processValue = pvRadixSplit[0] + opts.radixPoint + pvRadixSplit[1] || \"\";\\n                                var bufferTemplate = maskset._buffer.join(\"\");\\n                                if (processValue === opts.radixPoint) {\\n                                    processValue = bufferTemplate;\\n                                }\\n                                while (processValue.match(Inputmask.escapeRegex(bufferTemplate) + \"$\") === null) {\\n                                    bufferTemplate = bufferTemplate.slice(1);\\n                                }\\n                                processValue = processValue.replace(bufferTemplate, \"\");\\n                                processValue = processValue.split(\"\");\\n                                if (processValue[pos] === undefined) {\\n                                    isValid = {\\n                                        pos: pos,\\n                                        remove: pos\\n                                    };\\n                                } else {\\n                                    isValid = {\\n                                        pos: pos\\n                                    };\\n                                }\\n                            }\\n                        } else if (!strict && chrs === opts.radixPoint && maskset.validPositions[pos - 1] === undefined) {\\n                            isValid = {\\n                                insert: {\\n                                    pos: pos,\\n                                    c: 0\\n                                },\\n                                pos: pos + 1\\n                            };\\n                        }\\n                        return isValid;\\n                    },\\n                    cardinality: 1\\n                },\\n                \"+\": {\\n                    validator: function(chrs, maskset, pos, strict, opts) {\\n                        return opts.allowMinus && (chrs === \"-\" || chrs === opts.negationSymbol.front);\\n                    },\\n                    cardinality: 1,\\n                    placeholder: \"\"\\n                },\\n                \"-\": {\\n                    validator: function(chrs, maskset, pos, strict, opts) {\\n                        return opts.allowMinus && chrs === opts.negationSymbol.back;\\n                    },\\n                    cardinality: 1,\\n                    placeholder: \"\"\\n                },\\n                \":\": {\\n                    validator: function(chrs, maskset, pos, strict, opts) {\\n                        var radix = \"[\" + Inputmask.escapeRegex(opts.radixPoint) + \"]\";\\n                        var isValid = new RegExp(radix).test(chrs);\\n                        if (isValid && maskset.validPositions[pos] && maskset.validPositions[pos].match.placeholder === opts.radixPoint) {\\n                            isValid = {\\n                                caret: pos + 1\\n                            };\\n                        }\\n                        return isValid;\\n                    },\\n                    cardinality: 1,\\n                    placeholder: function(opts) {\\n                        return opts.radixPoint;\\n                    }\\n                }\\n            },\\n            onUnMask: function(maskedValue, unmaskedValue, opts) {\\n                if (unmaskedValue === \"\" && opts.nullable === true) {\\n                    return unmaskedValue;\\n                }\\n                var processValue = maskedValue.replace(opts.prefix, \"\");\\n                processValue = processValue.replace(opts.suffix, \"\");\\n                processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\\n                if (opts.placeholder.charAt(0) !== \"\") {\\n                    processValue = processValue.replace(new RegExp(opts.placeholder.charAt(0), \"g\"), \"0\");\\n                }\\n                if (opts.unmaskAsNumber) {\\n                    if (opts.radixPoint !== \"\" && processValue.indexOf(opts.radixPoint) !== -1) processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), \".\");\\n                    processValue = processValue.replace(new RegExp(\"^\" + Inputmask.escapeRegex(opts.negationSymbol.front)), \"-\");\\n                    processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\");\\n                    return Number(processValue);\\n                }\\n                return processValue;\\n            },\\n            isComplete: function(buffer, opts) {\\n                var maskedValue = (opts.numericInput ? buffer.slice().reverse() : buffer).join(\"\");\\n                maskedValue = maskedValue.replace(new RegExp(\"^\" + Inputmask.escapeRegex(opts.negationSymbol.front)), \"-\");\\n                maskedValue = maskedValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\");\\n                maskedValue = maskedValue.replace(opts.prefix, \"\");\\n                maskedValue = maskedValue.replace(opts.suffix, \"\");\\n                maskedValue = maskedValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator) + \"([0-9]{3})\", \"g\"), \"$1\");\\n                if (opts.radixPoint === \",\") maskedValue = maskedValue.replace(Inputmask.escapeRegex(opts.radixPoint), \".\");\\n                return isFinite(maskedValue);\\n            },\\n            onBeforeMask: function(initialValue, opts) {\\n                opts.isNegative = undefined;\\n                var radixPoint = opts.radixPoint || \",\";\\n                if ((typeof initialValue == \"number\" || opts.inputType === \"number\") && radixPoint !== \"\") {\\n                    initialValue = initialValue.toString().replace(\".\", radixPoint);\\n                }\\n                var valueParts = initialValue.split(radixPoint), integerPart = valueParts[0].replace(/[^\\\\-0-9]/g, \"\"), decimalPart = valueParts.length > 1 ? valueParts[1].replace(/[^0-9]/g, \"\") : \"\";\\n                initialValue = integerPart + (decimalPart !== \"\" ? radixPoint + decimalPart : decimalPart);\\n                var digits = 0;\\n                if (radixPoint !== \"\") {\\n                    digits = decimalPart.length;\\n                    if (decimalPart !== \"\") {\\n                        var digitsFactor = Math.pow(10, digits || 1);\\n                        if (isFinite(opts.digits)) {\\n                            digits = parseInt(opts.digits);\\n                            digitsFactor = Math.pow(10, digits);\\n                        }\\n                        initialValue = initialValue.replace(Inputmask.escapeRegex(radixPoint), \".\");\\n                        if (isFinite(initialValue)) initialValue = Math.round(parseFloat(initialValue) * digitsFactor) / digitsFactor;\\n                        initialValue = initialValue.toString().replace(\".\", radixPoint);\\n                    }\\n                }\\n                if (opts.digits === 0 && initialValue.indexOf(Inputmask.escapeRegex(radixPoint)) !== -1) {\\n                    initialValue = initialValue.substring(0, initialValue.indexOf(Inputmask.escapeRegex(radixPoint)));\\n                }\\n                return alignDigits(initialValue.toString().split(\"\"), digits, opts).join(\"\");\\n            },\\n            onKeyDown: function(e, buffer, caretPos, opts) {\\n                var $input = $(this);\\n                if (e.ctrlKey) {\\n                    switch (e.keyCode) {\\n                      case Inputmask.keyCode.UP:\\n                        $input.val(parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step));\\n                        $input.trigger(\"setvalue\");\\n                        break;\\n\\n                      case Inputmask.keyCode.DOWN:\\n                        $input.val(parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step));\\n                        $input.trigger(\"setvalue\");\\n                        break;\\n                    }\\n                }\\n            }\\n        },\\n        currency: {\\n            prefix: \"$ \",\\n            groupSeparator: \",\",\\n            alias: \"numeric\",\\n            placeholder: \"0\",\\n            autoGroup: true,\\n            digits: 2,\\n            digitsOptional: false,\\n            clearMaskOnLostFocus: false\\n        },\\n        decimal: {\\n            alias: \"numeric\"\\n        },\\n        integer: {\\n            alias: \"numeric\",\\n            digits: 0,\\n            radixPoint: \"\"\\n        },\\n        percentage: {\\n            alias: \"numeric\",\\n            digits: 2,\\n            digitsOptional: true,\\n            radixPoint: \".\",\\n            placeholder: \"0\",\\n            autoGroup: false,\\n            min: 0,\\n            max: 100,\\n            suffix: \" %\",\\n            allowMinus: false\\n        }\\n    });\\n    return Inputmask;\\n});\\n\\n//# sourceURL=webpack:///./node_modules/inputmask/dist/inputmask/inputmask.numeric.extensions.js?')},\"./node_modules/inputmask/index.js\":function(module,exports,__webpack_require__){eval('__webpack_require__(/*! ./dist/inputmask/inputmask.extensions */ \"./node_modules/inputmask/dist/inputmask/inputmask.extensions.js\");\\r\\n__webpack_require__(/*! ./dist/inputmask/inputmask.date.extensions */ \"./node_modules/inputmask/dist/inputmask/inputmask.date.extensions.js\");\\r\\n__webpack_require__(/*! ./dist/inputmask/inputmask.numeric.extensions */ \"./node_modules/inputmask/dist/inputmask/inputmask.numeric.extensions.js\");\\r\\n\\r\\nmodule.exports = __webpack_require__(/*! ./dist/inputmask/inputmask.js */ \"./node_modules/inputmask/dist/inputmask/inputmask.js\");\\r\\n\\n\\n//# sourceURL=webpack:///./node_modules/inputmask/index.js?')},\"./node_modules/jquery-bar-rating/dist/jquery.barrating.min.js\":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(t){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \\'function\\' ?\\n\\t\\t\\t\\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):undefined}(function(t){var e=function(){function e(){var e=this,n=function(){var n=[\"br-wrapper\"];\"\"!==e.options.theme&&n.push(\"br-theme-\"+e.options.theme),e.$elem.wrap(t(\"<div />\",{\"class\":n.join(\" \")}))},i=function(){e.$elem.unwrap()},a=function(n){return t.isNumeric(n)&&(n=Math.floor(n)),t(\\'option[value=\"\\'+n+\\'\"]\\',e.$elem)},r=function(){var n=e.options.initialRating;return n?a(n):t(\"option:selected\",e.$elem)},o=function(){var n=e.$elem.find(\\'option[value=\"\\'+e.options.emptyValue+\\'\"]\\');return!n.length&&e.options.allowEmpty?(n=t(\"<option />\",{value:e.options.emptyValue}),n.prependTo(e.$elem)):n},l=function(t){var n=e.$elem.data(\"barrating\");return\"undefined\"!=typeof t?n[t]:n},s=function(t,n){null!==n&&\"object\"==typeof n?e.$elem.data(\"barrating\",n):e.$elem.data(\"barrating\")[t]=n},u=function(){var t=r(),n=o(),i=t.val(),a=t.data(\"html\")?t.data(\"html\"):t.text(),l=null!==e.options.allowEmpty?e.options.allowEmpty:!!n.length,u=n.length?n.val():null,d=n.length?n.text():null;s(null,{userOptions:e.options,ratingValue:i,ratingText:a,originalRatingValue:i,originalRatingText:a,allowEmpty:l,emptyRatingValue:u,emptyRatingText:d,readOnly:e.options.readonly,ratingMade:!1})},d=function(){e.$elem.removeData(\"barrating\")},c=function(){return l(\"ratingText\")},f=function(){return l(\"ratingValue\")},g=function(){var n=t(\"<div />\",{\"class\":\"br-widget\"});return e.$elem.find(\"option\").each(function(){var i,a,r,o;i=t(this).val(),i!==l(\"emptyRatingValue\")&&(a=t(this).text(),r=t(this).data(\"html\"),r&&(a=r),o=t(\"<a />\",{href:\"#\",\"data-rating-value\":i,\"data-rating-text\":a,html:e.options.showValues?a:\"\"}),n.append(o))}),e.options.showSelectedRating&&n.append(t(\"<div />\",{text:\"\",\"class\":\"br-current-rating\"})),e.options.reverse&&n.addClass(\"br-reverse\"),e.options.readonly&&n.addClass(\"br-readonly\"),n},p=function(){return l(\"userOptions\").reverse?\"nextAll\":\"prevAll\"},h=function(t){a(t).prop(\"selected\",!0),e.$elem.change()},m=function(){t(\"option\",e.$elem).prop(\"selected\",function(){return this.defaultSelected}),e.$elem.change()},v=function(t){t=t?t:c(),t==l(\"emptyRatingText\")&&(t=\"\"),e.options.showSelectedRating&&e.$elem.parent().find(\".br-current-rating\").text(t)},y=function(t){return Math.round(Math.floor(10*t)/10%1*100)},b=function(){e.$widget.find(\"a\").removeClass(function(t,e){return(e.match(/(^|\\\\s)br-\\\\S+/g)||[]).join(\" \")})},w=function(){var n,i,a=e.$widget.find(\\'a[data-rating-value=\"\\'+f()+\\'\"]\\'),r=l(\"userOptions\").initialRating,o=t.isNumeric(f())?f():0,s=y(r);if(b(),a.addClass(\"br-selected br-current\")[p()]().addClass(\"br-selected\"),!l(\"ratingMade\")&&t.isNumeric(r)){if(o>=r||!s)return;n=e.$widget.find(\"a\"),i=a.length?a[l(\"userOptions\").reverse?\"prev\":\"next\"]():n[l(\"userOptions\").reverse?\"last\":\"first\"](),i.addClass(\"br-fractional\"),i.addClass(\"br-fractional-\"+s)}},$=function(t){return l(\"allowEmpty\")&&l(\"userOptions\").deselectable?f()==t.attr(\"data-rating-value\"):!1},x=function(n){n.on(\"click.barrating\",function(n){var i,a,r=t(this),o=l(\"userOptions\");return n.preventDefault(),i=r.attr(\"data-rating-value\"),a=r.attr(\"data-rating-text\"),$(r)&&(i=l(\"emptyRatingValue\"),a=l(\"emptyRatingText\")),s(\"ratingValue\",i),s(\"ratingText\",a),s(\"ratingMade\",!0),h(i),v(a),w(),o.onSelect.call(e,f(),c(),n),!1})},R=function(e){e.on(\"mouseenter.barrating\",function(){var e=t(this);b(),e.addClass(\"br-active\")[p()]().addClass(\"br-active\"),v(e.attr(\"data-rating-text\"))})},V=function(t){e.$widget.on(\"mouseleave.barrating blur.barrating\",function(){v(),w()})},O=function(e){e.on(\"touchstart.barrating\",function(e){e.preventDefault(),e.stopPropagation(),t(this).click()})},C=function(t){t.on(\"click.barrating\",function(t){t.preventDefault()})},S=function(t){x(t),e.options.hoverState&&(R(t),V(t))},T=function(t){t.off(\".barrating\")},j=function(t){var n=e.$widget.find(\"a\");O&&O(n),t?(T(n),C(n)):S(n)};this.show=function(){l()||(n(),u(),e.$widget=g(),e.$widget.insertAfter(e.$elem),w(),v(),j(e.options.readonly),e.$elem.hide())},this.readonly=function(t){\"boolean\"==typeof t&&l(\"readOnly\")!=t&&(j(t),s(\"readOnly\",t),e.$widget.toggleClass(\"br-readonly\"))},this.set=function(t){var n=l(\"userOptions\");0!==e.$elem.find(\\'option[value=\"\\'+t+\\'\"]\\').length&&(s(\"ratingValue\",t),s(\"ratingText\",e.$elem.find(\\'option[value=\"\\'+t+\\'\"]\\').text()),s(\"ratingMade\",!0),h(f()),v(c()),w(),n.silent||n.onSelect.call(this,f(),c()))},this.clear=function(){var t=l(\"userOptions\");s(\"ratingValue\",l(\"originalRatingValue\")),s(\"ratingText\",l(\"originalRatingText\")),s(\"ratingMade\",!1),m(),v(c()),w(),t.onClear.call(this,f(),c())},this.destroy=function(){var t=f(),n=c(),a=l(\"userOptions\");T(e.$widget.find(\"a\")),e.$widget.remove(),d(),i(),e.$elem.show(),a.onDestroy.call(this,t,n)}}return e.prototype.init=function(e,n){return this.$elem=t(n),this.options=t.extend({},t.fn.barrating.defaults,e),this.options},e}();t.fn.barrating=function(n,i){return this.each(function(){var a=new e;if(t(this).is(\"select\")||t.error(\"Sorry, this plugin only works with select fields.\"),a.hasOwnProperty(n)){if(a.init(i,this),\"show\"===n)return a.show(i);if(a.$elem.data(\"barrating\"))return a.$widget=t(this).next(\".br-widget\"),a[n](i)}else{if(\"object\"==typeof n||!n)return i=n,a.init(i,this),a.show();t.error(\"Method \"+n+\" does not exist on jQuery.barrating\")}})},t.fn.barrating.defaults={theme:\"\",initialRating:null,allowEmpty:null,emptyValue:\"\",showValues:!1,showSelectedRating:!0,deselectable:!0,reverse:!1,readonly:!1,fastClicks:!0,hoverState:!0,silent:!1,onSelect:function(t,e,n){},onClear:function(t,e){},onDestroy:function(t,e){}},t.fn.barrating.BarRating=e});\\n//# sourceMappingURL=jquery.barrating.min.js.map\\n\\n//# sourceURL=webpack:///./node_modules/jquery-bar-rating/dist/jquery.barrating.min.js?')},\"./node_modules/jquery/dist/jquery.js\":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\\n * jQuery JavaScript Library v3.3.1\\n * https://jquery.com/\\n *\\n * Includes Sizzle.js\\n * https://sizzlejs.com/\\n *\\n * Copyright JS Foundation and other contributors\\n * Released under the MIT license\\n * https://jquery.org/license\\n *\\n * Date: 2018-01-20T17:24Z\\n */\\n( function( global, factory ) {\\n\\n\\t\"use strict\";\\n\\n\\tif (  true && typeof module.exports === \"object\" ) {\\n\\n\\t\\t// For CommonJS and CommonJS-like environments where a proper `window`\\n\\t\\t// is present, execute the factory and get jQuery.\\n\\t\\t// For environments that do not have a `window` with a `document`\\n\\t\\t// (such as Node.js), expose a factory as module.exports.\\n\\t\\t// This accentuates the need for the creation of a real `window`.\\n\\t\\t// e.g. var jQuery = require(\"jquery\")(window);\\n\\t\\t// See ticket #14549 for more info.\\n\\t\\tmodule.exports = global.document ?\\n\\t\\t\\tfactory( global, true ) :\\n\\t\\t\\tfunction( w ) {\\n\\t\\t\\t\\tif ( !w.document ) {\\n\\t\\t\\t\\t\\tthrow new Error( \"jQuery requires a window with a document\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn factory( w );\\n\\t\\t\\t};\\n\\t} else {\\n\\t\\tfactory( global );\\n\\t}\\n\\n// Pass this if window is not defined yet\\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\\n\\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\\n// enough that all such attempts are guarded in a try block.\\n\"use strict\";\\n\\nvar arr = [];\\n\\nvar document = window.document;\\n\\nvar getProto = Object.getPrototypeOf;\\n\\nvar slice = arr.slice;\\n\\nvar concat = arr.concat;\\n\\nvar push = arr.push;\\n\\nvar indexOf = arr.indexOf;\\n\\nvar class2type = {};\\n\\nvar toString = class2type.toString;\\n\\nvar hasOwn = class2type.hasOwnProperty;\\n\\nvar fnToString = hasOwn.toString;\\n\\nvar ObjectFunctionString = fnToString.call( Object );\\n\\nvar support = {};\\n\\nvar isFunction = function isFunction( obj ) {\\n\\n      // Support: Chrome <=57, Firefox <=52\\n      // In some browsers, typeof returns \"function\" for HTML <object> elements\\n      // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\\n      // We don\\'t want to classify *any* DOM node as a function.\\n      return typeof obj === \"function\" && typeof obj.nodeType !== \"number\";\\n  };\\n\\n\\nvar isWindow = function isWindow( obj ) {\\n\\t\\treturn obj != null && obj === obj.window;\\n\\t};\\n\\n\\n\\n\\n\\tvar preservedScriptAttributes = {\\n\\t\\ttype: true,\\n\\t\\tsrc: true,\\n\\t\\tnoModule: true\\n\\t};\\n\\n\\tfunction DOMEval( code, doc, node ) {\\n\\t\\tdoc = doc || document;\\n\\n\\t\\tvar i,\\n\\t\\t\\tscript = doc.createElement( \"script\" );\\n\\n\\t\\tscript.text = code;\\n\\t\\tif ( node ) {\\n\\t\\t\\tfor ( i in preservedScriptAttributes ) {\\n\\t\\t\\t\\tif ( node[ i ] ) {\\n\\t\\t\\t\\t\\tscript[ i ] = node[ i ];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tdoc.head.appendChild( script ).parentNode.removeChild( script );\\n\\t}\\n\\n\\nfunction toType( obj ) {\\n\\tif ( obj == null ) {\\n\\t\\treturn obj + \"\";\\n\\t}\\n\\n\\t// Support: Android <=2.3 only (functionish RegExp)\\n\\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\\n\\t\\tclass2type[ toString.call( obj ) ] || \"object\" :\\n\\t\\ttypeof obj;\\n}\\n/* global Symbol */\\n// Defining this global in .eslintrc.json would create a danger of using the global\\n// unguarded in another place, it seems safer to define global only for this module\\n\\n\\n\\nvar\\n\\tversion = \"3.3.1\",\\n\\n\\t// Define a local copy of jQuery\\n\\tjQuery = function( selector, context ) {\\n\\n\\t\\t// The jQuery object is actually just the init constructor \\'enhanced\\'\\n\\t\\t// Need init if jQuery is called (just allow error to be thrown if not included)\\n\\t\\treturn new jQuery.fn.init( selector, context );\\n\\t},\\n\\n\\t// Support: Android <=4.0 only\\n\\t// Make sure we trim BOM and NBSP\\n\\trtrim = /^[\\\\s\\\\uFEFF\\\\xA0]+|[\\\\s\\\\uFEFF\\\\xA0]+$/g;\\n\\njQuery.fn = jQuery.prototype = {\\n\\n\\t// The current version of jQuery being used\\n\\tjquery: version,\\n\\n\\tconstructor: jQuery,\\n\\n\\t// The default length of a jQuery object is 0\\n\\tlength: 0,\\n\\n\\ttoArray: function() {\\n\\t\\treturn slice.call( this );\\n\\t},\\n\\n\\t// Get the Nth element in the matched element set OR\\n\\t// Get the whole matched element set as a clean array\\n\\tget: function( num ) {\\n\\n\\t\\t// Return all the elements in a clean array\\n\\t\\tif ( num == null ) {\\n\\t\\t\\treturn slice.call( this );\\n\\t\\t}\\n\\n\\t\\t// Return just the one element from the set\\n\\t\\treturn num < 0 ? this[ num + this.length ] : this[ num ];\\n\\t},\\n\\n\\t// Take an array of elements and push it onto the stack\\n\\t// (returning the new matched element set)\\n\\tpushStack: function( elems ) {\\n\\n\\t\\t// Build a new jQuery matched element set\\n\\t\\tvar ret = jQuery.merge( this.constructor(), elems );\\n\\n\\t\\t// Add the old object onto the stack (as a reference)\\n\\t\\tret.prevObject = this;\\n\\n\\t\\t// Return the newly-formed element set\\n\\t\\treturn ret;\\n\\t},\\n\\n\\t// Execute a callback for every element in the matched set.\\n\\teach: function( callback ) {\\n\\t\\treturn jQuery.each( this, callback );\\n\\t},\\n\\n\\tmap: function( callback ) {\\n\\t\\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\\n\\t\\t\\treturn callback.call( elem, i, elem );\\n\\t\\t} ) );\\n\\t},\\n\\n\\tslice: function() {\\n\\t\\treturn this.pushStack( slice.apply( this, arguments ) );\\n\\t},\\n\\n\\tfirst: function() {\\n\\t\\treturn this.eq( 0 );\\n\\t},\\n\\n\\tlast: function() {\\n\\t\\treturn this.eq( -1 );\\n\\t},\\n\\n\\teq: function( i ) {\\n\\t\\tvar len = this.length,\\n\\t\\t\\tj = +i + ( i < 0 ? len : 0 );\\n\\t\\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\\n\\t},\\n\\n\\tend: function() {\\n\\t\\treturn this.prevObject || this.constructor();\\n\\t},\\n\\n\\t// For internal use only.\\n\\t// Behaves like an Array\\'s method, not like a jQuery method.\\n\\tpush: push,\\n\\tsort: arr.sort,\\n\\tsplice: arr.splice\\n};\\n\\njQuery.extend = jQuery.fn.extend = function() {\\n\\tvar options, name, src, copy, copyIsArray, clone,\\n\\t\\ttarget = arguments[ 0 ] || {},\\n\\t\\ti = 1,\\n\\t\\tlength = arguments.length,\\n\\t\\tdeep = false;\\n\\n\\t// Handle a deep copy situation\\n\\tif ( typeof target === \"boolean\" ) {\\n\\t\\tdeep = target;\\n\\n\\t\\t// Skip the boolean and the target\\n\\t\\ttarget = arguments[ i ] || {};\\n\\t\\ti++;\\n\\t}\\n\\n\\t// Handle case when target is a string or something (possible in deep copy)\\n\\tif ( typeof target !== \"object\" && !isFunction( target ) ) {\\n\\t\\ttarget = {};\\n\\t}\\n\\n\\t// Extend jQuery itself if only one argument is passed\\n\\tif ( i === length ) {\\n\\t\\ttarget = this;\\n\\t\\ti--;\\n\\t}\\n\\n\\tfor ( ; i < length; i++ ) {\\n\\n\\t\\t// Only deal with non-null/undefined values\\n\\t\\tif ( ( options = arguments[ i ] ) != null ) {\\n\\n\\t\\t\\t// Extend the base object\\n\\t\\t\\tfor ( name in options ) {\\n\\t\\t\\t\\tsrc = target[ name ];\\n\\t\\t\\t\\tcopy = options[ name ];\\n\\n\\t\\t\\t\\t// Prevent never-ending loop\\n\\t\\t\\t\\tif ( target === copy ) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Recurse if we\\'re merging plain objects or arrays\\n\\t\\t\\t\\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\\n\\t\\t\\t\\t\\t( copyIsArray = Array.isArray( copy ) ) ) ) {\\n\\n\\t\\t\\t\\t\\tif ( copyIsArray ) {\\n\\t\\t\\t\\t\\t\\tcopyIsArray = false;\\n\\t\\t\\t\\t\\t\\tclone = src && Array.isArray( src ) ? src : [];\\n\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tclone = src && jQuery.isPlainObject( src ) ? src : {};\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Never move original objects, clone them\\n\\t\\t\\t\\t\\ttarget[ name ] = jQuery.extend( deep, clone, copy );\\n\\n\\t\\t\\t\\t// Don\\'t bring in undefined values\\n\\t\\t\\t\\t} else if ( copy !== undefined ) {\\n\\t\\t\\t\\t\\ttarget[ name ] = copy;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the modified object\\n\\treturn target;\\n};\\n\\njQuery.extend( {\\n\\n\\t// Unique for each copy of jQuery on the page\\n\\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\\\D/g, \"\" ),\\n\\n\\t// Assume jQuery is ready without the ready module\\n\\tisReady: true,\\n\\n\\terror: function( msg ) {\\n\\t\\tthrow new Error( msg );\\n\\t},\\n\\n\\tnoop: function() {},\\n\\n\\tisPlainObject: function( obj ) {\\n\\t\\tvar proto, Ctor;\\n\\n\\t\\t// Detect obvious negatives\\n\\t\\t// Use toString instead of jQuery.type to catch host objects\\n\\t\\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tproto = getProto( obj );\\n\\n\\t\\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\\n\\t\\tif ( !proto ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t// Objects with prototype are plain iff they were constructed by a global Object function\\n\\t\\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\\n\\t\\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\\n\\t},\\n\\n\\tisEmptyObject: function( obj ) {\\n\\n\\t\\t/* eslint-disable no-unused-vars */\\n\\t\\t// See https://github.com/eslint/eslint/issues/6125\\n\\t\\tvar name;\\n\\n\\t\\tfor ( name in obj ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t},\\n\\n\\t// Evaluates a script in a global context\\n\\tglobalEval: function( code ) {\\n\\t\\tDOMEval( code );\\n\\t},\\n\\n\\teach: function( obj, callback ) {\\n\\t\\tvar length, i = 0;\\n\\n\\t\\tif ( isArrayLike( obj ) ) {\\n\\t\\t\\tlength = obj.length;\\n\\t\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\t\\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor ( i in obj ) {\\n\\t\\t\\t\\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn obj;\\n\\t},\\n\\n\\t// Support: Android <=4.0 only\\n\\ttrim: function( text ) {\\n\\t\\treturn text == null ?\\n\\t\\t\\t\"\" :\\n\\t\\t\\t( text + \"\" ).replace( rtrim, \"\" );\\n\\t},\\n\\n\\t// results is for internal usage only\\n\\tmakeArray: function( arr, results ) {\\n\\t\\tvar ret = results || [];\\n\\n\\t\\tif ( arr != null ) {\\n\\t\\t\\tif ( isArrayLike( Object( arr ) ) ) {\\n\\t\\t\\t\\tjQuery.merge( ret,\\n\\t\\t\\t\\t\\ttypeof arr === \"string\" ?\\n\\t\\t\\t\\t\\t[ arr ] : arr\\n\\t\\t\\t\\t);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpush.call( ret, arr );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ret;\\n\\t},\\n\\n\\tinArray: function( elem, arr, i ) {\\n\\t\\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\\n\\t},\\n\\n\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\tmerge: function( first, second ) {\\n\\t\\tvar len = +second.length,\\n\\t\\t\\tj = 0,\\n\\t\\t\\ti = first.length;\\n\\n\\t\\tfor ( ; j < len; j++ ) {\\n\\t\\t\\tfirst[ i++ ] = second[ j ];\\n\\t\\t}\\n\\n\\t\\tfirst.length = i;\\n\\n\\t\\treturn first;\\n\\t},\\n\\n\\tgrep: function( elems, callback, invert ) {\\n\\t\\tvar callbackInverse,\\n\\t\\t\\tmatches = [],\\n\\t\\t\\ti = 0,\\n\\t\\t\\tlength = elems.length,\\n\\t\\t\\tcallbackExpect = !invert;\\n\\n\\t\\t// Go through the array, only saving the items\\n\\t\\t// that pass the validator function\\n\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\tcallbackInverse = !callback( elems[ i ], i );\\n\\t\\t\\tif ( callbackInverse !== callbackExpect ) {\\n\\t\\t\\t\\tmatches.push( elems[ i ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn matches;\\n\\t},\\n\\n\\t// arg is for internal usage only\\n\\tmap: function( elems, callback, arg ) {\\n\\t\\tvar length, value,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tret = [];\\n\\n\\t\\t// Go through the array, translating each of the items to their new values\\n\\t\\tif ( isArrayLike( elems ) ) {\\n\\t\\t\\tlength = elems.length;\\n\\t\\t\\tfor ( ; i < length; i++ ) {\\n\\t\\t\\t\\tvalue = callback( elems[ i ], i, arg );\\n\\n\\t\\t\\t\\tif ( value != null ) {\\n\\t\\t\\t\\t\\tret.push( value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Go through every key on the object,\\n\\t\\t} else {\\n\\t\\t\\tfor ( i in elems ) {\\n\\t\\t\\t\\tvalue = callback( elems[ i ], i, arg );\\n\\n\\t\\t\\t\\tif ( value != null ) {\\n\\t\\t\\t\\t\\tret.push( value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Flatten any nested arrays\\n\\t\\treturn concat.apply( [], ret );\\n\\t},\\n\\n\\t// A global GUID counter for objects\\n\\tguid: 1,\\n\\n\\t// jQuery.support is not used in Core but other projects attach their\\n\\t// properties to it so it needs to exist.\\n\\tsupport: support\\n} );\\n\\nif ( typeof Symbol === \"function\" ) {\\n\\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\\n}\\n\\n// Populate the class2type map\\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\\nfunction( i, name ) {\\n\\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\\n} );\\n\\nfunction isArrayLike( obj ) {\\n\\n\\t// Support: real iOS 8.2 only (not reproducible in simulator)\\n\\t// `in` check used to prevent JIT error (gh-2145)\\n\\t// hasOwn isn\\'t used here due to false negatives\\n\\t// regarding Nodelist length in IE\\n\\tvar length = !!obj && \"length\" in obj && obj.length,\\n\\t\\ttype = toType( obj );\\n\\n\\tif ( isFunction( obj ) || isWindow( obj ) ) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn type === \"array\" || length === 0 ||\\n\\t\\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\\n}\\nvar Sizzle =\\n/*!\\n * Sizzle CSS Selector Engine v2.3.3\\n * https://sizzlejs.com/\\n *\\n * Copyright jQuery Foundation and other contributors\\n * Released under the MIT license\\n * http://jquery.org/license\\n *\\n * Date: 2016-08-08\\n */\\n(function( window ) {\\n\\nvar i,\\n\\tsupport,\\n\\tExpr,\\n\\tgetText,\\n\\tisXML,\\n\\ttokenize,\\n\\tcompile,\\n\\tselect,\\n\\toutermostContext,\\n\\tsortInput,\\n\\thasDuplicate,\\n\\n\\t// Local document vars\\n\\tsetDocument,\\n\\tdocument,\\n\\tdocElem,\\n\\tdocumentIsHTML,\\n\\trbuggyQSA,\\n\\trbuggyMatches,\\n\\tmatches,\\n\\tcontains,\\n\\n\\t// Instance-specific data\\n\\texpando = \"sizzle\" + 1 * new Date(),\\n\\tpreferredDoc = window.document,\\n\\tdirruns = 0,\\n\\tdone = 0,\\n\\tclassCache = createCache(),\\n\\ttokenCache = createCache(),\\n\\tcompilerCache = createCache(),\\n\\tsortOrder = function( a, b ) {\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t},\\n\\n\\t// Instance methods\\n\\thasOwn = ({}).hasOwnProperty,\\n\\tarr = [],\\n\\tpop = arr.pop,\\n\\tpush_native = arr.push,\\n\\tpush = arr.push,\\n\\tslice = arr.slice,\\n\\t// Use a stripped-down indexOf as it\\'s faster than native\\n\\t// https://jsperf.com/thor-indexof-vs-for/5\\n\\tindexOf = function( list, elem ) {\\n\\t\\tvar i = 0,\\n\\t\\t\\tlen = list.length;\\n\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\tif ( list[i] === elem ) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t},\\n\\n\\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\\n\\n\\t// Regular expressions\\n\\n\\t// http://www.w3.org/TR/css3-selectors/#whitespace\\n\\twhitespace = \"[\\\\\\\\x20\\\\\\\\t\\\\\\\\r\\\\\\\\n\\\\\\\\f]\",\\n\\n\\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\\n\\tidentifier = \"(?:\\\\\\\\\\\\\\\\.|[\\\\\\\\w-]|[^\\\\0-\\\\\\\\xa0])+\",\\n\\n\\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\\n\\tattributes = \"\\\\\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\\n\\t\\t// Operator (capture 2)\\n\\t\\t\"*([*^$|!~]?=)\" + whitespace +\\n\\t\\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\\n\\t\\t\"*(?:\\'((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\'])*)\\'|\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\"|(\" + identifier + \"))|)\" + whitespace +\\n\\t\\t\"*\\\\\\\\]\",\\n\\n\\tpseudos = \":(\" + identifier + \")(?:\\\\\\\\((\" +\\n\\t\\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\\n\\t\\t// 1. quoted (capture 3; capture 4 or capture 5)\\n\\t\\t\"(\\'((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\'])*)\\'|\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\")|\" +\\n\\t\\t// 2. simple (capture 6)\\n\\t\\t\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\()[\\\\\\\\]]|\" + attributes + \")*)|\" +\\n\\t\\t// 3. anything else (capture 2)\\n\\t\\t\".*\" +\\n\\t\\t\")\\\\\\\\)|)\",\\n\\n\\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\\n\\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\\n\\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\\\\\\\\\])(?:\\\\\\\\\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\\n\\n\\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\\n\\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\\n\\n\\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\\\\\]\\'\\\\\"]*?)\" + whitespace + \"*\\\\\\\\]\", \"g\" ),\\n\\n\\trpseudo = new RegExp( pseudos ),\\n\\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\\n\\n\\tmatchExpr = {\\n\\t\\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\\n\\t\\t\"CLASS\": new RegExp( \"^\\\\\\\\.(\" + identifier + \")\" ),\\n\\t\\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\\n\\t\\t\"ATTR\": new RegExp( \"^\" + attributes ),\\n\\t\\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\\n\\t\\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\\\\\(\" + whitespace +\\n\\t\\t\\t\"*(even|odd|(([+-]|)(\\\\\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\\n\\t\\t\\t\"*(\\\\\\\\d+)|))\" + whitespace + \"*\\\\\\\\)|)\", \"i\" ),\\n\\t\\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\\n\\t\\t// For use in libraries implementing .is()\\n\\t\\t// We use this for POS matching in `select`\\n\\t\\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\\\\\(\" +\\n\\t\\t\\twhitespace + \"*((?:-\\\\\\\\d)?\\\\\\\\d*)\" + whitespace + \"*\\\\\\\\)|)(?=[^-]|$)\", \"i\" )\\n\\t},\\n\\n\\trinputs = /^(?:input|select|textarea|button)$/i,\\n\\trheader = /^h\\\\d$/i,\\n\\n\\trnative = /^[^{]+\\\\{\\\\s*\\\\[native \\\\w/,\\n\\n\\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\\n\\trquickExpr = /^(?:#([\\\\w-]+)|(\\\\w+)|\\\\.([\\\\w-]+))$/,\\n\\n\\trsibling = /[+~]/,\\n\\n\\t// CSS escapes\\n\\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\\n\\trunescape = new RegExp( \"\\\\\\\\\\\\\\\\([\\\\\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\\n\\tfunescape = function( _, escaped, escapedWhitespace ) {\\n\\t\\tvar high = \"0x\" + escaped - 0x10000;\\n\\t\\t// NaN means non-codepoint\\n\\t\\t// Support: Firefox<24\\n\\t\\t// Workaround erroneous numeric interpretation of +\"0x\"\\n\\t\\treturn high !== high || escapedWhitespace ?\\n\\t\\t\\tescaped :\\n\\t\\t\\thigh < 0 ?\\n\\t\\t\\t\\t// BMP codepoint\\n\\t\\t\\t\\tString.fromCharCode( high + 0x10000 ) :\\n\\t\\t\\t\\t// Supplemental Plane codepoint (surrogate pair)\\n\\t\\t\\t\\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\\n\\t},\\n\\n\\t// CSS string/identifier serialization\\n\\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\\n\\trcssescape = /([\\\\0-\\\\x1f\\\\x7f]|^-?\\\\d)|^-$|[^\\\\0-\\\\x1f\\\\x7f-\\\\uFFFF\\\\w-]/g,\\n\\tfcssescape = function( ch, asCodePoint ) {\\n\\t\\tif ( asCodePoint ) {\\n\\n\\t\\t\\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\\n\\t\\t\\tif ( ch === \"\\\\0\" ) {\\n\\t\\t\\t\\treturn \"\\\\uFFFD\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Control characters and (dependent upon position) numbers get escaped as code points\\n\\t\\t\\treturn ch.slice( 0, -1 ) + \"\\\\\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\\n\\t\\t}\\n\\n\\t\\t// Other potentially-special ASCII characters get backslash-escaped\\n\\t\\treturn \"\\\\\\\\\" + ch;\\n\\t},\\n\\n\\t// Used for iframes\\n\\t// See setDocument()\\n\\t// Removing the function wrapper causes a \"Permission Denied\"\\n\\t// error in IE\\n\\tunloadHandler = function() {\\n\\t\\tsetDocument();\\n\\t},\\n\\n\\tdisabledAncestor = addCombinator(\\n\\t\\tfunction( elem ) {\\n\\t\\t\\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\\n\\t\\t},\\n\\t\\t{ dir: \"parentNode\", next: \"legend\" }\\n\\t);\\n\\n// Optimize for push.apply( _, NodeList )\\ntry {\\n\\tpush.apply(\\n\\t\\t(arr = slice.call( preferredDoc.childNodes )),\\n\\t\\tpreferredDoc.childNodes\\n\\t);\\n\\t// Support: Android<4.0\\n\\t// Detect silently failing push.apply\\n\\tarr[ preferredDoc.childNodes.length ].nodeType;\\n} catch ( e ) {\\n\\tpush = { apply: arr.length ?\\n\\n\\t\\t// Leverage slice if possible\\n\\t\\tfunction( target, els ) {\\n\\t\\t\\tpush_native.apply( target, slice.call(els) );\\n\\t\\t} :\\n\\n\\t\\t// Support: IE<9\\n\\t\\t// Otherwise append directly\\n\\t\\tfunction( target, els ) {\\n\\t\\t\\tvar j = target.length,\\n\\t\\t\\t\\ti = 0;\\n\\t\\t\\t// Can\\'t trust NodeList.length\\n\\t\\t\\twhile ( (target[j++] = els[i++]) ) {}\\n\\t\\t\\ttarget.length = j - 1;\\n\\t\\t}\\n\\t};\\n}\\n\\nfunction Sizzle( selector, context, results, seed ) {\\n\\tvar m, i, elem, nid, match, groups, newSelector,\\n\\t\\tnewContext = context && context.ownerDocument,\\n\\n\\t\\t// nodeType defaults to 9, since context defaults to document\\n\\t\\tnodeType = context ? context.nodeType : 9;\\n\\n\\tresults = results || [];\\n\\n\\t// Return early from calls with invalid selector or context\\n\\tif ( typeof selector !== \"string\" || !selector ||\\n\\t\\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\\n\\n\\t\\treturn results;\\n\\t}\\n\\n\\t// Try to shortcut find operations (as opposed to filters) in HTML documents\\n\\tif ( !seed ) {\\n\\n\\t\\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\\n\\t\\t\\tsetDocument( context );\\n\\t\\t}\\n\\t\\tcontext = context || document;\\n\\n\\t\\tif ( documentIsHTML ) {\\n\\n\\t\\t\\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\\n\\t\\t\\t// (excepting DocumentFragment context, where the methods don\\'t exist)\\n\\t\\t\\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\\n\\n\\t\\t\\t\\t// ID selector\\n\\t\\t\\t\\tif ( (m = match[1]) ) {\\n\\n\\t\\t\\t\\t\\t// Document context\\n\\t\\t\\t\\t\\tif ( nodeType === 9 ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = context.getElementById( m )) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: IE, Opera, Webkit\\n\\t\\t\\t\\t\\t\\t\\t// TODO: identify versions\\n\\t\\t\\t\\t\\t\\t\\t// getElementById can match elements by name instead of ID\\n\\t\\t\\t\\t\\t\\t\\tif ( elem.id === m ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Element context\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE, Opera, Webkit\\n\\t\\t\\t\\t\\t\\t// TODO: identify versions\\n\\t\\t\\t\\t\\t\\t// getElementById can match elements by name instead of ID\\n\\t\\t\\t\\t\\t\\tif ( newContext && (elem = newContext.getElementById( m )) &&\\n\\t\\t\\t\\t\\t\\t\\tcontains( context, elem ) &&\\n\\t\\t\\t\\t\\t\\t\\telem.id === m ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Type selector\\n\\t\\t\\t\\t} else if ( match[2] ) {\\n\\t\\t\\t\\t\\tpush.apply( results, context.getElementsByTagName( selector ) );\\n\\t\\t\\t\\t\\treturn results;\\n\\n\\t\\t\\t\\t// Class selector\\n\\t\\t\\t\\t} else if ( (m = match[3]) && support.getElementsByClassName &&\\n\\t\\t\\t\\t\\tcontext.getElementsByClassName ) {\\n\\n\\t\\t\\t\\t\\tpush.apply( results, context.getElementsByClassName( m ) );\\n\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Take advantage of querySelectorAll\\n\\t\\t\\tif ( support.qsa &&\\n\\t\\t\\t\\t!compilerCache[ selector + \" \" ] &&\\n\\t\\t\\t\\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\\n\\n\\t\\t\\t\\tif ( nodeType !== 1 ) {\\n\\t\\t\\t\\t\\tnewContext = context;\\n\\t\\t\\t\\t\\tnewSelector = selector;\\n\\n\\t\\t\\t\\t// qSA looks outside Element context, which is not what we want\\n\\t\\t\\t\\t// Thanks to Andrew Dupont for this workaround technique\\n\\t\\t\\t\\t// Support: IE <=8\\n\\t\\t\\t\\t// Exclude object elements\\n\\t\\t\\t\\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\\n\\n\\t\\t\\t\\t\\t// Capture the context ID, setting it first if necessary\\n\\t\\t\\t\\t\\tif ( (nid = context.getAttribute( \"id\" )) ) {\\n\\t\\t\\t\\t\\t\\tnid = nid.replace( rcssescape, fcssescape );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcontext.setAttribute( \"id\", (nid = expando) );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Prefix every selector in the list\\n\\t\\t\\t\\t\\tgroups = tokenize( selector );\\n\\t\\t\\t\\t\\ti = groups.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnewSelector = groups.join( \",\" );\\n\\n\\t\\t\\t\\t\\t// Expand context for sibling selectors\\n\\t\\t\\t\\t\\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\\n\\t\\t\\t\\t\\t\\tcontext;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( newSelector ) {\\n\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\tpush.apply( results,\\n\\t\\t\\t\\t\\t\\t\\tnewContext.querySelectorAll( newSelector )\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t} catch ( qsaError ) {\\n\\t\\t\\t\\t\\t} finally {\\n\\t\\t\\t\\t\\t\\tif ( nid === expando ) {\\n\\t\\t\\t\\t\\t\\t\\tcontext.removeAttribute( \"id\" );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// All others\\n\\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\\n}\\n\\n/**\\n * Create key-value caches of limited size\\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\\n *\\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\\n *\\tdeleting the oldest entry\\n */\\nfunction createCache() {\\n\\tvar keys = [];\\n\\n\\tfunction cache( key, value ) {\\n\\t\\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\\n\\t\\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\\n\\t\\t\\t// Only keep the most recent entries\\n\\t\\t\\tdelete cache[ keys.shift() ];\\n\\t\\t}\\n\\t\\treturn (cache[ key + \" \" ] = value);\\n\\t}\\n\\treturn cache;\\n}\\n\\n/**\\n * Mark a function for special use by Sizzle\\n * @param {Function} fn The function to mark\\n */\\nfunction markFunction( fn ) {\\n\\tfn[ expando ] = true;\\n\\treturn fn;\\n}\\n\\n/**\\n * Support testing using an element\\n * @param {Function} fn Passed the created element and returns a boolean result\\n */\\nfunction assert( fn ) {\\n\\tvar el = document.createElement(\"fieldset\");\\n\\n\\ttry {\\n\\t\\treturn !!fn( el );\\n\\t} catch (e) {\\n\\t\\treturn false;\\n\\t} finally {\\n\\t\\t// Remove from its parent by default\\n\\t\\tif ( el.parentNode ) {\\n\\t\\t\\tel.parentNode.removeChild( el );\\n\\t\\t}\\n\\t\\t// release memory in IE\\n\\t\\tel = null;\\n\\t}\\n}\\n\\n/**\\n * Adds the same handler for all of the specified attrs\\n * @param {String} attrs Pipe-separated list of attributes\\n * @param {Function} handler The method that will be applied\\n */\\nfunction addHandle( attrs, handler ) {\\n\\tvar arr = attrs.split(\"|\"),\\n\\t\\ti = arr.length;\\n\\n\\twhile ( i-- ) {\\n\\t\\tExpr.attrHandle[ arr[i] ] = handler;\\n\\t}\\n}\\n\\n/**\\n * Checks document order of two siblings\\n * @param {Element} a\\n * @param {Element} b\\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\\n */\\nfunction siblingCheck( a, b ) {\\n\\tvar cur = b && a,\\n\\t\\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\\n\\t\\t\\ta.sourceIndex - b.sourceIndex;\\n\\n\\t// Use IE sourceIndex if available on both nodes\\n\\tif ( diff ) {\\n\\t\\treturn diff;\\n\\t}\\n\\n\\t// Check if b follows a\\n\\tif ( cur ) {\\n\\t\\twhile ( (cur = cur.nextSibling) ) {\\n\\t\\t\\tif ( cur === b ) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn a ? 1 : -1;\\n}\\n\\n/**\\n * Returns a function to use in pseudos for input types\\n * @param {String} type\\n */\\nfunction createInputPseudo( type ) {\\n\\treturn function( elem ) {\\n\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\treturn name === \"input\" && elem.type === type;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for buttons\\n * @param {String} type\\n */\\nfunction createButtonPseudo( type ) {\\n\\treturn function( elem ) {\\n\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\treturn (name === \"input\" || name === \"button\") && elem.type === type;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for :enabled/:disabled\\n * @param {Boolean} disabled true for :disabled; false for :enabled\\n */\\nfunction createDisabledPseudo( disabled ) {\\n\\n\\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\\n\\treturn function( elem ) {\\n\\n\\t\\t// Only certain elements can match :enabled or :disabled\\n\\t\\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\\n\\t\\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\\n\\t\\tif ( \"form\" in elem ) {\\n\\n\\t\\t\\t// Check for inherited disabledness on relevant non-disabled elements:\\n\\t\\t\\t// * listed form-associated elements in a disabled fieldset\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\\n\\t\\t\\t// * option elements in a disabled optgroup\\n\\t\\t\\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\\n\\t\\t\\t// All such elements have a \"form\" property.\\n\\t\\t\\tif ( elem.parentNode && elem.disabled === false ) {\\n\\n\\t\\t\\t\\t// Option elements defer to a parent optgroup if present\\n\\t\\t\\t\\tif ( \"label\" in elem ) {\\n\\t\\t\\t\\t\\tif ( \"label\" in elem.parentNode ) {\\n\\t\\t\\t\\t\\t\\treturn elem.parentNode.disabled === disabled;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn elem.disabled === disabled;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Support: IE 6 - 11\\n\\t\\t\\t\\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\\n\\t\\t\\t\\treturn elem.isDisabled === disabled ||\\n\\n\\t\\t\\t\\t\\t// Where there is no isDisabled, check manually\\n\\t\\t\\t\\t\\t/* jshint -W018 */\\n\\t\\t\\t\\t\\telem.isDisabled !== !disabled &&\\n\\t\\t\\t\\t\\t\\tdisabledAncestor( elem ) === disabled;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn elem.disabled === disabled;\\n\\n\\t\\t// Try to winnow out elements that can\\'t be disabled before trusting the disabled property.\\n\\t\\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn\\'t\\n\\t\\t// even exist on them, let alone have a boolean value.\\n\\t\\t} else if ( \"label\" in elem ) {\\n\\t\\t\\treturn elem.disabled === disabled;\\n\\t\\t}\\n\\n\\t\\t// Remaining elements are neither :enabled nor :disabled\\n\\t\\treturn false;\\n\\t};\\n}\\n\\n/**\\n * Returns a function to use in pseudos for positionals\\n * @param {Function} fn\\n */\\nfunction createPositionalPseudo( fn ) {\\n\\treturn markFunction(function( argument ) {\\n\\t\\targument = +argument;\\n\\t\\treturn markFunction(function( seed, matches ) {\\n\\t\\t\\tvar j,\\n\\t\\t\\t\\tmatchIndexes = fn( [], seed.length, argument ),\\n\\t\\t\\t\\ti = matchIndexes.length;\\n\\n\\t\\t\\t// Match elements found at the specified indexes\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( seed[ (j = matchIndexes[i]) ] ) {\\n\\t\\t\\t\\t\\tseed[j] = !(matches[j] = seed[j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t});\\n}\\n\\n/**\\n * Checks a node for validity as a Sizzle context\\n * @param {Element|Object=} context\\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\\n */\\nfunction testContext( context ) {\\n\\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\\n}\\n\\n// Expose support vars for convenience\\nsupport = Sizzle.support = {};\\n\\n/**\\n * Detects XML nodes\\n * @param {Element|Object} elem An element or a document\\n * @returns {Boolean} True iff elem is a non-HTML XML node\\n */\\nisXML = Sizzle.isXML = function( elem ) {\\n\\t// documentElement is verified for cases where it doesn\\'t yet exist\\n\\t// (such as loading iframes in IE - #4833)\\n\\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\\n\\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\\n};\\n\\n/**\\n * Sets document-related variables once based on the current document\\n * @param {Element|Object} [doc] An element or document object to use to set the document\\n * @returns {Object} Returns the current document\\n */\\nsetDocument = Sizzle.setDocument = function( node ) {\\n\\tvar hasCompare, subWindow,\\n\\t\\tdoc = node ? node.ownerDocument || node : preferredDoc;\\n\\n\\t// Return early if doc is invalid or already selected\\n\\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\\n\\t\\treturn document;\\n\\t}\\n\\n\\t// Update global variables\\n\\tdocument = doc;\\n\\tdocElem = document.documentElement;\\n\\tdocumentIsHTML = !isXML( document );\\n\\n\\t// Support: IE 9-11, Edge\\n\\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\\n\\tif ( preferredDoc !== document &&\\n\\t\\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\\n\\n\\t\\t// Support: IE 11, Edge\\n\\t\\tif ( subWindow.addEventListener ) {\\n\\t\\t\\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\\n\\n\\t\\t// Support: IE 9 - 10 only\\n\\t\\t} else if ( subWindow.attachEvent ) {\\n\\t\\t\\tsubWindow.attachEvent( \"onunload\", unloadHandler );\\n\\t\\t}\\n\\t}\\n\\n\\t/* Attributes\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Support: IE<8\\n\\t// Verify that getAttribute really returns attributes and not properties\\n\\t// (excepting IE8 booleans)\\n\\tsupport.attributes = assert(function( el ) {\\n\\t\\tel.className = \"i\";\\n\\t\\treturn !el.getAttribute(\"className\");\\n\\t});\\n\\n\\t/* getElement(s)By*\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Check if getElementsByTagName(\"*\") returns only elements\\n\\tsupport.getElementsByTagName = assert(function( el ) {\\n\\t\\tel.appendChild( document.createComment(\"\") );\\n\\t\\treturn !el.getElementsByTagName(\"*\").length;\\n\\t});\\n\\n\\t// Support: IE<9\\n\\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\\n\\n\\t// Support: IE<10\\n\\t// Check if getElementById returns elements by name\\n\\t// The broken getElementById methods don\\'t pick up programmatically-set names,\\n\\t// so use a roundabout getElementsByName test\\n\\tsupport.getById = assert(function( el ) {\\n\\t\\tdocElem.appendChild( el ).id = expando;\\n\\t\\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\\n\\t});\\n\\n\\t// ID filter and find\\n\\tif ( support.getById ) {\\n\\t\\tExpr.filter[\"ID\"] = function( id ) {\\n\\t\\t\\tvar attrId = id.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn elem.getAttribute(\"id\") === attrId;\\n\\t\\t\\t};\\n\\t\\t};\\n\\t\\tExpr.find[\"ID\"] = function( id, context ) {\\n\\t\\t\\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\\n\\t\\t\\t\\tvar elem = context.getElementById( id );\\n\\t\\t\\t\\treturn elem ? [ elem ] : [];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t} else {\\n\\t\\tExpr.filter[\"ID\"] =  function( id ) {\\n\\t\\t\\tvar attrId = id.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\\n\\t\\t\\t\\t\\telem.getAttributeNode(\"id\");\\n\\t\\t\\t\\treturn node && node.value === attrId;\\n\\t\\t\\t};\\n\\t\\t};\\n\\n\\t\\t// Support: IE 6 - 7 only\\n\\t\\t// getElementById is not reliable as a find shortcut\\n\\t\\tExpr.find[\"ID\"] = function( id, context ) {\\n\\t\\t\\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\\n\\t\\t\\t\\tvar node, i, elems,\\n\\t\\t\\t\\t\\telem = context.getElementById( id );\\n\\n\\t\\t\\t\\tif ( elem ) {\\n\\n\\t\\t\\t\\t\\t// Verify the id attribute\\n\\t\\t\\t\\t\\tnode = elem.getAttributeNode(\"id\");\\n\\t\\t\\t\\t\\tif ( node && node.value === id ) {\\n\\t\\t\\t\\t\\t\\treturn [ elem ];\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Fall back on getElementsByName\\n\\t\\t\\t\\t\\telems = context.getElementsByName( id );\\n\\t\\t\\t\\t\\ti = 0;\\n\\t\\t\\t\\t\\twhile ( (elem = elems[i++]) ) {\\n\\t\\t\\t\\t\\t\\tnode = elem.getAttributeNode(\"id\");\\n\\t\\t\\t\\t\\t\\tif ( node && node.value === id ) {\\n\\t\\t\\t\\t\\t\\t\\treturn [ elem ];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn [];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\n\\t// Tag\\n\\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\\n\\t\\tfunction( tag, context ) {\\n\\t\\t\\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\\n\\t\\t\\t\\treturn context.getElementsByTagName( tag );\\n\\n\\t\\t\\t// DocumentFragment nodes don\\'t have gEBTN\\n\\t\\t\\t} else if ( support.qsa ) {\\n\\t\\t\\t\\treturn context.querySelectorAll( tag );\\n\\t\\t\\t}\\n\\t\\t} :\\n\\n\\t\\tfunction( tag, context ) {\\n\\t\\t\\tvar elem,\\n\\t\\t\\t\\ttmp = [],\\n\\t\\t\\t\\ti = 0,\\n\\t\\t\\t\\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\\n\\t\\t\\t\\tresults = context.getElementsByTagName( tag );\\n\\n\\t\\t\\t// Filter out possible comments\\n\\t\\t\\tif ( tag === \"*\" ) {\\n\\t\\t\\t\\twhile ( (elem = results[i++]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\t\\t\\t\\ttmp.push( elem );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn tmp;\\n\\t\\t\\t}\\n\\t\\t\\treturn results;\\n\\t\\t};\\n\\n\\t// Class\\n\\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\\n\\t\\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\\n\\t\\t\\treturn context.getElementsByClassName( className );\\n\\t\\t}\\n\\t};\\n\\n\\t/* QSA/matchesSelector\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// QSA and matchesSelector support\\n\\n\\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\\n\\trbuggyMatches = [];\\n\\n\\t// qSa(:focus) reports false when true (Chrome 21)\\n\\t// We allow this because of a bug in IE8/9 that throws an error\\n\\t// whenever `document.activeElement` is accessed on an iframe\\n\\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\\n\\t// See https://bugs.jquery.com/ticket/13378\\n\\trbuggyQSA = [];\\n\\n\\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\\n\\t\\t// Build QSA regex\\n\\t\\t// Regex strategy adopted from Diego Perini\\n\\t\\tassert(function( el ) {\\n\\t\\t\\t// Select is set to empty string on purpose\\n\\t\\t\\t// This is to test IE\\'s treatment of not explicitly\\n\\t\\t\\t// setting a boolean content attribute,\\n\\t\\t\\t// since its presence should be enough\\n\\t\\t\\t// https://bugs.jquery.com/ticket/12359\\n\\t\\t\\tdocElem.appendChild( el ).innerHTML = \"<a id=\\'\" + expando + \"\\'></a>\" +\\n\\t\\t\\t\\t\"<select id=\\'\" + expando + \"-\\\\r\\\\\\\\\\' msallowcapture=\\'\\'>\" +\\n\\t\\t\\t\\t\"<option selected=\\'\\'></option></select>\";\\n\\n\\t\\t\\t// Support: IE8, Opera 11-12.16\\n\\t\\t\\t// Nothing should be selected when empty strings follow ^= or $= or *=\\n\\t\\t\\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\\n\\t\\t\\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\\n\\t\\t\\tif ( el.querySelectorAll(\"[msallowcapture^=\\'\\']\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:\\'\\'|\\\\\"\\\\\")\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: IE8\\n\\t\\t\\t// Boolean attributes and \"value\" are not treated correctly\\n\\t\\t\\tif ( !el.querySelectorAll(\"[selected]\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \"\\\\\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\\n\\t\\t\\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\"~=\");\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Webkit/Opera - :checked should return selected option elements\\n\\t\\t\\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\\n\\t\\t\\t// IE8 throws error here and will not see later tests\\n\\t\\t\\tif ( !el.querySelectorAll(\":checked\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\":checked\");\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: Safari 8+, iOS 8+\\n\\t\\t\\t// https://bugs.webkit.org/show_bug.cgi?id=136851\\n\\t\\t\\t// In-page `selector#id sibling-combinator selector` fails\\n\\t\\t\\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\\n\\t\\t\\t\\trbuggyQSA.push(\".#.+[+~]\");\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tassert(function( el ) {\\n\\t\\t\\tel.innerHTML = \"<a href=\\'\\' disabled=\\'disabled\\'></a>\" +\\n\\t\\t\\t\\t\"<select disabled=\\'disabled\\'><option/></select>\";\\n\\n\\t\\t\\t// Support: Windows 8 Native Apps\\n\\t\\t\\t// The type and name attributes are restricted during .innerHTML assignment\\n\\t\\t\\tvar input = document.createElement(\"input\");\\n\\t\\t\\tinput.setAttribute( \"type\", \"hidden\" );\\n\\t\\t\\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\\n\\n\\t\\t\\t// Support: IE8\\n\\t\\t\\t// Enforce case-sensitivity of name attribute\\n\\t\\t\\tif ( el.querySelectorAll(\"[name=d]\").length ) {\\n\\t\\t\\t\\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\\n\\t\\t\\t// IE8 throws error here and will not see later tests\\n\\t\\t\\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\\n\\t\\t\\t\\trbuggyQSA.push( \":enabled\", \":disabled\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Support: IE9-11+\\n\\t\\t\\t// IE\\'s :disabled selector does not pick up the children of disabled fieldsets\\n\\t\\t\\tdocElem.appendChild( el ).disabled = true;\\n\\t\\t\\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\\n\\t\\t\\t\\trbuggyQSA.push( \":enabled\", \":disabled\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Opera 10-11 does not throw on post-comma invalid pseudos\\n\\t\\t\\tel.querySelectorAll(\"*,:x\");\\n\\t\\t\\trbuggyQSA.push(\",.*:\");\\n\\t\\t});\\n\\t}\\n\\n\\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\\n\\t\\tdocElem.webkitMatchesSelector ||\\n\\t\\tdocElem.mozMatchesSelector ||\\n\\t\\tdocElem.oMatchesSelector ||\\n\\t\\tdocElem.msMatchesSelector) )) ) {\\n\\n\\t\\tassert(function( el ) {\\n\\t\\t\\t// Check to see if it\\'s possible to do matchesSelector\\n\\t\\t\\t// on a disconnected node (IE 9)\\n\\t\\t\\tsupport.disconnectedMatch = matches.call( el, \"*\" );\\n\\n\\t\\t\\t// This should fail with an exception\\n\\t\\t\\t// Gecko does not error, returns false instead\\n\\t\\t\\tmatches.call( el, \"[s!=\\'\\']:x\" );\\n\\t\\t\\trbuggyMatches.push( \"!=\", pseudos );\\n\\t\\t});\\n\\t}\\n\\n\\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\\n\\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\\n\\n\\t/* Contains\\n\\t---------------------------------------------------------------------- */\\n\\thasCompare = rnative.test( docElem.compareDocumentPosition );\\n\\n\\t// Element contains another\\n\\t// Purposefully self-exclusive\\n\\t// As in, an element does not contain itself\\n\\tcontains = hasCompare || rnative.test( docElem.contains ) ?\\n\\t\\tfunction( a, b ) {\\n\\t\\t\\tvar adown = a.nodeType === 9 ? a.documentElement : a,\\n\\t\\t\\t\\tbup = b && b.parentNode;\\n\\t\\t\\treturn a === bup || !!( bup && bup.nodeType === 1 && (\\n\\t\\t\\t\\tadown.contains ?\\n\\t\\t\\t\\t\\tadown.contains( bup ) :\\n\\t\\t\\t\\t\\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\\n\\t\\t\\t));\\n\\t\\t} :\\n\\t\\tfunction( a, b ) {\\n\\t\\t\\tif ( b ) {\\n\\t\\t\\t\\twhile ( (b = b.parentNode) ) {\\n\\t\\t\\t\\t\\tif ( b === a ) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n\\n\\t/* Sorting\\n\\t---------------------------------------------------------------------- */\\n\\n\\t// Document order sorting\\n\\tsortOrder = hasCompare ?\\n\\tfunction( a, b ) {\\n\\n\\t\\t// Flag for duplicate removal\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\t// Sort on method existence if only one input has compareDocumentPosition\\n\\t\\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\\n\\t\\tif ( compare ) {\\n\\t\\t\\treturn compare;\\n\\t\\t}\\n\\n\\t\\t// Calculate position if both inputs belong to the same document\\n\\t\\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\\n\\t\\t\\ta.compareDocumentPosition( b ) :\\n\\n\\t\\t\\t// Otherwise we know they are disconnected\\n\\t\\t\\t1;\\n\\n\\t\\t// Disconnected nodes\\n\\t\\tif ( compare & 1 ||\\n\\t\\t\\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\\n\\n\\t\\t\\t// Choose the first element that is related to our preferred document\\n\\t\\t\\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t\\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Maintain original order\\n\\t\\t\\treturn sortInput ?\\n\\t\\t\\t\\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\\n\\t\\t\\t\\t0;\\n\\t\\t}\\n\\n\\t\\treturn compare & 4 ? -1 : 1;\\n\\t} :\\n\\tfunction( a, b ) {\\n\\t\\t// Exit early if the nodes are identical\\n\\t\\tif ( a === b ) {\\n\\t\\t\\thasDuplicate = true;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tvar cur,\\n\\t\\t\\ti = 0,\\n\\t\\t\\taup = a.parentNode,\\n\\t\\t\\tbup = b.parentNode,\\n\\t\\t\\tap = [ a ],\\n\\t\\t\\tbp = [ b ];\\n\\n\\t\\t// Parentless nodes are either documents or disconnected\\n\\t\\tif ( !aup || !bup ) {\\n\\t\\t\\treturn a === document ? -1 :\\n\\t\\t\\t\\tb === document ? 1 :\\n\\t\\t\\t\\taup ? -1 :\\n\\t\\t\\t\\tbup ? 1 :\\n\\t\\t\\t\\tsortInput ?\\n\\t\\t\\t\\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\\n\\t\\t\\t\\t0;\\n\\n\\t\\t// If the nodes are siblings, we can do a quick check\\n\\t\\t} else if ( aup === bup ) {\\n\\t\\t\\treturn siblingCheck( a, b );\\n\\t\\t}\\n\\n\\t\\t// Otherwise we need full lists of their ancestors for comparison\\n\\t\\tcur = a;\\n\\t\\twhile ( (cur = cur.parentNode) ) {\\n\\t\\t\\tap.unshift( cur );\\n\\t\\t}\\n\\t\\tcur = b;\\n\\t\\twhile ( (cur = cur.parentNode) ) {\\n\\t\\t\\tbp.unshift( cur );\\n\\t\\t}\\n\\n\\t\\t// Walk down the tree looking for a discrepancy\\n\\t\\twhile ( ap[i] === bp[i] ) {\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\treturn i ?\\n\\t\\t\\t// Do a sibling check if the nodes have a common ancestor\\n\\t\\t\\tsiblingCheck( ap[i], bp[i] ) :\\n\\n\\t\\t\\t// Otherwise nodes in our document sort first\\n\\t\\t\\tap[i] === preferredDoc ? -1 :\\n\\t\\t\\tbp[i] === preferredDoc ? 1 :\\n\\t\\t\\t0;\\n\\t};\\n\\n\\treturn document;\\n};\\n\\nSizzle.matches = function( expr, elements ) {\\n\\treturn Sizzle( expr, null, null, elements );\\n};\\n\\nSizzle.matchesSelector = function( elem, expr ) {\\n\\t// Set document vars if needed\\n\\tif ( ( elem.ownerDocument || elem ) !== document ) {\\n\\t\\tsetDocument( elem );\\n\\t}\\n\\n\\t// Make sure that attribute selectors are quoted\\n\\texpr = expr.replace( rattributeQuotes, \"=\\'$1\\']\" );\\n\\n\\tif ( support.matchesSelector && documentIsHTML &&\\n\\t\\t!compilerCache[ expr + \" \" ] &&\\n\\t\\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\\n\\t\\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\\n\\n\\t\\ttry {\\n\\t\\t\\tvar ret = matches.call( elem, expr );\\n\\n\\t\\t\\t// IE 9\\'s matchesSelector returns false on disconnected nodes\\n\\t\\t\\tif ( ret || support.disconnectedMatch ||\\n\\t\\t\\t\\t\\t// As well, disconnected nodes are said to be in a document\\n\\t\\t\\t\\t\\t// fragment in IE 9\\n\\t\\t\\t\\t\\telem.document && elem.document.nodeType !== 11 ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\t\\t} catch (e) {}\\n\\t}\\n\\n\\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\\n};\\n\\nSizzle.contains = function( context, elem ) {\\n\\t// Set document vars if needed\\n\\tif ( ( context.ownerDocument || context ) !== document ) {\\n\\t\\tsetDocument( context );\\n\\t}\\n\\treturn contains( context, elem );\\n};\\n\\nSizzle.attr = function( elem, name ) {\\n\\t// Set document vars if needed\\n\\tif ( ( elem.ownerDocument || elem ) !== document ) {\\n\\t\\tsetDocument( elem );\\n\\t}\\n\\n\\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\\n\\t\\t// Don\\'t get fooled by Object.prototype properties (jQuery #13807)\\n\\t\\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\\n\\t\\t\\tfn( elem, name, !documentIsHTML ) :\\n\\t\\t\\tundefined;\\n\\n\\treturn val !== undefined ?\\n\\t\\tval :\\n\\t\\tsupport.attributes || !documentIsHTML ?\\n\\t\\t\\telem.getAttribute( name ) :\\n\\t\\t\\t(val = elem.getAttributeNode(name)) && val.specified ?\\n\\t\\t\\t\\tval.value :\\n\\t\\t\\t\\tnull;\\n};\\n\\nSizzle.escape = function( sel ) {\\n\\treturn (sel + \"\").replace( rcssescape, fcssescape );\\n};\\n\\nSizzle.error = function( msg ) {\\n\\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\\n};\\n\\n/**\\n * Document sorting and removing duplicates\\n * @param {ArrayLike} results\\n */\\nSizzle.uniqueSort = function( results ) {\\n\\tvar elem,\\n\\t\\tduplicates = [],\\n\\t\\tj = 0,\\n\\t\\ti = 0;\\n\\n\\t// Unless we *know* we can detect duplicates, assume their presence\\n\\thasDuplicate = !support.detectDuplicates;\\n\\tsortInput = !support.sortStable && results.slice( 0 );\\n\\tresults.sort( sortOrder );\\n\\n\\tif ( hasDuplicate ) {\\n\\t\\twhile ( (elem = results[i++]) ) {\\n\\t\\t\\tif ( elem === results[ i ] ) {\\n\\t\\t\\t\\tj = duplicates.push( i );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile ( j-- ) {\\n\\t\\t\\tresults.splice( duplicates[ j ], 1 );\\n\\t\\t}\\n\\t}\\n\\n\\t// Clear input after sorting to release objects\\n\\t// See https://github.com/jquery/sizzle/pull/225\\n\\tsortInput = null;\\n\\n\\treturn results;\\n};\\n\\n/**\\n * Utility function for retrieving the text value of an array of DOM nodes\\n * @param {Array|Element} elem\\n */\\ngetText = Sizzle.getText = function( elem ) {\\n\\tvar node,\\n\\t\\tret = \"\",\\n\\t\\ti = 0,\\n\\t\\tnodeType = elem.nodeType;\\n\\n\\tif ( !nodeType ) {\\n\\t\\t// If no nodeType, this is expected to be an array\\n\\t\\twhile ( (node = elem[i++]) ) {\\n\\t\\t\\t// Do not traverse comment nodes\\n\\t\\t\\tret += getText( node );\\n\\t\\t}\\n\\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\\n\\t\\t// Use textContent for elements\\n\\t\\t// innerText usage removed for consistency of new lines (jQuery #11153)\\n\\t\\tif ( typeof elem.textContent === \"string\" ) {\\n\\t\\t\\treturn elem.textContent;\\n\\t\\t} else {\\n\\t\\t\\t// Traverse its children\\n\\t\\t\\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\\n\\t\\t\\t\\tret += getText( elem );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else if ( nodeType === 3 || nodeType === 4 ) {\\n\\t\\treturn elem.nodeValue;\\n\\t}\\n\\t// Do not include comment or processing instruction nodes\\n\\n\\treturn ret;\\n};\\n\\nExpr = Sizzle.selectors = {\\n\\n\\t// Can be adjusted by the user\\n\\tcacheLength: 50,\\n\\n\\tcreatePseudo: markFunction,\\n\\n\\tmatch: matchExpr,\\n\\n\\tattrHandle: {},\\n\\n\\tfind: {},\\n\\n\\trelative: {\\n\\t\\t\">\": { dir: \"parentNode\", first: true },\\n\\t\\t\" \": { dir: \"parentNode\" },\\n\\t\\t\"+\": { dir: \"previousSibling\", first: true },\\n\\t\\t\"~\": { dir: \"previousSibling\" }\\n\\t},\\n\\n\\tpreFilter: {\\n\\t\\t\"ATTR\": function( match ) {\\n\\t\\t\\tmatch[1] = match[1].replace( runescape, funescape );\\n\\n\\t\\t\\t// Move the given value to match[3] whether quoted or unquoted\\n\\t\\t\\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\\n\\n\\t\\t\\tif ( match[2] === \"~=\" ) {\\n\\t\\t\\t\\tmatch[3] = \" \" + match[3] + \" \";\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn match.slice( 0, 4 );\\n\\t\\t},\\n\\n\\t\\t\"CHILD\": function( match ) {\\n\\t\\t\\t/* matches from matchExpr[\"CHILD\"]\\n\\t\\t\\t\\t1 type (only|nth|...)\\n\\t\\t\\t\\t2 what (child|of-type)\\n\\t\\t\\t\\t3 argument (even|odd|\\\\d*|\\\\d*n([+-]\\\\d+)?|...)\\n\\t\\t\\t\\t4 xn-component of xn+y argument ([+-]?\\\\d*n|)\\n\\t\\t\\t\\t5 sign of xn-component\\n\\t\\t\\t\\t6 x of xn-component\\n\\t\\t\\t\\t7 sign of y-component\\n\\t\\t\\t\\t8 y of y-component\\n\\t\\t\\t*/\\n\\t\\t\\tmatch[1] = match[1].toLowerCase();\\n\\n\\t\\t\\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\\n\\t\\t\\t\\t// nth-* requires argument\\n\\t\\t\\t\\tif ( !match[3] ) {\\n\\t\\t\\t\\t\\tSizzle.error( match[0] );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// numeric x and y parameters for Expr.filter.CHILD\\n\\t\\t\\t\\t// remember that false/true cast respectively to 0/1\\n\\t\\t\\t\\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\\n\\t\\t\\t\\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\\n\\n\\t\\t\\t// other types prohibit arguments\\n\\t\\t\\t} else if ( match[3] ) {\\n\\t\\t\\t\\tSizzle.error( match[0] );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn match;\\n\\t\\t},\\n\\n\\t\\t\"PSEUDO\": function( match ) {\\n\\t\\t\\tvar excess,\\n\\t\\t\\t\\tunquoted = !match[6] && match[2];\\n\\n\\t\\t\\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Accept quoted arguments as-is\\n\\t\\t\\tif ( match[3] ) {\\n\\t\\t\\t\\tmatch[2] = match[4] || match[5] || \"\";\\n\\n\\t\\t\\t// Strip excess characters from unquoted arguments\\n\\t\\t\\t} else if ( unquoted && rpseudo.test( unquoted ) &&\\n\\t\\t\\t\\t// Get excess from tokenize (recursively)\\n\\t\\t\\t\\t(excess = tokenize( unquoted, true )) &&\\n\\t\\t\\t\\t// advance to the next closing parenthesis\\n\\t\\t\\t\\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\\n\\n\\t\\t\\t\\t// excess is a negative index\\n\\t\\t\\t\\tmatch[0] = match[0].slice( 0, excess );\\n\\t\\t\\t\\tmatch[2] = unquoted.slice( 0, excess );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Return only captures needed by the pseudo filter method (type and argument)\\n\\t\\t\\treturn match.slice( 0, 3 );\\n\\t\\t}\\n\\t},\\n\\n\\tfilter: {\\n\\n\\t\\t\"TAG\": function( nodeNameSelector ) {\\n\\t\\t\\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\\n\\t\\t\\treturn nodeNameSelector === \"*\" ?\\n\\t\\t\\t\\tfunction() { return true; } :\\n\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\\n\\t\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\"CLASS\": function( className ) {\\n\\t\\t\\tvar pattern = classCache[ className + \" \" ];\\n\\n\\t\\t\\treturn pattern ||\\n\\t\\t\\t\\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\\n\\t\\t\\t\\tclassCache( className, function( elem ) {\\n\\t\\t\\t\\t\\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\\n\\t\\t\\t\\t});\\n\\t\\t},\\n\\n\\t\\t\"ATTR\": function( name, operator, check ) {\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar result = Sizzle.attr( elem, name );\\n\\n\\t\\t\\t\\tif ( result == null ) {\\n\\t\\t\\t\\t\\treturn operator === \"!=\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( !operator ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tresult += \"\";\\n\\n\\t\\t\\t\\treturn operator === \"=\" ? result === check :\\n\\t\\t\\t\\t\\toperator === \"!=\" ? result !== check :\\n\\t\\t\\t\\t\\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\\n\\t\\t\\t\\t\\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\\n\\t\\t\\t\\t\\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\\n\\t\\t\\t\\t\\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\\n\\t\\t\\t\\t\\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\\n\\t\\t\\t\\t\\tfalse;\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\"CHILD\": function( type, what, argument, first, last ) {\\n\\t\\t\\tvar simple = type.slice( 0, 3 ) !== \"nth\",\\n\\t\\t\\t\\tforward = type.slice( -4 ) !== \"last\",\\n\\t\\t\\t\\tofType = what === \"of-type\";\\n\\n\\t\\t\\treturn first === 1 && last === 0 ?\\n\\n\\t\\t\\t\\t// Shortcut for :nth-*(n)\\n\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\treturn !!elem.parentNode;\\n\\t\\t\\t\\t} :\\n\\n\\t\\t\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\t\\t\\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\\n\\t\\t\\t\\t\\t\\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\\n\\t\\t\\t\\t\\t\\tparent = elem.parentNode,\\n\\t\\t\\t\\t\\t\\tname = ofType && elem.nodeName.toLowerCase(),\\n\\t\\t\\t\\t\\t\\tuseCache = !xml && !ofType,\\n\\t\\t\\t\\t\\t\\tdiff = false;\\n\\n\\t\\t\\t\\t\\tif ( parent ) {\\n\\n\\t\\t\\t\\t\\t\\t// :(first|last|only)-(child|of-type)\\n\\t\\t\\t\\t\\t\\tif ( simple ) {\\n\\t\\t\\t\\t\\t\\t\\twhile ( dir ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tnode = elem;\\n\\t\\t\\t\\t\\t\\t\\t\\twhile ( (node = node[ dir ]) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( ofType ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeName.toLowerCase() === name :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t// Reverse direction for :only-* (if we haven\\'t yet done so)\\n\\t\\t\\t\\t\\t\\t\\t\\tstart = dir = type === \"only\" && !start && \"nextSibling\";\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tstart = [ forward ? parent.firstChild : parent.lastChild ];\\n\\n\\t\\t\\t\\t\\t\\t// non-xml :nth-child(...) stores cache data on `parent`\\n\\t\\t\\t\\t\\t\\tif ( forward && useCache ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Seek `elem` from a previously-cached index\\n\\n\\t\\t\\t\\t\\t\\t\\t// ...in a gzip-friendly way\\n\\t\\t\\t\\t\\t\\t\\tnode = parent;\\n\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\tcache = uniqueCache[ type ] || [];\\n\\t\\t\\t\\t\\t\\t\\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\tdiff = nodeIndex && cache[ 2 ];\\n\\t\\t\\t\\t\\t\\t\\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Fallback to seeking `elem` from the start\\n\\t\\t\\t\\t\\t\\t\\t\\t(diff = nodeIndex = 0) || start.pop()) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// When found, cache indexes on `parent` and break\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( node.nodeType === 1 && ++diff && node === elem ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t// Use previously-cached element index if available\\n\\t\\t\\t\\t\\t\\t\\tif ( useCache ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// ...in a gzip-friendly way\\n\\t\\t\\t\\t\\t\\t\\t\\tnode = elem;\\n\\t\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcache = uniqueCache[ type ] || [];\\n\\t\\t\\t\\t\\t\\t\\t\\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\\n\\t\\t\\t\\t\\t\\t\\t\\tdiff = nodeIndex;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// xml :nth-child(...)\\n\\t\\t\\t\\t\\t\\t\\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\\n\\t\\t\\t\\t\\t\\t\\tif ( diff === false ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t// Use the same loop as above to seek `elem` from the start\\n\\t\\t\\t\\t\\t\\t\\t\\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(diff = nodeIndex = 0) || start.pop()) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( ( ofType ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeName.toLowerCase() === name :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tnode.nodeType === 1 ) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t++diff ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Cache the index of each encountered element\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( useCache ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\touterCache = node[ expando ] || (node[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ node.uniqueID ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(outerCache[ node.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tuniqueCache[ type ] = [ dirruns, diff ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( node === elem ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Incorporate the offset, then check against cycle size\\n\\t\\t\\t\\t\\t\\tdiff -= last;\\n\\t\\t\\t\\t\\t\\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\t\"PSEUDO\": function( pseudo, argument ) {\\n\\t\\t\\t// pseudo-class names are case-insensitive\\n\\t\\t\\t// http://www.w3.org/TR/selectors/#pseudo-classes\\n\\t\\t\\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\\n\\t\\t\\t// Remember that setFilters inherits from pseudos\\n\\t\\t\\tvar args,\\n\\t\\t\\t\\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\\n\\t\\t\\t\\t\\tSizzle.error( \"unsupported pseudo: \" + pseudo );\\n\\n\\t\\t\\t// The user may use createPseudo to indicate that\\n\\t\\t\\t// arguments are needed to create the filter function\\n\\t\\t\\t// just as Sizzle does\\n\\t\\t\\tif ( fn[ expando ] ) {\\n\\t\\t\\t\\treturn fn( argument );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// But maintain support for old signatures\\n\\t\\t\\tif ( fn.length > 1 ) {\\n\\t\\t\\t\\targs = [ pseudo, pseudo, \"\", argument ];\\n\\t\\t\\t\\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\\n\\t\\t\\t\\t\\tmarkFunction(function( seed, matches ) {\\n\\t\\t\\t\\t\\t\\tvar idx,\\n\\t\\t\\t\\t\\t\\t\\tmatched = fn( seed, argument ),\\n\\t\\t\\t\\t\\t\\t\\ti = matched.length;\\n\\t\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\t\\tidx = indexOf( seed, matched[i] );\\n\\t\\t\\t\\t\\t\\t\\tseed[ idx ] = !( matches[ idx ] = matched[i] );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}) :\\n\\t\\t\\t\\t\\tfunction( elem ) {\\n\\t\\t\\t\\t\\t\\treturn fn( elem, 0, args );\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn fn;\\n\\t\\t}\\n\\t},\\n\\n\\tpseudos: {\\n\\t\\t// Potentially complex pseudos\\n\\t\\t\"not\": markFunction(function( selector ) {\\n\\t\\t\\t// Trim the selector passed to compile\\n\\t\\t\\t// to avoid treating leading and trailing\\n\\t\\t\\t// spaces as combinators\\n\\t\\t\\tvar input = [],\\n\\t\\t\\t\\tresults = [],\\n\\t\\t\\t\\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\\n\\n\\t\\t\\treturn matcher[ expando ] ?\\n\\t\\t\\t\\tmarkFunction(function( seed, matches, context, xml ) {\\n\\t\\t\\t\\t\\tvar elem,\\n\\t\\t\\t\\t\\t\\tunmatched = matcher( seed, null, xml, [] ),\\n\\t\\t\\t\\t\\t\\ti = seed.length;\\n\\n\\t\\t\\t\\t\\t// Match elements unmatched by `matcher`\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = unmatched[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\tseed[i] = !(matches[i] = elem);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}) :\\n\\t\\t\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\t\\t\\tinput[0] = elem;\\n\\t\\t\\t\\t\\tmatcher( input, null, xml, results );\\n\\t\\t\\t\\t\\t// Don\\'t keep the element (issue #299)\\n\\t\\t\\t\\t\\tinput[0] = null;\\n\\t\\t\\t\\t\\treturn !results.pop();\\n\\t\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t\"has\": markFunction(function( selector ) {\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn Sizzle( selector, elem ).length > 0;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t\"contains\": markFunction(function( text ) {\\n\\t\\t\\ttext = text.replace( runescape, funescape );\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t// \"Whether an element is represented by a :lang() selector\\n\\t\\t// is based solely on the element\\'s language value\\n\\t\\t// being equal to the identifier C,\\n\\t\\t// or beginning with the identifier C immediately followed by \"-\".\\n\\t\\t// The matching of C against the element\\'s language value is performed case-insensitively.\\n\\t\\t// The identifier C does not have to be a valid language name.\"\\n\\t\\t// http://www.w3.org/TR/selectors/#lang-pseudo\\n\\t\\t\"lang\": markFunction( function( lang ) {\\n\\t\\t\\t// lang value must be a valid identifier\\n\\t\\t\\tif ( !ridentifier.test(lang || \"\") ) {\\n\\t\\t\\t\\tSizzle.error( \"unsupported lang: \" + lang );\\n\\t\\t\\t}\\n\\t\\t\\tlang = lang.replace( runescape, funescape ).toLowerCase();\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\tvar elemLang;\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\tif ( (elemLang = documentIsHTML ?\\n\\t\\t\\t\\t\\t\\telem.lang :\\n\\t\\t\\t\\t\\t\\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\\n\\n\\t\\t\\t\\t\\t\\telemLang = elemLang.toLowerCase();\\n\\t\\t\\t\\t\\t\\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t};\\n\\t\\t}),\\n\\n\\t\\t// Miscellaneous\\n\\t\\t\"target\": function( elem ) {\\n\\t\\t\\tvar hash = window.location && window.location.hash;\\n\\t\\t\\treturn hash && hash.slice( 1 ) === elem.id;\\n\\t\\t},\\n\\n\\t\\t\"root\": function( elem ) {\\n\\t\\t\\treturn elem === docElem;\\n\\t\\t},\\n\\n\\t\\t\"focus\": function( elem ) {\\n\\t\\t\\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\\n\\t\\t},\\n\\n\\t\\t// Boolean properties\\n\\t\\t\"enabled\": createDisabledPseudo( false ),\\n\\t\\t\"disabled\": createDisabledPseudo( true ),\\n\\n\\t\\t\"checked\": function( elem ) {\\n\\t\\t\\t// In CSS3, :checked should return both checked and selected elements\\n\\t\\t\\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\\n\\t\\t\\tvar nodeName = elem.nodeName.toLowerCase();\\n\\t\\t\\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\\n\\t\\t},\\n\\n\\t\\t\"selected\": function( elem ) {\\n\\t\\t\\t// Accessing this property makes selected-by-default\\n\\t\\t\\t// options in Safari work properly\\n\\t\\t\\tif ( elem.parentNode ) {\\n\\t\\t\\t\\telem.parentNode.selectedIndex;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn elem.selected === true;\\n\\t\\t},\\n\\n\\t\\t// Contents\\n\\t\\t\"empty\": function( elem ) {\\n\\t\\t\\t// http://www.w3.org/TR/selectors/#empty-pseudo\\n\\t\\t\\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\\n\\t\\t\\t//   but not by others (comment: 8; processing instruction: 7; etc.)\\n\\t\\t\\t// nodeType < 6 works because attributes (2) do not appear as children\\n\\t\\t\\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\\n\\t\\t\\t\\tif ( elem.nodeType < 6 ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t},\\n\\n\\t\\t\"parent\": function( elem ) {\\n\\t\\t\\treturn !Expr.pseudos[\"empty\"]( elem );\\n\\t\\t},\\n\\n\\t\\t// Element/input types\\n\\t\\t\"header\": function( elem ) {\\n\\t\\t\\treturn rheader.test( elem.nodeName );\\n\\t\\t},\\n\\n\\t\\t\"input\": function( elem ) {\\n\\t\\t\\treturn rinputs.test( elem.nodeName );\\n\\t\\t},\\n\\n\\t\\t\"button\": function( elem ) {\\n\\t\\t\\tvar name = elem.nodeName.toLowerCase();\\n\\t\\t\\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\\n\\t\\t},\\n\\n\\t\\t\"text\": function( elem ) {\\n\\t\\t\\tvar attr;\\n\\t\\t\\treturn elem.nodeName.toLowerCase() === \"input\" &&\\n\\t\\t\\t\\telem.type === \"text\" &&\\n\\n\\t\\t\\t\\t// Support: IE<8\\n\\t\\t\\t\\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\\n\\t\\t\\t\\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\\n\\t\\t},\\n\\n\\t\\t// Position-in-collection\\n\\t\\t\"first\": createPositionalPseudo(function() {\\n\\t\\t\\treturn [ 0 ];\\n\\t\\t}),\\n\\n\\t\\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\treturn [ length - 1 ];\\n\\t\\t}),\\n\\n\\t\\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\treturn [ argument < 0 ? argument + length : argument ];\\n\\t\\t}),\\n\\n\\t\\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\tvar i = 0;\\n\\t\\t\\tfor ( ; i < length; i += 2 ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\\n\\t\\t\\tvar i = 1;\\n\\t\\t\\tfor ( ; i < length; i += 2 ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\tvar i = argument < 0 ? argument + length : argument;\\n\\t\\t\\tfor ( ; --i >= 0; ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t}),\\n\\n\\t\\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\\n\\t\\t\\tvar i = argument < 0 ? argument + length : argument;\\n\\t\\t\\tfor ( ; ++i < length; ) {\\n\\t\\t\\t\\tmatchIndexes.push( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn matchIndexes;\\n\\t\\t})\\n\\t}\\n};\\n\\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\\n\\n// Add button/input type pseudos\\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\\n\\tExpr.pseudos[ i ] = createInputPseudo( i );\\n}\\nfor ( i in { submit: true, reset: true } ) {\\n\\tExpr.pseudos[ i ] = createButtonPseudo( i );\\n}\\n\\n// Easy API for creating new setFilters\\nfunction setFilters() {}\\nsetFilters.prototype = Expr.filters = Expr.pseudos;\\nExpr.setFilters = new setFilters();\\n\\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\\n\\tvar matched, match, tokens, type,\\n\\t\\tsoFar, groups, preFilters,\\n\\t\\tcached = tokenCache[ selector + \" \" ];\\n\\n\\tif ( cached ) {\\n\\t\\treturn parseOnly ? 0 : cached.slice( 0 );\\n\\t}\\n\\n\\tsoFar = selector;\\n\\tgroups = [];\\n\\tpreFilters = Expr.preFilter;\\n\\n\\twhile ( soFar ) {\\n\\n\\t\\t// Comma and first run\\n\\t\\tif ( !matched || (match = rcomma.exec( soFar )) ) {\\n\\t\\t\\tif ( match ) {\\n\\t\\t\\t\\t// Don\\'t consume trailing commas as valid\\n\\t\\t\\t\\tsoFar = soFar.slice( match[0].length ) || soFar;\\n\\t\\t\\t}\\n\\t\\t\\tgroups.push( (tokens = []) );\\n\\t\\t}\\n\\n\\t\\tmatched = false;\\n\\n\\t\\t// Combinators\\n\\t\\tif ( (match = rcombinators.exec( soFar )) ) {\\n\\t\\t\\tmatched = match.shift();\\n\\t\\t\\ttokens.push({\\n\\t\\t\\t\\tvalue: matched,\\n\\t\\t\\t\\t// Cast descendant combinators to space\\n\\t\\t\\t\\ttype: match[0].replace( rtrim, \" \" )\\n\\t\\t\\t});\\n\\t\\t\\tsoFar = soFar.slice( matched.length );\\n\\t\\t}\\n\\n\\t\\t// Filters\\n\\t\\tfor ( type in Expr.filter ) {\\n\\t\\t\\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\\n\\t\\t\\t\\t(match = preFilters[ type ]( match ))) ) {\\n\\t\\t\\t\\tmatched = match.shift();\\n\\t\\t\\t\\ttokens.push({\\n\\t\\t\\t\\t\\tvalue: matched,\\n\\t\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\t\\tmatches: match\\n\\t\\t\\t\\t});\\n\\t\\t\\t\\tsoFar = soFar.slice( matched.length );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( !matched ) {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the length of the invalid excess\\n\\t// if we\\'re just parsing\\n\\t// Otherwise, throw an error or return tokens\\n\\treturn parseOnly ?\\n\\t\\tsoFar.length :\\n\\t\\tsoFar ?\\n\\t\\t\\tSizzle.error( selector ) :\\n\\t\\t\\t// Cache the tokens\\n\\t\\t\\ttokenCache( selector, groups ).slice( 0 );\\n};\\n\\nfunction toSelector( tokens ) {\\n\\tvar i = 0,\\n\\t\\tlen = tokens.length,\\n\\t\\tselector = \"\";\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tselector += tokens[i].value;\\n\\t}\\n\\treturn selector;\\n}\\n\\nfunction addCombinator( matcher, combinator, base ) {\\n\\tvar dir = combinator.dir,\\n\\t\\tskip = combinator.next,\\n\\t\\tkey = skip || dir,\\n\\t\\tcheckNonElements = base && key === \"parentNode\",\\n\\t\\tdoneName = done++;\\n\\n\\treturn combinator.first ?\\n\\t\\t// Check against closest ancestor/preceding element\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\treturn matcher( elem, context, xml );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t} :\\n\\n\\t\\t// Check against all ancestor/preceding elements\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\tvar oldCache, uniqueCache, outerCache,\\n\\t\\t\\t\\tnewCache = [ dirruns, doneName ];\\n\\n\\t\\t\\t// We can\\'t set arbitrary data on XML nodes, so they don\\'t benefit from combinator caching\\n\\t\\t\\tif ( xml ) {\\n\\t\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\t\\tif ( matcher( elem, context, xml ) ) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twhile ( (elem = elem[ dir ]) ) {\\n\\t\\t\\t\\t\\tif ( elem.nodeType === 1 || checkNonElements ) {\\n\\t\\t\\t\\t\\t\\touterCache = elem[ expando ] || (elem[ expando ] = {});\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE <9 only\\n\\t\\t\\t\\t\\t\\t// Defend against cloned attroperties (jQuery gh-1709)\\n\\t\\t\\t\\t\\t\\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\\n\\n\\t\\t\\t\\t\\t\\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\\n\\t\\t\\t\\t\\t\\t\\telem = elem[ dir ] || elem;\\n\\t\\t\\t\\t\\t\\t} else if ( (oldCache = uniqueCache[ key ]) &&\\n\\t\\t\\t\\t\\t\\t\\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Assign to newCache so results back-propagate to previous elements\\n\\t\\t\\t\\t\\t\\t\\treturn (newCache[ 2 ] = oldCache[ 2 ]);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t// Reuse newcache so results back-propagate to previous elements\\n\\t\\t\\t\\t\\t\\t\\tuniqueCache[ key ] = newCache;\\n\\n\\t\\t\\t\\t\\t\\t\\t// A match means we\\'re done; a fail means we have to keep checking\\n\\t\\t\\t\\t\\t\\t\\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t};\\n}\\n\\nfunction elementMatcher( matchers ) {\\n\\treturn matchers.length > 1 ?\\n\\t\\tfunction( elem, context, xml ) {\\n\\t\\t\\tvar i = matchers.length;\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( !matchers[i]( elem, context, xml ) ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t} :\\n\\t\\tmatchers[0];\\n}\\n\\nfunction multipleContexts( selector, contexts, results ) {\\n\\tvar i = 0,\\n\\t\\tlen = contexts.length;\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tSizzle( selector, contexts[i], results );\\n\\t}\\n\\treturn results;\\n}\\n\\nfunction condense( unmatched, map, filter, context, xml ) {\\n\\tvar elem,\\n\\t\\tnewUnmatched = [],\\n\\t\\ti = 0,\\n\\t\\tlen = unmatched.length,\\n\\t\\tmapped = map != null;\\n\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tif ( (elem = unmatched[i]) ) {\\n\\t\\t\\tif ( !filter || filter( elem, context, xml ) ) {\\n\\t\\t\\t\\tnewUnmatched.push( elem );\\n\\t\\t\\t\\tif ( mapped ) {\\n\\t\\t\\t\\t\\tmap.push( i );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn newUnmatched;\\n}\\n\\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\\n\\tif ( postFilter && !postFilter[ expando ] ) {\\n\\t\\tpostFilter = setMatcher( postFilter );\\n\\t}\\n\\tif ( postFinder && !postFinder[ expando ] ) {\\n\\t\\tpostFinder = setMatcher( postFinder, postSelector );\\n\\t}\\n\\treturn markFunction(function( seed, results, context, xml ) {\\n\\t\\tvar temp, i, elem,\\n\\t\\t\\tpreMap = [],\\n\\t\\t\\tpostMap = [],\\n\\t\\t\\tpreexisting = results.length,\\n\\n\\t\\t\\t// Get initial elements from seed or context\\n\\t\\t\\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\\n\\n\\t\\t\\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\\n\\t\\t\\tmatcherIn = preFilter && ( seed || !selector ) ?\\n\\t\\t\\t\\tcondense( elems, preMap, preFilter, context, xml ) :\\n\\t\\t\\t\\telems,\\n\\n\\t\\t\\tmatcherOut = matcher ?\\n\\t\\t\\t\\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\\n\\t\\t\\t\\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\\n\\n\\t\\t\\t\\t\\t// ...intermediate processing is necessary\\n\\t\\t\\t\\t\\t[] :\\n\\n\\t\\t\\t\\t\\t// ...otherwise use results directly\\n\\t\\t\\t\\t\\tresults :\\n\\t\\t\\t\\tmatcherIn;\\n\\n\\t\\t// Find primary matches\\n\\t\\tif ( matcher ) {\\n\\t\\t\\tmatcher( matcherIn, matcherOut, context, xml );\\n\\t\\t}\\n\\n\\t\\t// Apply postFilter\\n\\t\\tif ( postFilter ) {\\n\\t\\t\\ttemp = condense( matcherOut, postMap );\\n\\t\\t\\tpostFilter( temp, [], context, xml );\\n\\n\\t\\t\\t// Un-match failing elements by moving them back to matcherIn\\n\\t\\t\\ti = temp.length;\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tif ( (elem = temp[i]) ) {\\n\\t\\t\\t\\t\\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( seed ) {\\n\\t\\t\\tif ( postFinder || preFilter ) {\\n\\t\\t\\t\\tif ( postFinder ) {\\n\\t\\t\\t\\t\\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\\n\\t\\t\\t\\t\\ttemp = [];\\n\\t\\t\\t\\t\\ti = matcherOut.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\tif ( (elem = matcherOut[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\t// Restore matcherIn since elem is not yet a final match\\n\\t\\t\\t\\t\\t\\t\\ttemp.push( (matcherIn[i] = elem) );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tpostFinder( null, (matcherOut = []), temp, xml );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Move matched elements from seed to results to keep them synchronized\\n\\t\\t\\t\\ti = matcherOut.length;\\n\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\tif ( (elem = matcherOut[i]) &&\\n\\t\\t\\t\\t\\t\\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\\n\\n\\t\\t\\t\\t\\t\\tseed[temp] = !(results[temp] = elem);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Add elements to results, through postFinder if defined\\n\\t\\t} else {\\n\\t\\t\\tmatcherOut = condense(\\n\\t\\t\\t\\tmatcherOut === results ?\\n\\t\\t\\t\\t\\tmatcherOut.splice( preexisting, matcherOut.length ) :\\n\\t\\t\\t\\t\\tmatcherOut\\n\\t\\t\\t);\\n\\t\\t\\tif ( postFinder ) {\\n\\t\\t\\t\\tpostFinder( null, results, matcherOut, xml );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpush.apply( results, matcherOut );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n}\\n\\nfunction matcherFromTokens( tokens ) {\\n\\tvar checkContext, matcher, j,\\n\\t\\tlen = tokens.length,\\n\\t\\tleadingRelative = Expr.relative[ tokens[0].type ],\\n\\t\\timplicitRelative = leadingRelative || Expr.relative[\" \"],\\n\\t\\ti = leadingRelative ? 1 : 0,\\n\\n\\t\\t// The foundational matcher ensures that elements are reachable from top-level context(s)\\n\\t\\tmatchContext = addCombinator( function( elem ) {\\n\\t\\t\\treturn elem === checkContext;\\n\\t\\t}, implicitRelative, true ),\\n\\t\\tmatchAnyContext = addCombinator( function( elem ) {\\n\\t\\t\\treturn indexOf( checkContext, elem ) > -1;\\n\\t\\t}, implicitRelative, true ),\\n\\t\\tmatchers = [ function( elem, context, xml ) {\\n\\t\\t\\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\\n\\t\\t\\t\\t(checkContext = context).nodeType ?\\n\\t\\t\\t\\t\\tmatchContext( elem, context, xml ) :\\n\\t\\t\\t\\t\\tmatchAnyContext( elem, context, xml ) );\\n\\t\\t\\t// Avoid hanging onto element (issue #299)\\n\\t\\t\\tcheckContext = null;\\n\\t\\t\\treturn ret;\\n\\t\\t} ];\\n\\n\\tfor ( ; i < len; i++ ) {\\n\\t\\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\\n\\t\\t\\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\\n\\t\\t} else {\\n\\t\\t\\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\\n\\n\\t\\t\\t// Return special upon seeing a positional matcher\\n\\t\\t\\tif ( matcher[ expando ] ) {\\n\\t\\t\\t\\t// Find the next relative operator (if any) for proper handling\\n\\t\\t\\t\\tj = ++i;\\n\\t\\t\\t\\tfor ( ; j < len; j++ ) {\\n\\t\\t\\t\\t\\tif ( Expr.relative[ tokens[j].type ] ) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn setMatcher(\\n\\t\\t\\t\\t\\ti > 1 && elementMatcher( matchers ),\\n\\t\\t\\t\\t\\ti > 1 && toSelector(\\n\\t\\t\\t\\t\\t\\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\\n\\t\\t\\t\\t\\t\\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\\n\\t\\t\\t\\t\\t).replace( rtrim, \"$1\" ),\\n\\t\\t\\t\\t\\tmatcher,\\n\\t\\t\\t\\t\\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\\n\\t\\t\\t\\t\\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\\n\\t\\t\\t\\t\\tj < len && toSelector( tokens )\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t\\tmatchers.push( matcher );\\n\\t\\t}\\n\\t}\\n\\n\\treturn elementMatcher( matchers );\\n}\\n\\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\\n\\tvar bySet = setMatchers.length > 0,\\n\\t\\tbyElement = elementMatchers.length > 0,\\n\\t\\tsuperMatcher = function( seed, context, xml, results, outermost ) {\\n\\t\\t\\tvar elem, j, matcher,\\n\\t\\t\\t\\tmatchedCount = 0,\\n\\t\\t\\t\\ti = \"0\",\\n\\t\\t\\t\\tunmatched = seed && [],\\n\\t\\t\\t\\tsetMatched = [],\\n\\t\\t\\t\\tcontextBackup = outermostContext,\\n\\t\\t\\t\\t// We must always have either seed elements or outermost context\\n\\t\\t\\t\\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\\n\\t\\t\\t\\t// Use integer dirruns iff this is the outermost matcher\\n\\t\\t\\t\\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\\n\\t\\t\\t\\tlen = elems.length;\\n\\n\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\toutermostContext = context === document || context || outermost;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add elements passing elementMatchers directly to results\\n\\t\\t\\t// Support: IE<9, Safari\\n\\t\\t\\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\\n\\t\\t\\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\\n\\t\\t\\t\\tif ( byElement && elem ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\tif ( !context && elem.ownerDocument !== document ) {\\n\\t\\t\\t\\t\\t\\tsetDocument( elem );\\n\\t\\t\\t\\t\\t\\txml = !documentIsHTML;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\twhile ( (matcher = elementMatchers[j++]) ) {\\n\\t\\t\\t\\t\\t\\tif ( matcher( elem, context || document, xml) ) {\\n\\t\\t\\t\\t\\t\\t\\tresults.push( elem );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\t\\t\\tdirruns = dirrunsUnique;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Track unmatched elements for set filters\\n\\t\\t\\t\\tif ( bySet ) {\\n\\t\\t\\t\\t\\t// They will have gone through all possible matchers\\n\\t\\t\\t\\t\\tif ( (elem = !matcher && elem) ) {\\n\\t\\t\\t\\t\\t\\tmatchedCount--;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Lengthen the array for every element, matched or not\\n\\t\\t\\t\\t\\tif ( seed ) {\\n\\t\\t\\t\\t\\t\\tunmatched.push( elem );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\\n\\t\\t\\t// makes the latter nonnegative.\\n\\t\\t\\tmatchedCount += i;\\n\\n\\t\\t\\t// Apply set filters to unmatched elements\\n\\t\\t\\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\\n\\t\\t\\t// equals `i`), unless we didn\\'t visit _any_ elements in the above loop because we have\\n\\t\\t\\t// no element matchers and no seed.\\n\\t\\t\\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\\n\\t\\t\\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\\n\\t\\t\\t// numerically zero.\\n\\t\\t\\tif ( bySet && i !== matchedCount ) {\\n\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\twhile ( (matcher = setMatchers[j++]) ) {\\n\\t\\t\\t\\t\\tmatcher( unmatched, setMatched, context, xml );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( seed ) {\\n\\t\\t\\t\\t\\t// Reintegrate element matches to eliminate the need for sorting\\n\\t\\t\\t\\t\\tif ( matchedCount > 0 ) {\\n\\t\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( !(unmatched[i] || setMatched[i]) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tsetMatched[i] = pop.call( results );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Discard index placeholder values to get only actual matches\\n\\t\\t\\t\\t\\tsetMatched = condense( setMatched );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Add matches to results\\n\\t\\t\\t\\tpush.apply( results, setMatched );\\n\\n\\t\\t\\t\\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\\n\\t\\t\\t\\tif ( outermost && !seed && setMatched.length > 0 &&\\n\\t\\t\\t\\t\\t( matchedCount + setMatchers.length ) > 1 ) {\\n\\n\\t\\t\\t\\t\\tSizzle.uniqueSort( results );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Override manipulation of globals by nested matchers\\n\\t\\t\\tif ( outermost ) {\\n\\t\\t\\t\\tdirruns = dirrunsUnique;\\n\\t\\t\\t\\toutermostContext = contextBackup;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn unmatched;\\n\\t\\t};\\n\\n\\treturn bySet ?\\n\\t\\tmarkFunction( superMatcher ) :\\n\\t\\tsuperMatcher;\\n}\\n\\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\\n\\tvar i,\\n\\t\\tsetMatchers = [],\\n\\t\\telementMatchers = [],\\n\\t\\tcached = compilerCache[ selector + \" \" ];\\n\\n\\tif ( !cached ) {\\n\\t\\t// Generate a function of recursive functions that can be used to check each element\\n\\t\\tif ( !match ) {\\n\\t\\t\\tmatch = tokenize( selector );\\n\\t\\t}\\n\\t\\ti = match.length;\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tcached = matcherFromTokens( match[i] );\\n\\t\\t\\tif ( cached[ expando ] ) {\\n\\t\\t\\t\\tsetMatchers.push( cached );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\telementMatchers.push( cached );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Cache the compiled function\\n\\t\\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\\n\\n\\t\\t// Save selector and tokenization\\n\\t\\tcached.selector = selector;\\n\\t}\\n\\treturn cached;\\n};\\n\\n/**\\n * A low-level selection function that works with Sizzle\\'s compiled\\n *  selector functions\\n * @param {String|Function} selector A selector or a pre-compiled\\n *  selector function built with Sizzle.compile\\n * @param {Element} context\\n * @param {Array} [results]\\n * @param {Array} [seed] A set of elements to match against\\n */\\nselect = Sizzle.select = function( selector, context, results, seed ) {\\n\\tvar i, tokens, token, type, find,\\n\\t\\tcompiled = typeof selector === \"function\" && selector,\\n\\t\\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\\n\\n\\tresults = results || [];\\n\\n\\t// Try to minimize operations if there is only one selector in the list and no seed\\n\\t// (the latter of which guarantees us context)\\n\\tif ( match.length === 1 ) {\\n\\n\\t\\t// Reduce context if the leading compound selector is an ID\\n\\t\\ttokens = match[0] = match[0].slice( 0 );\\n\\t\\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\\n\\t\\t\\t\\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\\n\\n\\t\\t\\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\\n\\t\\t\\tif ( !context ) {\\n\\t\\t\\t\\treturn results;\\n\\n\\t\\t\\t// Precompiled matchers will still verify ancestry, so step up a level\\n\\t\\t\\t} else if ( compiled ) {\\n\\t\\t\\t\\tcontext = context.parentNode;\\n\\t\\t\\t}\\n\\n\\t\\t\\tselector = selector.slice( tokens.shift().value.length );\\n\\t\\t}\\n\\n\\t\\t// Fetch a seed set for right-to-left matching\\n\\t\\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\ttoken = tokens[i];\\n\\n\\t\\t\\t// Abort if we hit a combinator\\n\\t\\t\\tif ( Expr.relative[ (type = token.type) ] ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif ( (find = Expr.find[ type ]) ) {\\n\\t\\t\\t\\t// Search, expanding context for leading sibling combinators\\n\\t\\t\\t\\tif ( (seed = find(\\n\\t\\t\\t\\t\\ttoken.matches[0].replace( runescape, funescape ),\\n\\t\\t\\t\\t\\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\\n\\t\\t\\t\\t)) ) {\\n\\n\\t\\t\\t\\t\\t// If seed is empty or no tokens remain, we can return early\\n\\t\\t\\t\\t\\ttokens.splice( i, 1 );\\n\\t\\t\\t\\t\\tselector = seed.length && toSelector( tokens );\\n\\t\\t\\t\\t\\tif ( !selector ) {\\n\\t\\t\\t\\t\\t\\tpush.apply( results, seed );\\n\\t\\t\\t\\t\\t\\treturn results;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Compile and execute a filtering function if one is not provided\\n\\t// Provide `match` to avoid retokenization if we modified the selector above\\n\\t( compiled || compile( selector, match ) )(\\n\\t\\tseed,\\n\\t\\tcontext,\\n\\t\\t!documentIsHTML,\\n\\t\\tresults,\\n\\t\\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\\n\\t);\\n\\treturn results;\\n};\\n\\n// One-time assignments\\n\\n// Sort stability\\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\\n\\n// Support: Chrome 14-35+\\n// Always assume duplicates if they aren\\'t passed to the comparison function\\nsupport.detectDuplicates = !!hasDuplicate;\\n\\n// Initialize against the default document\\nsetDocument();\\n\\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\\n// Detached nodes confoundingly follow *each other*\\nsupport.sortDetached = assert(function( el ) {\\n\\t// Should return 1, but returns 4 (following)\\n\\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\\n});\\n\\n// Support: IE<8\\n// Prevent attribute/property \"interpolation\"\\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\\nif ( !assert(function( el ) {\\n\\tel.innerHTML = \"<a href=\\'#\\'></a>\";\\n\\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\\n}) ) {\\n\\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\\n\\t\\tif ( !isXML ) {\\n\\t\\t\\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\\n\\t\\t}\\n\\t});\\n}\\n\\n// Support: IE<9\\n// Use defaultValue in place of getAttribute(\"value\")\\nif ( !support.attributes || !assert(function( el ) {\\n\\tel.innerHTML = \"<input/>\";\\n\\tel.firstChild.setAttribute( \"value\", \"\" );\\n\\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\\n}) ) {\\n\\taddHandle( \"value\", function( elem, name, isXML ) {\\n\\t\\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\\n\\t\\t\\treturn elem.defaultValue;\\n\\t\\t}\\n\\t});\\n}\\n\\n// Support: IE<9\\n// Use getAttributeNode to fetch booleans when getAttribute lies\\nif ( !assert(function( el ) {\\n\\treturn el.getAttribute(\"disabled\") == null;\\n}) ) {\\n\\taddHandle( booleans, function( elem, name, isXML ) {\\n\\t\\tvar val;\\n\\t\\tif ( !isXML ) {\\n\\t\\t\\treturn elem[ name ] === true ? name.toLowerCase() :\\n\\t\\t\\t\\t\\t(val = elem.getAttributeNode( name )) && val.specified ?\\n\\t\\t\\t\\t\\tval.value :\\n\\t\\t\\t\\tnull;\\n\\t\\t}\\n\\t});\\n}\\n\\nreturn Sizzle;\\n\\n})( window );\\n\\n\\n\\njQuery.find = Sizzle;\\njQuery.expr = Sizzle.selectors;\\n\\n// Deprecated\\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\\njQuery.text = Sizzle.getText;\\njQuery.isXMLDoc = Sizzle.isXML;\\njQuery.contains = Sizzle.contains;\\njQuery.escapeSelector = Sizzle.escape;\\n\\n\\n\\n\\nvar dir = function( elem, dir, until ) {\\n\\tvar matched = [],\\n\\t\\ttruncate = until !== undefined;\\n\\n\\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\\n\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\tif ( truncate && jQuery( elem ).is( until ) ) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tmatched.push( elem );\\n\\t\\t}\\n\\t}\\n\\treturn matched;\\n};\\n\\n\\nvar siblings = function( n, elem ) {\\n\\tvar matched = [];\\n\\n\\tfor ( ; n; n = n.nextSibling ) {\\n\\t\\tif ( n.nodeType === 1 && n !== elem ) {\\n\\t\\t\\tmatched.push( n );\\n\\t\\t}\\n\\t}\\n\\n\\treturn matched;\\n};\\n\\n\\nvar rneedsContext = jQuery.expr.match.needsContext;\\n\\n\\n\\nfunction nodeName( elem, name ) {\\n\\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\\n\\n};\\nvar rsingleTag = ( /^<([a-z][^\\\\/\\\\0>:\\\\x20\\\\t\\\\r\\\\n\\\\f]*)[\\\\x20\\\\t\\\\r\\\\n\\\\f]*\\\\/?>(?:<\\\\/\\\\1>|)$/i );\\n\\n\\n\\n// Implement the identical functionality for filter and not\\nfunction winnow( elements, qualifier, not ) {\\n\\tif ( isFunction( qualifier ) ) {\\n\\t\\treturn jQuery.grep( elements, function( elem, i ) {\\n\\t\\t\\treturn !!qualifier.call( elem, i, elem ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Single element\\n\\tif ( qualifier.nodeType ) {\\n\\t\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\t\\treturn ( elem === qualifier ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Arraylike of elements (jQuery, arguments, Array)\\n\\tif ( typeof qualifier !== \"string\" ) {\\n\\t\\treturn jQuery.grep( elements, function( elem ) {\\n\\t\\t\\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\\n\\t\\t} );\\n\\t}\\n\\n\\t// Filtered directly for both simple and complex selectors\\n\\treturn jQuery.filter( qualifier, elements, not );\\n}\\n\\njQuery.filter = function( expr, elems, not ) {\\n\\tvar elem = elems[ 0 ];\\n\\n\\tif ( not ) {\\n\\t\\texpr = \":not(\" + expr + \")\";\\n\\t}\\n\\n\\tif ( elems.length === 1 && elem.nodeType === 1 ) {\\n\\t\\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\\n\\t}\\n\\n\\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\\n\\t\\treturn elem.nodeType === 1;\\n\\t} ) );\\n};\\n\\njQuery.fn.extend( {\\n\\tfind: function( selector ) {\\n\\t\\tvar i, ret,\\n\\t\\t\\tlen = this.length,\\n\\t\\t\\tself = this;\\n\\n\\t\\tif ( typeof selector !== \"string\" ) {\\n\\t\\t\\treturn this.pushStack( jQuery( selector ).filter( function() {\\n\\t\\t\\t\\tfor ( i = 0; i < len; i++ ) {\\n\\t\\t\\t\\t\\tif ( jQuery.contains( self[ i ], this ) ) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} ) );\\n\\t\\t}\\n\\n\\t\\tret = this.pushStack( [] );\\n\\n\\t\\tfor ( i = 0; i < len; i++ ) {\\n\\t\\t\\tjQuery.find( selector, self[ i ], ret );\\n\\t\\t}\\n\\n\\t\\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\\n\\t},\\n\\tfilter: function( selector ) {\\n\\t\\treturn this.pushStack( winnow( this, selector || [], false ) );\\n\\t},\\n\\tnot: function( selector ) {\\n\\t\\treturn this.pushStack( winnow( this, selector || [], true ) );\\n\\t},\\n\\tis: function( selector ) {\\n\\t\\treturn !!winnow(\\n\\t\\t\\tthis,\\n\\n\\t\\t\\t// If this is a positional/relative selector, check membership in the returned set\\n\\t\\t\\t// so $(\"p:first\").is(\"p:last\") won\\'t return true for a doc with two \"p\".\\n\\t\\t\\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\\n\\t\\t\\t\\tjQuery( selector ) :\\n\\t\\t\\t\\tselector || [],\\n\\t\\t\\tfalse\\n\\t\\t).length;\\n\\t}\\n} );\\n\\n\\n// Initialize a jQuery object\\n\\n\\n// A central reference to the root jQuery(document)\\nvar rootjQuery,\\n\\n\\t// A simple way to check for HTML strings\\n\\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\\n\\t// Strict HTML recognition (#11290: must start with <)\\n\\t// Shortcut simple #id case for speed\\n\\trquickExpr = /^(?:\\\\s*(<[\\\\w\\\\W]+>)[^>]*|#([\\\\w-]+))$/,\\n\\n\\tinit = jQuery.fn.init = function( selector, context, root ) {\\n\\t\\tvar match, elem;\\n\\n\\t\\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\\n\\t\\tif ( !selector ) {\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\t// Method init() accepts an alternate rootjQuery\\n\\t\\t// so migrate can support jQuery.sub (gh-2101)\\n\\t\\troot = root || rootjQuery;\\n\\n\\t\\t// Handle HTML strings\\n\\t\\tif ( typeof selector === \"string\" ) {\\n\\t\\t\\tif ( selector[ 0 ] === \"<\" &&\\n\\t\\t\\t\\tselector[ selector.length - 1 ] === \">\" &&\\n\\t\\t\\t\\tselector.length >= 3 ) {\\n\\n\\t\\t\\t\\t// Assume that strings that start and end with <> are HTML and skip the regex check\\n\\t\\t\\t\\tmatch = [ null, selector, null ];\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmatch = rquickExpr.exec( selector );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Match html or make sure no context is specified for #id\\n\\t\\t\\tif ( match && ( match[ 1 ] || !context ) ) {\\n\\n\\t\\t\\t\\t// HANDLE: $(html) -> $(array)\\n\\t\\t\\t\\tif ( match[ 1 ] ) {\\n\\t\\t\\t\\t\\tcontext = context instanceof jQuery ? context[ 0 ] : context;\\n\\n\\t\\t\\t\\t\\t// Option to run scripts is true for back-compat\\n\\t\\t\\t\\t\\t// Intentionally let the error be thrown if parseHTML is not present\\n\\t\\t\\t\\t\\tjQuery.merge( this, jQuery.parseHTML(\\n\\t\\t\\t\\t\\t\\tmatch[ 1 ],\\n\\t\\t\\t\\t\\t\\tcontext && context.nodeType ? context.ownerDocument || context : document,\\n\\t\\t\\t\\t\\t\\ttrue\\n\\t\\t\\t\\t\\t) );\\n\\n\\t\\t\\t\\t\\t// HANDLE: $(html, props)\\n\\t\\t\\t\\t\\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\\n\\t\\t\\t\\t\\t\\tfor ( match in context ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Properties of context are called as methods if possible\\n\\t\\t\\t\\t\\t\\t\\tif ( isFunction( this[ match ] ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis[ match ]( context[ match ] );\\n\\n\\t\\t\\t\\t\\t\\t\\t// ...and otherwise set as attributes\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tthis.attr( match, context[ match ] );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t// HANDLE: $(#id)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\telem = document.getElementById( match[ 2 ] );\\n\\n\\t\\t\\t\\t\\tif ( elem ) {\\n\\n\\t\\t\\t\\t\\t\\t// Inject the element directly into the jQuery object\\n\\t\\t\\t\\t\\t\\tthis[ 0 ] = elem;\\n\\t\\t\\t\\t\\t\\tthis.length = 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t// HANDLE: $(expr, $(...))\\n\\t\\t\\t} else if ( !context || context.jquery ) {\\n\\t\\t\\t\\treturn ( context || root ).find( selector );\\n\\n\\t\\t\\t// HANDLE: $(expr, context)\\n\\t\\t\\t// (which is just equivalent to: $(context).find(expr)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this.constructor( context ).find( selector );\\n\\t\\t\\t}\\n\\n\\t\\t// HANDLE: $(DOMElement)\\n\\t\\t} else if ( selector.nodeType ) {\\n\\t\\t\\tthis[ 0 ] = selector;\\n\\t\\t\\tthis.length = 1;\\n\\t\\t\\treturn this;\\n\\n\\t\\t// HANDLE: $(function)\\n\\t\\t// Shortcut for document ready\\n\\t\\t} else if ( isFunction( selector ) ) {\\n\\t\\t\\treturn root.ready !== undefined ?\\n\\t\\t\\t\\troot.ready( selector ) :\\n\\n\\t\\t\\t\\t// Execute immediately if ready is not present\\n\\t\\t\\t\\tselector( jQuery );\\n\\t\\t}\\n\\n\\t\\treturn jQuery.makeArray( selector, this );\\n\\t};\\n\\n// Give the init function the jQuery prototype for later instantiation\\ninit.prototype = jQuery.fn;\\n\\n// Initialize central reference\\nrootjQuery = jQuery( document );\\n\\n\\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\\n\\n\\t// Methods guaranteed to produce a unique set when starting from a unique set\\n\\tguaranteedUnique = {\\n\\t\\tchildren: true,\\n\\t\\tcontents: true,\\n\\t\\tnext: true,\\n\\t\\tprev: true\\n\\t};\\n\\njQuery.fn.extend( {\\n\\thas: function( target ) {\\n\\t\\tvar targets = jQuery( target, this ),\\n\\t\\t\\tl = targets.length;\\n\\n\\t\\treturn this.filter( function() {\\n\\t\\t\\tvar i = 0;\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tif ( jQuery.contains( this, targets[ i ] ) ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tclosest: function( selectors, context ) {\\n\\t\\tvar cur,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tl = this.length,\\n\\t\\t\\tmatched = [],\\n\\t\\t\\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\\n\\n\\t\\t// Positional selectors never match, since there\\'s no _selection_ context\\n\\t\\tif ( !rneedsContext.test( selectors ) ) {\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\\n\\n\\t\\t\\t\\t\\t// Always skip document fragments\\n\\t\\t\\t\\t\\tif ( cur.nodeType < 11 && ( targets ?\\n\\t\\t\\t\\t\\t\\ttargets.index( cur ) > -1 :\\n\\n\\t\\t\\t\\t\\t\\t// Don\\'t pass non-elements to Sizzle\\n\\t\\t\\t\\t\\t\\tcur.nodeType === 1 &&\\n\\t\\t\\t\\t\\t\\t\\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\tmatched.push( cur );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\\n\\t},\\n\\n\\t// Determine the position of an element within the set\\n\\tindex: function( elem ) {\\n\\n\\t\\t// No argument, return index in parent\\n\\t\\tif ( !elem ) {\\n\\t\\t\\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\\n\\t\\t}\\n\\n\\t\\t// Index in selector\\n\\t\\tif ( typeof elem === \"string\" ) {\\n\\t\\t\\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\\n\\t\\t}\\n\\n\\t\\t// Locate the position of the desired element\\n\\t\\treturn indexOf.call( this,\\n\\n\\t\\t\\t// If it receives a jQuery object, the first element is used\\n\\t\\t\\telem.jquery ? elem[ 0 ] : elem\\n\\t\\t);\\n\\t},\\n\\n\\tadd: function( selector, context ) {\\n\\t\\treturn this.pushStack(\\n\\t\\t\\tjQuery.uniqueSort(\\n\\t\\t\\t\\tjQuery.merge( this.get(), jQuery( selector, context ) )\\n\\t\\t\\t)\\n\\t\\t);\\n\\t},\\n\\n\\taddBack: function( selector ) {\\n\\t\\treturn this.add( selector == null ?\\n\\t\\t\\tthis.prevObject : this.prevObject.filter( selector )\\n\\t\\t);\\n\\t}\\n} );\\n\\nfunction sibling( cur, dir ) {\\n\\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\\n\\treturn cur;\\n}\\n\\njQuery.each( {\\n\\tparent: function( elem ) {\\n\\t\\tvar parent = elem.parentNode;\\n\\t\\treturn parent && parent.nodeType !== 11 ? parent : null;\\n\\t},\\n\\tparents: function( elem ) {\\n\\t\\treturn dir( elem, \"parentNode\" );\\n\\t},\\n\\tparentsUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \"parentNode\", until );\\n\\t},\\n\\tnext: function( elem ) {\\n\\t\\treturn sibling( elem, \"nextSibling\" );\\n\\t},\\n\\tprev: function( elem ) {\\n\\t\\treturn sibling( elem, \"previousSibling\" );\\n\\t},\\n\\tnextAll: function( elem ) {\\n\\t\\treturn dir( elem, \"nextSibling\" );\\n\\t},\\n\\tprevAll: function( elem ) {\\n\\t\\treturn dir( elem, \"previousSibling\" );\\n\\t},\\n\\tnextUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \"nextSibling\", until );\\n\\t},\\n\\tprevUntil: function( elem, i, until ) {\\n\\t\\treturn dir( elem, \"previousSibling\", until );\\n\\t},\\n\\tsiblings: function( elem ) {\\n\\t\\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\\n\\t},\\n\\tchildren: function( elem ) {\\n\\t\\treturn siblings( elem.firstChild );\\n\\t},\\n\\tcontents: function( elem ) {\\n        if ( nodeName( elem, \"iframe\" ) ) {\\n            return elem.contentDocument;\\n        }\\n\\n        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\\n        // Treat the template element as a regular one in browsers that\\n        // don\\'t support it.\\n        if ( nodeName( elem, \"template\" ) ) {\\n            elem = elem.content || elem;\\n        }\\n\\n        return jQuery.merge( [], elem.childNodes );\\n\\t}\\n}, function( name, fn ) {\\n\\tjQuery.fn[ name ] = function( until, selector ) {\\n\\t\\tvar matched = jQuery.map( this, fn, until );\\n\\n\\t\\tif ( name.slice( -5 ) !== \"Until\" ) {\\n\\t\\t\\tselector = until;\\n\\t\\t}\\n\\n\\t\\tif ( selector && typeof selector === \"string\" ) {\\n\\t\\t\\tmatched = jQuery.filter( selector, matched );\\n\\t\\t}\\n\\n\\t\\tif ( this.length > 1 ) {\\n\\n\\t\\t\\t// Remove duplicates\\n\\t\\t\\tif ( !guaranteedUnique[ name ] ) {\\n\\t\\t\\t\\tjQuery.uniqueSort( matched );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Reverse order for parents* and prev-derivatives\\n\\t\\t\\tif ( rparentsprev.test( name ) ) {\\n\\t\\t\\t\\tmatched.reverse();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( matched );\\n\\t};\\n} );\\nvar rnothtmlwhite = ( /[^\\\\x20\\\\t\\\\r\\\\n\\\\f]+/g );\\n\\n\\n\\n// Convert String-formatted options into Object-formatted ones\\nfunction createOptions( options ) {\\n\\tvar object = {};\\n\\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\\n\\t\\tobject[ flag ] = true;\\n\\t} );\\n\\treturn object;\\n}\\n\\n/*\\n * Create a callback list using the following parameters:\\n *\\n *\\toptions: an optional list of space-separated options that will change how\\n *\\t\\t\\tthe callback list behaves or a more traditional option object\\n *\\n * By default a callback list will act like an event callback list and can be\\n * \"fired\" multiple times.\\n *\\n * Possible options:\\n *\\n *\\tonce:\\t\\t\\twill ensure the callback list can only be fired once (like a Deferred)\\n *\\n *\\tmemory:\\t\\t\\twill keep track of previous values and will call any callback added\\n *\\t\\t\\t\\t\\tafter the list has been fired right away with the latest \"memorized\"\\n *\\t\\t\\t\\t\\tvalues (like a Deferred)\\n *\\n *\\tunique:\\t\\t\\twill ensure a callback can only be added once (no duplicate in the list)\\n *\\n *\\tstopOnFalse:\\tinterrupt callings when a callback returns false\\n *\\n */\\njQuery.Callbacks = function( options ) {\\n\\n\\t// Convert options from String-formatted to Object-formatted if needed\\n\\t// (we check in cache first)\\n\\toptions = typeof options === \"string\" ?\\n\\t\\tcreateOptions( options ) :\\n\\t\\tjQuery.extend( {}, options );\\n\\n\\tvar // Flag to know if list is currently firing\\n\\t\\tfiring,\\n\\n\\t\\t// Last fire value for non-forgettable lists\\n\\t\\tmemory,\\n\\n\\t\\t// Flag to know if list was already fired\\n\\t\\tfired,\\n\\n\\t\\t// Flag to prevent firing\\n\\t\\tlocked,\\n\\n\\t\\t// Actual callback list\\n\\t\\tlist = [],\\n\\n\\t\\t// Queue of execution data for repeatable lists\\n\\t\\tqueue = [],\\n\\n\\t\\t// Index of currently firing callback (modified by add/remove as needed)\\n\\t\\tfiringIndex = -1,\\n\\n\\t\\t// Fire callbacks\\n\\t\\tfire = function() {\\n\\n\\t\\t\\t// Enforce single-firing\\n\\t\\t\\tlocked = locked || options.once;\\n\\n\\t\\t\\t// Execute callbacks for all pending executions,\\n\\t\\t\\t// respecting firingIndex overrides and runtime changes\\n\\t\\t\\tfired = firing = true;\\n\\t\\t\\tfor ( ; queue.length; firingIndex = -1 ) {\\n\\t\\t\\t\\tmemory = queue.shift();\\n\\t\\t\\t\\twhile ( ++firingIndex < list.length ) {\\n\\n\\t\\t\\t\\t\\t// Run callback and check for early termination\\n\\t\\t\\t\\t\\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\\n\\t\\t\\t\\t\\t\\toptions.stopOnFalse ) {\\n\\n\\t\\t\\t\\t\\t\\t// Jump to end and forget the data so .add doesn\\'t re-fire\\n\\t\\t\\t\\t\\t\\tfiringIndex = list.length;\\n\\t\\t\\t\\t\\t\\tmemory = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Forget the data if we\\'re done with it\\n\\t\\t\\tif ( !options.memory ) {\\n\\t\\t\\t\\tmemory = false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfiring = false;\\n\\n\\t\\t\\t// Clean up if we\\'re done firing for good\\n\\t\\t\\tif ( locked ) {\\n\\n\\t\\t\\t\\t// Keep an empty list if we have data for future add calls\\n\\t\\t\\t\\tif ( memory ) {\\n\\t\\t\\t\\t\\tlist = [];\\n\\n\\t\\t\\t\\t// Otherwise, this object is spent\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlist = \"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\t// Actual Callbacks object\\n\\t\\tself = {\\n\\n\\t\\t\\t// Add a callback or a collection of callbacks to the list\\n\\t\\t\\tadd: function() {\\n\\t\\t\\t\\tif ( list ) {\\n\\n\\t\\t\\t\\t\\t// If we have memory from a past run, we should fire after adding\\n\\t\\t\\t\\t\\tif ( memory && !firing ) {\\n\\t\\t\\t\\t\\t\\tfiringIndex = list.length - 1;\\n\\t\\t\\t\\t\\t\\tqueue.push( memory );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t( function add( args ) {\\n\\t\\t\\t\\t\\t\\tjQuery.each( args, function( _, arg ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( isFunction( arg ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( !options.unique || !self.has( arg ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tlist.push( arg );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Inspect recursively\\n\\t\\t\\t\\t\\t\\t\\t\\tadd( arg );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t} )( arguments );\\n\\n\\t\\t\\t\\t\\tif ( memory && !firing ) {\\n\\t\\t\\t\\t\\t\\tfire();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Remove a callback from the list\\n\\t\\t\\tremove: function() {\\n\\t\\t\\t\\tjQuery.each( arguments, function( _, arg ) {\\n\\t\\t\\t\\t\\tvar index;\\n\\t\\t\\t\\t\\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\\n\\t\\t\\t\\t\\t\\tlist.splice( index, 1 );\\n\\n\\t\\t\\t\\t\\t\\t// Handle firing indexes\\n\\t\\t\\t\\t\\t\\tif ( index <= firingIndex ) {\\n\\t\\t\\t\\t\\t\\t\\tfiringIndex--;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Check if a given callback is in the list.\\n\\t\\t\\t// If no argument is given, return whether or not list has callbacks attached.\\n\\t\\t\\thas: function( fn ) {\\n\\t\\t\\t\\treturn fn ?\\n\\t\\t\\t\\t\\tjQuery.inArray( fn, list ) > -1 :\\n\\t\\t\\t\\t\\tlist.length > 0;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Remove all callbacks from the list\\n\\t\\t\\tempty: function() {\\n\\t\\t\\t\\tif ( list ) {\\n\\t\\t\\t\\t\\tlist = [];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Disable .fire and .add\\n\\t\\t\\t// Abort any current/pending executions\\n\\t\\t\\t// Clear all callbacks and values\\n\\t\\t\\tdisable: function() {\\n\\t\\t\\t\\tlocked = queue = [];\\n\\t\\t\\t\\tlist = memory = \"\";\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\t\\t\\tdisabled: function() {\\n\\t\\t\\t\\treturn !list;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Disable .fire\\n\\t\\t\\t// Also disable .add unless we have memory (since it would have no effect)\\n\\t\\t\\t// Abort any pending executions\\n\\t\\t\\tlock: function() {\\n\\t\\t\\t\\tlocked = queue = [];\\n\\t\\t\\t\\tif ( !memory && !firing ) {\\n\\t\\t\\t\\t\\tlist = memory = \"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\t\\t\\tlocked: function() {\\n\\t\\t\\t\\treturn !!locked;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Call all callbacks with the given context and arguments\\n\\t\\t\\tfireWith: function( context, args ) {\\n\\t\\t\\t\\tif ( !locked ) {\\n\\t\\t\\t\\t\\targs = args || [];\\n\\t\\t\\t\\t\\targs = [ context, args.slice ? args.slice() : args ];\\n\\t\\t\\t\\t\\tqueue.push( args );\\n\\t\\t\\t\\t\\tif ( !firing ) {\\n\\t\\t\\t\\t\\t\\tfire();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// Call all the callbacks with the given arguments\\n\\t\\t\\tfire: function() {\\n\\t\\t\\t\\tself.fireWith( this, arguments );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t},\\n\\n\\t\\t\\t// To know if the callbacks have already been called at least once\\n\\t\\t\\tfired: function() {\\n\\t\\t\\t\\treturn !!fired;\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\treturn self;\\n};\\n\\n\\nfunction Identity( v ) {\\n\\treturn v;\\n}\\nfunction Thrower( ex ) {\\n\\tthrow ex;\\n}\\n\\nfunction adoptValue( value, resolve, reject, noValue ) {\\n\\tvar method;\\n\\n\\ttry {\\n\\n\\t\\t// Check for promise aspect first to privilege synchronous behavior\\n\\t\\tif ( value && isFunction( ( method = value.promise ) ) ) {\\n\\t\\t\\tmethod.call( value ).done( resolve ).fail( reject );\\n\\n\\t\\t// Other thenables\\n\\t\\t} else if ( value && isFunction( ( method = value.then ) ) ) {\\n\\t\\t\\tmethod.call( value, resolve, reject );\\n\\n\\t\\t// Other non-thenables\\n\\t\\t} else {\\n\\n\\t\\t\\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\\n\\t\\t\\t// * false: [ value ].slice( 0 ) => resolve( value )\\n\\t\\t\\t// * true: [ value ].slice( 1 ) => resolve()\\n\\t\\t\\tresolve.apply( undefined, [ value ].slice( noValue ) );\\n\\t\\t}\\n\\n\\t// For Promises/A+, convert exceptions into rejections\\n\\t// Since jQuery.when doesn\\'t unwrap thenables, we can skip the extra checks appearing in\\n\\t// Deferred#then to conditionally suppress rejection.\\n\\t} catch ( value ) {\\n\\n\\t\\t// Support: Android 4.0 only\\n\\t\\t// Strict mode functions invoked without .call/.apply get global-object context\\n\\t\\treject.apply( undefined, [ value ] );\\n\\t}\\n}\\n\\njQuery.extend( {\\n\\n\\tDeferred: function( func ) {\\n\\t\\tvar tuples = [\\n\\n\\t\\t\\t\\t// action, add listener, callbacks,\\n\\t\\t\\t\\t// ... .then handlers, argument index, [final state]\\n\\t\\t\\t\\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \"memory\" ), 2 ],\\n\\t\\t\\t\\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\\n\\t\\t\\t\\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\\n\\t\\t\\t\\t\\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\\n\\t\\t\\t],\\n\\t\\t\\tstate = \"pending\",\\n\\t\\t\\tpromise = {\\n\\t\\t\\t\\tstate: function() {\\n\\t\\t\\t\\t\\treturn state;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\talways: function() {\\n\\t\\t\\t\\t\\tdeferred.done( arguments ).fail( arguments );\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t\"catch\": function( fn ) {\\n\\t\\t\\t\\t\\treturn promise.then( null, fn );\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Keep pipe for back-compat\\n\\t\\t\\t\\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\\n\\t\\t\\t\\t\\tvar fns = arguments;\\n\\n\\t\\t\\t\\t\\treturn jQuery.Deferred( function( newDefer ) {\\n\\t\\t\\t\\t\\t\\tjQuery.each( tuples, function( i, tuple ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\\n\\t\\t\\t\\t\\t\\t\\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\\n\\n\\t\\t\\t\\t\\t\\t\\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\\n\\t\\t\\t\\t\\t\\t\\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\\n\\t\\t\\t\\t\\t\\t\\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\\n\\t\\t\\t\\t\\t\\t\\tdeferred[ tuple[ 1 ] ]( function() {\\n\\t\\t\\t\\t\\t\\t\\t\\tvar returned = fn && fn.apply( this, arguments );\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( returned && isFunction( returned.promise ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturned.promise()\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.progress( newDefer.notify )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.done( newDefer.resolve )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t.fail( newDefer.reject );\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnewDefer[ tuple[ 0 ] + \"With\" ](\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthis,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfn ? [ returned ] : arguments\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\tfns = null;\\n\\t\\t\\t\\t\\t} ).promise();\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tthen: function( onFulfilled, onRejected, onProgress ) {\\n\\t\\t\\t\\t\\tvar maxDepth = 0;\\n\\t\\t\\t\\t\\tfunction resolve( depth, deferred, handler, special ) {\\n\\t\\t\\t\\t\\t\\treturn function() {\\n\\t\\t\\t\\t\\t\\t\\tvar that = this,\\n\\t\\t\\t\\t\\t\\t\\t\\targs = arguments,\\n\\t\\t\\t\\t\\t\\t\\t\\tmightThrow = function() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tvar returned, then;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-59\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Ignore double-resolution attempts\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( depth < maxDepth ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturned = handler.apply( that, args );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-48\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( returned === deferred.promise() ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthrow new TypeError( \"Thenable self-resolution\" );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ sections 2.3.3.1, 3.5\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-54\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-75\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Retrieve `then` only once\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthen = returned &&\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-64\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only check objects and functions for thenability\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t( typeof returned === \"object\" ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttypeof returned === \"function\" ) &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned.then;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Handle a returned thenable\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( isFunction( then ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Special processors (notify) just wait for resolution\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( special ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthen.call(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Thrower, special )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Normal processors (resolve) also hook into progress\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// ...and disregard older resolution values\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmaxDepth++;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthen.call(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\treturned,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Thrower, special ),\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tresolve( maxDepth, deferred, Identity,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdeferred.notifyWith )\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Handle all other returned values\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only substitute handlers pass on context\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// and multiple values (non-spec behavior)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( handler !== Identity ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthat = undefined;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\targs = [ returned ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Process the value(s)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Default process is resolve\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t( special || deferred.resolveWith )( that, args );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Only normal processors (resolve) catch and reject exceptions\\n\\t\\t\\t\\t\\t\\t\\t\\tprocess = special ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tmightThrow :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tmightThrow();\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.Deferred.exceptionHook ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tjQuery.Deferred.exceptionHook( e,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tprocess.stackTrace );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.4.1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-61\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Ignore post-resolution exceptions\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( depth + 1 >= maxDepth ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only substitute handlers pass on context\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// and multiple values (non-spec behavior)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( handler !== Thrower ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tthat = undefined;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\targs = [ e ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdeferred.rejectWith( that, args );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\t\\t\\t// Support: Promises/A+ section 2.3.3.3.1\\n\\t\\t\\t\\t\\t\\t\\t// https://promisesaplus.com/#point-57\\n\\t\\t\\t\\t\\t\\t\\t// Re-resolve promises immediately to dodge false rejection from\\n\\t\\t\\t\\t\\t\\t\\t// subsequent errors\\n\\t\\t\\t\\t\\t\\t\\tif ( depth ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tprocess();\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Call an optional hook to record the stack, in case of exception\\n\\t\\t\\t\\t\\t\\t\\t\\t// since it\\'s otherwise lost when execution goes async\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( jQuery.Deferred.getStackHook ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tprocess.stackTrace = jQuery.Deferred.getStackHook();\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\twindow.setTimeout( process );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn jQuery.Deferred( function( newDefer ) {\\n\\n\\t\\t\\t\\t\\t\\t// progress_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 0 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tisFunction( onProgress ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonProgress :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tIdentity,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer.notifyWith\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t// fulfilled_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 1 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tisFunction( onFulfilled ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonFulfilled :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tIdentity\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t// rejected_handlers.add( ... )\\n\\t\\t\\t\\t\\t\\ttuples[ 2 ][ 3 ].add(\\n\\t\\t\\t\\t\\t\\t\\tresolve(\\n\\t\\t\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t\\t\\t\\tnewDefer,\\n\\t\\t\\t\\t\\t\\t\\t\\tisFunction( onRejected ) ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tonRejected :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tThrower\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t} ).promise();\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Get a promise for this deferred\\n\\t\\t\\t\\t// If obj is provided, the promise aspect is added to the object\\n\\t\\t\\t\\tpromise: function( obj ) {\\n\\t\\t\\t\\t\\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdeferred = {};\\n\\n\\t\\t// Add list-specific methods\\n\\t\\tjQuery.each( tuples, function( i, tuple ) {\\n\\t\\t\\tvar list = tuple[ 2 ],\\n\\t\\t\\t\\tstateString = tuple[ 5 ];\\n\\n\\t\\t\\t// promise.progress = list.add\\n\\t\\t\\t// promise.done = list.add\\n\\t\\t\\t// promise.fail = list.add\\n\\t\\t\\tpromise[ tuple[ 1 ] ] = list.add;\\n\\n\\t\\t\\t// Handle state\\n\\t\\t\\tif ( stateString ) {\\n\\t\\t\\t\\tlist.add(\\n\\t\\t\\t\\t\\tfunction() {\\n\\n\\t\\t\\t\\t\\t\\t// state = \"resolved\" (i.e., fulfilled)\\n\\t\\t\\t\\t\\t\\t// state = \"rejected\"\\n\\t\\t\\t\\t\\t\\tstate = stateString;\\n\\t\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t\\t// rejected_callbacks.disable\\n\\t\\t\\t\\t\\t// fulfilled_callbacks.disable\\n\\t\\t\\t\\t\\ttuples[ 3 - i ][ 2 ].disable,\\n\\n\\t\\t\\t\\t\\t// rejected_handlers.disable\\n\\t\\t\\t\\t\\t// fulfilled_handlers.disable\\n\\t\\t\\t\\t\\ttuples[ 3 - i ][ 3 ].disable,\\n\\n\\t\\t\\t\\t\\t// progress_callbacks.lock\\n\\t\\t\\t\\t\\ttuples[ 0 ][ 2 ].lock,\\n\\n\\t\\t\\t\\t\\t// progress_handlers.lock\\n\\t\\t\\t\\t\\ttuples[ 0 ][ 3 ].lock\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// progress_handlers.fire\\n\\t\\t\\t// fulfilled_handlers.fire\\n\\t\\t\\t// rejected_handlers.fire\\n\\t\\t\\tlist.add( tuple[ 3 ].fire );\\n\\n\\t\\t\\t// deferred.notify = function() { deferred.notifyWith(...) }\\n\\t\\t\\t// deferred.resolve = function() { deferred.resolveWith(...) }\\n\\t\\t\\t// deferred.reject = function() { deferred.rejectWith(...) }\\n\\t\\t\\tdeferred[ tuple[ 0 ] ] = function() {\\n\\t\\t\\t\\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t};\\n\\n\\t\\t\\t// deferred.notifyWith = list.fireWith\\n\\t\\t\\t// deferred.resolveWith = list.fireWith\\n\\t\\t\\t// deferred.rejectWith = list.fireWith\\n\\t\\t\\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\\n\\t\\t} );\\n\\n\\t\\t// Make the deferred a promise\\n\\t\\tpromise.promise( deferred );\\n\\n\\t\\t// Call given func if any\\n\\t\\tif ( func ) {\\n\\t\\t\\tfunc.call( deferred, deferred );\\n\\t\\t}\\n\\n\\t\\t// All done!\\n\\t\\treturn deferred;\\n\\t},\\n\\n\\t// Deferred helper\\n\\twhen: function( singleValue ) {\\n\\t\\tvar\\n\\n\\t\\t\\t// count of uncompleted subordinates\\n\\t\\t\\tremaining = arguments.length,\\n\\n\\t\\t\\t// count of unprocessed arguments\\n\\t\\t\\ti = remaining,\\n\\n\\t\\t\\t// subordinate fulfillment data\\n\\t\\t\\tresolveContexts = Array( i ),\\n\\t\\t\\tresolveValues = slice.call( arguments ),\\n\\n\\t\\t\\t// the master Deferred\\n\\t\\t\\tmaster = jQuery.Deferred(),\\n\\n\\t\\t\\t// subordinate callback factory\\n\\t\\t\\tupdateFunc = function( i ) {\\n\\t\\t\\t\\treturn function( value ) {\\n\\t\\t\\t\\t\\tresolveContexts[ i ] = this;\\n\\t\\t\\t\\t\\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\\n\\t\\t\\t\\t\\tif ( !( --remaining ) ) {\\n\\t\\t\\t\\t\\t\\tmaster.resolveWith( resolveContexts, resolveValues );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\t\\t\\t};\\n\\n\\t\\t// Single- and empty arguments are adopted like Promise.resolve\\n\\t\\tif ( remaining <= 1 ) {\\n\\t\\t\\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\\n\\t\\t\\t\\t!remaining );\\n\\n\\t\\t\\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\\n\\t\\t\\tif ( master.state() === \"pending\" ||\\n\\t\\t\\t\\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\\n\\n\\t\\t\\t\\treturn master.then();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Multiple arguments are aggregated like Promise.all array elements\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\\n\\t\\t}\\n\\n\\t\\treturn master.promise();\\n\\t}\\n} );\\n\\n\\n// These usually indicate a programmer mistake during development,\\n// warn about them ASAP rather than swallowing them by default.\\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\\n\\njQuery.Deferred.exceptionHook = function( error, stack ) {\\n\\n\\t// Support: IE 8 - 9 only\\n\\t// Console exists when dev tools are open, which can happen at any time\\n\\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\\n\\t\\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\\n\\t}\\n};\\n\\n\\n\\n\\njQuery.readyException = function( error ) {\\n\\twindow.setTimeout( function() {\\n\\t\\tthrow error;\\n\\t} );\\n};\\n\\n\\n\\n\\n// The deferred used on DOM ready\\nvar readyList = jQuery.Deferred();\\n\\njQuery.fn.ready = function( fn ) {\\n\\n\\treadyList\\n\\t\\t.then( fn )\\n\\n\\t\\t// Wrap jQuery.readyException in a function so that the lookup\\n\\t\\t// happens at the time of error handling instead of callback\\n\\t\\t// registration.\\n\\t\\t.catch( function( error ) {\\n\\t\\t\\tjQuery.readyException( error );\\n\\t\\t} );\\n\\n\\treturn this;\\n};\\n\\njQuery.extend( {\\n\\n\\t// Is the DOM ready to be used? Set to true once it occurs.\\n\\tisReady: false,\\n\\n\\t// A counter to track how many items to wait for before\\n\\t// the ready event fires. See #6781\\n\\treadyWait: 1,\\n\\n\\t// Handle when the DOM is ready\\n\\tready: function( wait ) {\\n\\n\\t\\t// Abort if there are pending holds or we\\'re already ready\\n\\t\\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Remember that the DOM is ready\\n\\t\\tjQuery.isReady = true;\\n\\n\\t\\t// If a normal DOM Ready event fired, decrement, and wait if need be\\n\\t\\tif ( wait !== true && --jQuery.readyWait > 0 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// If there are functions bound, to execute\\n\\t\\treadyList.resolveWith( document, [ jQuery ] );\\n\\t}\\n} );\\n\\njQuery.ready.then = readyList.then;\\n\\n// The ready event handler and self cleanup method\\nfunction completed() {\\n\\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\\n\\twindow.removeEventListener( \"load\", completed );\\n\\tjQuery.ready();\\n}\\n\\n// Catch cases where $(document).ready() is called\\n// after the browser event has already occurred.\\n// Support: IE <=9 - 10 only\\n// Older IE sometimes signals \"interactive\" too soon\\nif ( document.readyState === \"complete\" ||\\n\\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\\n\\n\\t// Handle it asynchronously to allow scripts the opportunity to delay ready\\n\\twindow.setTimeout( jQuery.ready );\\n\\n} else {\\n\\n\\t// Use the handy event callback\\n\\tdocument.addEventListener( \"DOMContentLoaded\", completed );\\n\\n\\t// A fallback to window.onload, that will always work\\n\\twindow.addEventListener( \"load\", completed );\\n}\\n\\n\\n\\n\\n// Multifunctional method to get and set values of a collection\\n// The value/s can optionally be executed if it\\'s a function\\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\\n\\tvar i = 0,\\n\\t\\tlen = elems.length,\\n\\t\\tbulk = key == null;\\n\\n\\t// Sets many values\\n\\tif ( toType( key ) === \"object\" ) {\\n\\t\\tchainable = true;\\n\\t\\tfor ( i in key ) {\\n\\t\\t\\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\\n\\t\\t}\\n\\n\\t// Sets one value\\n\\t} else if ( value !== undefined ) {\\n\\t\\tchainable = true;\\n\\n\\t\\tif ( !isFunction( value ) ) {\\n\\t\\t\\traw = true;\\n\\t\\t}\\n\\n\\t\\tif ( bulk ) {\\n\\n\\t\\t\\t// Bulk operations run against the entire set\\n\\t\\t\\tif ( raw ) {\\n\\t\\t\\t\\tfn.call( elems, value );\\n\\t\\t\\t\\tfn = null;\\n\\n\\t\\t\\t// ...except when executing function values\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbulk = fn;\\n\\t\\t\\t\\tfn = function( elem, key, value ) {\\n\\t\\t\\t\\t\\treturn bulk.call( jQuery( elem ), value );\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( fn ) {\\n\\t\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\t\\tfn(\\n\\t\\t\\t\\t\\telems[ i ], key, raw ?\\n\\t\\t\\t\\t\\tvalue :\\n\\t\\t\\t\\t\\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif ( chainable ) {\\n\\t\\treturn elems;\\n\\t}\\n\\n\\t// Gets\\n\\tif ( bulk ) {\\n\\t\\treturn fn.call( elems );\\n\\t}\\n\\n\\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\\n};\\n\\n\\n// Matches dashed string for camelizing\\nvar rmsPrefix = /^-ms-/,\\n\\trdashAlpha = /-([a-z])/g;\\n\\n// Used by camelCase as callback to replace()\\nfunction fcamelCase( all, letter ) {\\n\\treturn letter.toUpperCase();\\n}\\n\\n// Convert dashed to camelCase; used by the css and data modules\\n// Support: IE <=9 - 11, Edge 12 - 15\\n// Microsoft forgot to hump their vendor prefix (#9572)\\nfunction camelCase( string ) {\\n\\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\\n}\\nvar acceptData = function( owner ) {\\n\\n\\t// Accepts only:\\n\\t//  - Node\\n\\t//    - Node.ELEMENT_NODE\\n\\t//    - Node.DOCUMENT_NODE\\n\\t//  - Object\\n\\t//    - Any\\n\\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\\n};\\n\\n\\n\\n\\nfunction Data() {\\n\\tthis.expando = jQuery.expando + Data.uid++;\\n}\\n\\nData.uid = 1;\\n\\nData.prototype = {\\n\\n\\tcache: function( owner ) {\\n\\n\\t\\t// Check if the owner object already has a cache\\n\\t\\tvar value = owner[ this.expando ];\\n\\n\\t\\t// If not, create one\\n\\t\\tif ( !value ) {\\n\\t\\t\\tvalue = {};\\n\\n\\t\\t\\t// We can accept data for non-element nodes in modern browsers,\\n\\t\\t\\t// but we should not, see #8335.\\n\\t\\t\\t// Always return an empty object.\\n\\t\\t\\tif ( acceptData( owner ) ) {\\n\\n\\t\\t\\t\\t// If it is a node unlikely to be stringify-ed or looped over\\n\\t\\t\\t\\t// use plain assignment\\n\\t\\t\\t\\tif ( owner.nodeType ) {\\n\\t\\t\\t\\t\\towner[ this.expando ] = value;\\n\\n\\t\\t\\t\\t// Otherwise secure it in a non-enumerable property\\n\\t\\t\\t\\t// configurable must be true to allow the property to be\\n\\t\\t\\t\\t// deleted when data is removed\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tObject.defineProperty( owner, this.expando, {\\n\\t\\t\\t\\t\\t\\tvalue: value,\\n\\t\\t\\t\\t\\t\\tconfigurable: true\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn value;\\n\\t},\\n\\tset: function( owner, data, value ) {\\n\\t\\tvar prop,\\n\\t\\t\\tcache = this.cache( owner );\\n\\n\\t\\t// Handle: [ owner, key, value ] args\\n\\t\\t// Always use camelCase key (gh-2257)\\n\\t\\tif ( typeof data === \"string\" ) {\\n\\t\\t\\tcache[ camelCase( data ) ] = value;\\n\\n\\t\\t// Handle: [ owner, { properties } ] args\\n\\t\\t} else {\\n\\n\\t\\t\\t// Copy the properties one-by-one to the cache object\\n\\t\\t\\tfor ( prop in data ) {\\n\\t\\t\\t\\tcache[ camelCase( prop ) ] = data[ prop ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cache;\\n\\t},\\n\\tget: function( owner, key ) {\\n\\t\\treturn key === undefined ?\\n\\t\\t\\tthis.cache( owner ) :\\n\\n\\t\\t\\t// Always use camelCase key (gh-2257)\\n\\t\\t\\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\\n\\t},\\n\\taccess: function( owner, key, value ) {\\n\\n\\t\\t// In cases where either:\\n\\t\\t//\\n\\t\\t//   1. No key was specified\\n\\t\\t//   2. A string key was specified, but no value provided\\n\\t\\t//\\n\\t\\t// Take the \"read\" path and allow the get method to determine\\n\\t\\t// which value to return, respectively either:\\n\\t\\t//\\n\\t\\t//   1. The entire cache object\\n\\t\\t//   2. The data stored at the key\\n\\t\\t//\\n\\t\\tif ( key === undefined ||\\n\\t\\t\\t\\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\\n\\n\\t\\t\\treturn this.get( owner, key );\\n\\t\\t}\\n\\n\\t\\t// When the key is not a string, or both a key and value\\n\\t\\t// are specified, set or extend (existing objects) with either:\\n\\t\\t//\\n\\t\\t//   1. An object of properties\\n\\t\\t//   2. A key and value\\n\\t\\t//\\n\\t\\tthis.set( owner, key, value );\\n\\n\\t\\t// Since the \"set\" path can have two possible entry points\\n\\t\\t// return the expected data based on which path was taken[*]\\n\\t\\treturn value !== undefined ? value : key;\\n\\t},\\n\\tremove: function( owner, key ) {\\n\\t\\tvar i,\\n\\t\\t\\tcache = owner[ this.expando ];\\n\\n\\t\\tif ( cache === undefined ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( key !== undefined ) {\\n\\n\\t\\t\\t// Support array or space separated string of keys\\n\\t\\t\\tif ( Array.isArray( key ) ) {\\n\\n\\t\\t\\t\\t// If key is an array of keys...\\n\\t\\t\\t\\t// We always set camelCase keys, so remove that.\\n\\t\\t\\t\\tkey = key.map( camelCase );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tkey = camelCase( key );\\n\\n\\t\\t\\t\\t// If a key with the spaces exists, use it.\\n\\t\\t\\t\\t// Otherwise, create an array by matching non-whitespace\\n\\t\\t\\t\\tkey = key in cache ?\\n\\t\\t\\t\\t\\t[ key ] :\\n\\t\\t\\t\\t\\t( key.match( rnothtmlwhite ) || [] );\\n\\t\\t\\t}\\n\\n\\t\\t\\ti = key.length;\\n\\n\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\tdelete cache[ key[ i ] ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Remove the expando if there\\'s no more data\\n\\t\\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\\n\\n\\t\\t\\t// Support: Chrome <=35 - 45\\n\\t\\t\\t// Webkit & Blink performance suffers when deleting properties\\n\\t\\t\\t// from DOM nodes, so set to undefined instead\\n\\t\\t\\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\\n\\t\\t\\tif ( owner.nodeType ) {\\n\\t\\t\\t\\towner[ this.expando ] = undefined;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdelete owner[ this.expando ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\thasData: function( owner ) {\\n\\t\\tvar cache = owner[ this.expando ];\\n\\t\\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\\n\\t}\\n};\\nvar dataPriv = new Data();\\n\\nvar dataUser = new Data();\\n\\n\\n\\n//\\tImplementation Summary\\n//\\n//\\t1. Enforce API surface and semantic compatibility with 1.9.x branch\\n//\\t2. Improve the module\\'s maintainability by reducing the storage\\n//\\t\\tpaths to a single mechanism.\\n//\\t3. Use the same single mechanism to support \"private\" and \"user\" data.\\n//\\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\\n//\\t5. Avoid exposing implementation details on user objects (eg. expando properties)\\n//\\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\\n\\nvar rbrace = /^(?:\\\\{[\\\\w\\\\W]*\\\\}|\\\\[[\\\\w\\\\W]*\\\\])$/,\\n\\trmultiDash = /[A-Z]/g;\\n\\nfunction getData( data ) {\\n\\tif ( data === \"true\" ) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif ( data === \"false\" ) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif ( data === \"null\" ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// Only convert to a number if it doesn\\'t change the string\\n\\tif ( data === +data + \"\" ) {\\n\\t\\treturn +data;\\n\\t}\\n\\n\\tif ( rbrace.test( data ) ) {\\n\\t\\treturn JSON.parse( data );\\n\\t}\\n\\n\\treturn data;\\n}\\n\\nfunction dataAttr( elem, key, data ) {\\n\\tvar name;\\n\\n\\t// If nothing was found internally, try to fetch any\\n\\t// data from the HTML5 data-* attribute\\n\\tif ( data === undefined && elem.nodeType === 1 ) {\\n\\t\\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\\n\\t\\tdata = elem.getAttribute( name );\\n\\n\\t\\tif ( typeof data === \"string\" ) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tdata = getData( data );\\n\\t\\t\\t} catch ( e ) {}\\n\\n\\t\\t\\t// Make sure we set the data so it isn\\'t changed later\\n\\t\\t\\tdataUser.set( elem, key, data );\\n\\t\\t} else {\\n\\t\\t\\tdata = undefined;\\n\\t\\t}\\n\\t}\\n\\treturn data;\\n}\\n\\njQuery.extend( {\\n\\thasData: function( elem ) {\\n\\t\\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\\n\\t},\\n\\n\\tdata: function( elem, name, data ) {\\n\\t\\treturn dataUser.access( elem, name, data );\\n\\t},\\n\\n\\tremoveData: function( elem, name ) {\\n\\t\\tdataUser.remove( elem, name );\\n\\t},\\n\\n\\t// TODO: Now that all calls to _data and _removeData have been replaced\\n\\t// with direct calls to dataPriv methods, these can be deprecated.\\n\\t_data: function( elem, name, data ) {\\n\\t\\treturn dataPriv.access( elem, name, data );\\n\\t},\\n\\n\\t_removeData: function( elem, name ) {\\n\\t\\tdataPriv.remove( elem, name );\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tdata: function( key, value ) {\\n\\t\\tvar i, name, data,\\n\\t\\t\\telem = this[ 0 ],\\n\\t\\t\\tattrs = elem && elem.attributes;\\n\\n\\t\\t// Gets all values\\n\\t\\tif ( key === undefined ) {\\n\\t\\t\\tif ( this.length ) {\\n\\t\\t\\t\\tdata = dataUser.get( elem );\\n\\n\\t\\t\\t\\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\\n\\t\\t\\t\\t\\ti = attrs.length;\\n\\t\\t\\t\\t\\twhile ( i-- ) {\\n\\n\\t\\t\\t\\t\\t\\t// Support: IE 11 only\\n\\t\\t\\t\\t\\t\\t// The attrs elements can be null (#14894)\\n\\t\\t\\t\\t\\t\\tif ( attrs[ i ] ) {\\n\\t\\t\\t\\t\\t\\t\\tname = attrs[ i ].name;\\n\\t\\t\\t\\t\\t\\t\\tif ( name.indexOf( \"data-\" ) === 0 ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tname = camelCase( name.slice( 5 ) );\\n\\t\\t\\t\\t\\t\\t\\t\\tdataAttr( elem, name, data[ name ] );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdataPriv.set( elem, \"hasDataAttrs\", true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\t\\t}\\n\\n\\t\\t// Sets multiple values\\n\\t\\tif ( typeof key === \"object\" ) {\\n\\t\\t\\treturn this.each( function() {\\n\\t\\t\\t\\tdataUser.set( this, key );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\tvar data;\\n\\n\\t\\t\\t// The calling jQuery object (element matches) is not empty\\n\\t\\t\\t// (and therefore has an element appears at this[ 0 ]) and the\\n\\t\\t\\t// `value` parameter was not undefined. An empty jQuery object\\n\\t\\t\\t// will result in `undefined` for elem = this[ 0 ] which will\\n\\t\\t\\t// throw an exception if an attempt to read a data cache is made.\\n\\t\\t\\tif ( elem && value === undefined ) {\\n\\n\\t\\t\\t\\t// Attempt to get data from the cache\\n\\t\\t\\t\\t// The key will always be camelCased in Data\\n\\t\\t\\t\\tdata = dataUser.get( elem, key );\\n\\t\\t\\t\\tif ( data !== undefined ) {\\n\\t\\t\\t\\t\\treturn data;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Attempt to \"discover\" the data in\\n\\t\\t\\t\\t// HTML5 custom data-* attrs\\n\\t\\t\\t\\tdata = dataAttr( elem, key );\\n\\t\\t\\t\\tif ( data !== undefined ) {\\n\\t\\t\\t\\t\\treturn data;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// We tried really hard, but the data doesn\\'t exist.\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set the data...\\n\\t\\t\\tthis.each( function() {\\n\\n\\t\\t\\t\\t// We always store the camelCased key\\n\\t\\t\\t\\tdataUser.set( this, key, value );\\n\\t\\t\\t} );\\n\\t\\t}, null, value, arguments.length > 1, null, true );\\n\\t},\\n\\n\\tremoveData: function( key ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tdataUser.remove( this, key );\\n\\t\\t} );\\n\\t}\\n} );\\n\\n\\njQuery.extend( {\\n\\tqueue: function( elem, type, data ) {\\n\\t\\tvar queue;\\n\\n\\t\\tif ( elem ) {\\n\\t\\t\\ttype = ( type || \"fx\" ) + \"queue\";\\n\\t\\t\\tqueue = dataPriv.get( elem, type );\\n\\n\\t\\t\\t// Speed up dequeue by getting out quickly if this is just a lookup\\n\\t\\t\\tif ( data ) {\\n\\t\\t\\t\\tif ( !queue || Array.isArray( data ) ) {\\n\\t\\t\\t\\t\\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tqueue.push( data );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn queue || [];\\n\\t\\t}\\n\\t},\\n\\n\\tdequeue: function( elem, type ) {\\n\\t\\ttype = type || \"fx\";\\n\\n\\t\\tvar queue = jQuery.queue( elem, type ),\\n\\t\\t\\tstartLength = queue.length,\\n\\t\\t\\tfn = queue.shift(),\\n\\t\\t\\thooks = jQuery._queueHooks( elem, type ),\\n\\t\\t\\tnext = function() {\\n\\t\\t\\t\\tjQuery.dequeue( elem, type );\\n\\t\\t\\t};\\n\\n\\t\\t// If the fx queue is dequeued, always remove the progress sentinel\\n\\t\\tif ( fn === \"inprogress\" ) {\\n\\t\\t\\tfn = queue.shift();\\n\\t\\t\\tstartLength--;\\n\\t\\t}\\n\\n\\t\\tif ( fn ) {\\n\\n\\t\\t\\t// Add a progress sentinel to prevent the fx queue from being\\n\\t\\t\\t// automatically dequeued\\n\\t\\t\\tif ( type === \"fx\" ) {\\n\\t\\t\\t\\tqueue.unshift( \"inprogress\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Clear up the last queue stop function\\n\\t\\t\\tdelete hooks.stop;\\n\\t\\t\\tfn.call( elem, next, hooks );\\n\\t\\t}\\n\\n\\t\\tif ( !startLength && hooks ) {\\n\\t\\t\\thooks.empty.fire();\\n\\t\\t}\\n\\t},\\n\\n\\t// Not public - generate a queueHooks object, or return the current one\\n\\t_queueHooks: function( elem, type ) {\\n\\t\\tvar key = type + \"queueHooks\";\\n\\t\\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\\n\\t\\t\\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\\n\\t\\t\\t\\tdataPriv.remove( elem, [ type + \"queue\", key ] );\\n\\t\\t\\t} )\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tqueue: function( type, data ) {\\n\\t\\tvar setter = 2;\\n\\n\\t\\tif ( typeof type !== \"string\" ) {\\n\\t\\t\\tdata = type;\\n\\t\\t\\ttype = \"fx\";\\n\\t\\t\\tsetter--;\\n\\t\\t}\\n\\n\\t\\tif ( arguments.length < setter ) {\\n\\t\\t\\treturn jQuery.queue( this[ 0 ], type );\\n\\t\\t}\\n\\n\\t\\treturn data === undefined ?\\n\\t\\t\\tthis :\\n\\t\\t\\tthis.each( function() {\\n\\t\\t\\t\\tvar queue = jQuery.queue( this, type, data );\\n\\n\\t\\t\\t\\t// Ensure a hooks for this queue\\n\\t\\t\\t\\tjQuery._queueHooks( this, type );\\n\\n\\t\\t\\t\\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\\n\\t\\t\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t},\\n\\tdequeue: function( type ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t} );\\n\\t},\\n\\tclearQueue: function( type ) {\\n\\t\\treturn this.queue( type || \"fx\", [] );\\n\\t},\\n\\n\\t// Get a promise resolved when queues of a certain type\\n\\t// are emptied (fx is the type by default)\\n\\tpromise: function( type, obj ) {\\n\\t\\tvar tmp,\\n\\t\\t\\tcount = 1,\\n\\t\\t\\tdefer = jQuery.Deferred(),\\n\\t\\t\\telements = this,\\n\\t\\t\\ti = this.length,\\n\\t\\t\\tresolve = function() {\\n\\t\\t\\t\\tif ( !( --count ) ) {\\n\\t\\t\\t\\t\\tdefer.resolveWith( elements, [ elements ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\tif ( typeof type !== \"string\" ) {\\n\\t\\t\\tobj = type;\\n\\t\\t\\ttype = undefined;\\n\\t\\t}\\n\\t\\ttype = type || \"fx\";\\n\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\\n\\t\\t\\tif ( tmp && tmp.empty ) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\ttmp.empty.add( resolve );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresolve();\\n\\t\\treturn defer.promise( obj );\\n\\t}\\n} );\\nvar pnum = ( /[+-]?(?:\\\\d*\\\\.|)\\\\d+(?:[eE][+-]?\\\\d+|)/ ).source;\\n\\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\\n\\n\\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\\n\\nvar isHiddenWithinTree = function( elem, el ) {\\n\\n\\t\\t// isHiddenWithinTree might be called from jQuery#filter function;\\n\\t\\t// in that case, element will be second argument\\n\\t\\telem = el || elem;\\n\\n\\t\\t// Inline style trumps all\\n\\t\\treturn elem.style.display === \"none\" ||\\n\\t\\t\\telem.style.display === \"\" &&\\n\\n\\t\\t\\t// Otherwise, check computed style\\n\\t\\t\\t// Support: Firefox <=43 - 45\\n\\t\\t\\t// Disconnected elements can have computed display: none, so first confirm that elem is\\n\\t\\t\\t// in the document.\\n\\t\\t\\tjQuery.contains( elem.ownerDocument, elem ) &&\\n\\n\\t\\t\\tjQuery.css( elem, \"display\" ) === \"none\";\\n\\t};\\n\\nvar swap = function( elem, options, callback, args ) {\\n\\tvar ret, name,\\n\\t\\told = {};\\n\\n\\t// Remember the old values, and insert the new ones\\n\\tfor ( name in options ) {\\n\\t\\told[ name ] = elem.style[ name ];\\n\\t\\telem.style[ name ] = options[ name ];\\n\\t}\\n\\n\\tret = callback.apply( elem, args || [] );\\n\\n\\t// Revert the old values\\n\\tfor ( name in options ) {\\n\\t\\telem.style[ name ] = old[ name ];\\n\\t}\\n\\n\\treturn ret;\\n};\\n\\n\\n\\n\\nfunction adjustCSS( elem, prop, valueParts, tween ) {\\n\\tvar adjusted, scale,\\n\\t\\tmaxIterations = 20,\\n\\t\\tcurrentValue = tween ?\\n\\t\\t\\tfunction() {\\n\\t\\t\\t\\treturn tween.cur();\\n\\t\\t\\t} :\\n\\t\\t\\tfunction() {\\n\\t\\t\\t\\treturn jQuery.css( elem, prop, \"\" );\\n\\t\\t\\t},\\n\\t\\tinitial = currentValue(),\\n\\t\\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\\n\\n\\t\\t// Starting value computation is required for potential unit mismatches\\n\\t\\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\\n\\t\\t\\trcssNum.exec( jQuery.css( elem, prop ) );\\n\\n\\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\\n\\n\\t\\t// Support: Firefox <=54\\n\\t\\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\\n\\t\\tinitial = initial / 2;\\n\\n\\t\\t// Trust units reported by jQuery.css\\n\\t\\tunit = unit || initialInUnit[ 3 ];\\n\\n\\t\\t// Iteratively approximate from a nonzero starting point\\n\\t\\tinitialInUnit = +initial || 1;\\n\\n\\t\\twhile ( maxIterations-- ) {\\n\\n\\t\\t\\t// Evaluate and update our best guess (doubling guesses that zero out).\\n\\t\\t\\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\\n\\t\\t\\tjQuery.style( elem, prop, initialInUnit + unit );\\n\\t\\t\\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\\n\\t\\t\\t\\tmaxIterations = 0;\\n\\t\\t\\t}\\n\\t\\t\\tinitialInUnit = initialInUnit / scale;\\n\\n\\t\\t}\\n\\n\\t\\tinitialInUnit = initialInUnit * 2;\\n\\t\\tjQuery.style( elem, prop, initialInUnit + unit );\\n\\n\\t\\t// Make sure we update the tween properties later on\\n\\t\\tvalueParts = valueParts || [];\\n\\t}\\n\\n\\tif ( valueParts ) {\\n\\t\\tinitialInUnit = +initialInUnit || +initial || 0;\\n\\n\\t\\t// Apply relative offset (+=/-=) if specified\\n\\t\\tadjusted = valueParts[ 1 ] ?\\n\\t\\t\\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\\n\\t\\t\\t+valueParts[ 2 ];\\n\\t\\tif ( tween ) {\\n\\t\\t\\ttween.unit = unit;\\n\\t\\t\\ttween.start = initialInUnit;\\n\\t\\t\\ttween.end = adjusted;\\n\\t\\t}\\n\\t}\\n\\treturn adjusted;\\n}\\n\\n\\nvar defaultDisplayMap = {};\\n\\nfunction getDefaultDisplay( elem ) {\\n\\tvar temp,\\n\\t\\tdoc = elem.ownerDocument,\\n\\t\\tnodeName = elem.nodeName,\\n\\t\\tdisplay = defaultDisplayMap[ nodeName ];\\n\\n\\tif ( display ) {\\n\\t\\treturn display;\\n\\t}\\n\\n\\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\\n\\tdisplay = jQuery.css( temp, \"display\" );\\n\\n\\ttemp.parentNode.removeChild( temp );\\n\\n\\tif ( display === \"none\" ) {\\n\\t\\tdisplay = \"block\";\\n\\t}\\n\\tdefaultDisplayMap[ nodeName ] = display;\\n\\n\\treturn display;\\n}\\n\\nfunction showHide( elements, show ) {\\n\\tvar display, elem,\\n\\t\\tvalues = [],\\n\\t\\tindex = 0,\\n\\t\\tlength = elements.length;\\n\\n\\t// Determine new display value for elements that need to change\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\telem = elements[ index ];\\n\\t\\tif ( !elem.style ) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tdisplay = elem.style.display;\\n\\t\\tif ( show ) {\\n\\n\\t\\t\\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\\n\\t\\t\\t// check is required in this first loop unless we have a nonempty display value (either\\n\\t\\t\\t// inline or about-to-be-restored)\\n\\t\\t\\tif ( display === \"none\" ) {\\n\\t\\t\\t\\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\\n\\t\\t\\t\\tif ( !values[ index ] ) {\\n\\t\\t\\t\\t\\telem.style.display = \"\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\\n\\t\\t\\t\\tvalues[ index ] = getDefaultDisplay( elem );\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif ( display !== \"none\" ) {\\n\\t\\t\\t\\tvalues[ index ] = \"none\";\\n\\n\\t\\t\\t\\t// Remember what we\\'re overwriting\\n\\t\\t\\t\\tdataPriv.set( elem, \"display\", display );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Set the display of the elements in a second loop to avoid constant reflow\\n\\tfor ( index = 0; index < length; index++ ) {\\n\\t\\tif ( values[ index ] != null ) {\\n\\t\\t\\telements[ index ].style.display = values[ index ];\\n\\t\\t}\\n\\t}\\n\\n\\treturn elements;\\n}\\n\\njQuery.fn.extend( {\\n\\tshow: function() {\\n\\t\\treturn showHide( this, true );\\n\\t},\\n\\thide: function() {\\n\\t\\treturn showHide( this );\\n\\t},\\n\\ttoggle: function( state ) {\\n\\t\\tif ( typeof state === \"boolean\" ) {\\n\\t\\t\\treturn state ? this.show() : this.hide();\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tif ( isHiddenWithinTree( this ) ) {\\n\\t\\t\\t\\tjQuery( this ).show();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tjQuery( this ).hide();\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n} );\\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\\n\\nvar rtagName = ( /<([a-z][^\\\\/\\\\0>\\\\x20\\\\t\\\\r\\\\n\\\\f]+)/i );\\n\\nvar rscriptType = ( /^$|^module$|\\\\/(?:java|ecma)script/i );\\n\\n\\n\\n// We have to close these tags to support XHTML (#13200)\\nvar wrapMap = {\\n\\n\\t// Support: IE <=9 only\\n\\toption: [ 1, \"<select multiple=\\'multiple\\'>\", \"</select>\" ],\\n\\n\\t// XHTML parsers do not magically insert elements in the\\n\\t// same way that tag soup parsers do. So we cannot shorten\\n\\t// this by omitting <tbody> or other required elements.\\n\\tthead: [ 1, \"<table>\", \"</table>\" ],\\n\\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\\n\\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\\n\\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\\n\\n\\t_default: [ 0, \"\", \"\" ]\\n};\\n\\n// Support: IE <=9 only\\nwrapMap.optgroup = wrapMap.option;\\n\\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\\nwrapMap.th = wrapMap.td;\\n\\n\\nfunction getAll( context, tag ) {\\n\\n\\t// Support: IE <=9 - 11 only\\n\\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\\n\\tvar ret;\\n\\n\\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\\n\\t\\tret = context.getElementsByTagName( tag || \"*\" );\\n\\n\\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\\n\\t\\tret = context.querySelectorAll( tag || \"*\" );\\n\\n\\t} else {\\n\\t\\tret = [];\\n\\t}\\n\\n\\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\\n\\t\\treturn jQuery.merge( [ context ], ret );\\n\\t}\\n\\n\\treturn ret;\\n}\\n\\n\\n// Mark scripts as having already been evaluated\\nfunction setGlobalEval( elems, refElements ) {\\n\\tvar i = 0,\\n\\t\\tl = elems.length;\\n\\n\\tfor ( ; i < l; i++ ) {\\n\\t\\tdataPriv.set(\\n\\t\\t\\telems[ i ],\\n\\t\\t\\t\"globalEval\",\\n\\t\\t\\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\\n\\t\\t);\\n\\t}\\n}\\n\\n\\nvar rhtml = /<|&#?\\\\w+;/;\\n\\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\\n\\tvar elem, tmp, tag, wrap, contains, j,\\n\\t\\tfragment = context.createDocumentFragment(),\\n\\t\\tnodes = [],\\n\\t\\ti = 0,\\n\\t\\tl = elems.length;\\n\\n\\tfor ( ; i < l; i++ ) {\\n\\t\\telem = elems[ i ];\\n\\n\\t\\tif ( elem || elem === 0 ) {\\n\\n\\t\\t\\t// Add nodes directly\\n\\t\\t\\tif ( toType( elem ) === \"object\" ) {\\n\\n\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\\n\\n\\t\\t\\t// Convert non-html into a text node\\n\\t\\t\\t} else if ( !rhtml.test( elem ) ) {\\n\\t\\t\\t\\tnodes.push( context.createTextNode( elem ) );\\n\\n\\t\\t\\t// Convert html into DOM nodes\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\\n\\n\\t\\t\\t\\t// Deserialize a standard representation\\n\\t\\t\\t\\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\\n\\t\\t\\t\\twrap = wrapMap[ tag ] || wrapMap._default;\\n\\t\\t\\t\\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\\n\\n\\t\\t\\t\\t// Descend through wrappers to the right content\\n\\t\\t\\t\\tj = wrap[ 0 ];\\n\\t\\t\\t\\twhile ( j-- ) {\\n\\t\\t\\t\\t\\ttmp = tmp.lastChild;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\tjQuery.merge( nodes, tmp.childNodes );\\n\\n\\t\\t\\t\\t// Remember the top-level container\\n\\t\\t\\t\\ttmp = fragment.firstChild;\\n\\n\\t\\t\\t\\t// Ensure the created nodes are orphaned (#12392)\\n\\t\\t\\t\\ttmp.textContent = \"\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Remove wrapper from fragment\\n\\tfragment.textContent = \"\";\\n\\n\\ti = 0;\\n\\twhile ( ( elem = nodes[ i++ ] ) ) {\\n\\n\\t\\t// Skip elements already in the context collection (trac-4087)\\n\\t\\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\\n\\t\\t\\tif ( ignored ) {\\n\\t\\t\\t\\tignored.push( elem );\\n\\t\\t\\t}\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tcontains = jQuery.contains( elem.ownerDocument, elem );\\n\\n\\t\\t// Append to fragment\\n\\t\\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\\n\\n\\t\\t// Preserve script evaluation history\\n\\t\\tif ( contains ) {\\n\\t\\t\\tsetGlobalEval( tmp );\\n\\t\\t}\\n\\n\\t\\t// Capture executables\\n\\t\\tif ( scripts ) {\\n\\t\\t\\tj = 0;\\n\\t\\t\\twhile ( ( elem = tmp[ j++ ] ) ) {\\n\\t\\t\\t\\tif ( rscriptType.test( elem.type || \"\" ) ) {\\n\\t\\t\\t\\t\\tscripts.push( elem );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn fragment;\\n}\\n\\n\\n( function() {\\n\\tvar fragment = document.createDocumentFragment(),\\n\\t\\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\\n\\t\\tinput = document.createElement( \"input\" );\\n\\n\\t// Support: Android 4.0 - 4.3 only\\n\\t// Check state lost if the name is set (#11217)\\n\\t// Support: Windows Web Apps (WWA)\\n\\t// `name` and `type` must use .setAttribute for WWA (#14901)\\n\\tinput.setAttribute( \"type\", \"radio\" );\\n\\tinput.setAttribute( \"checked\", \"checked\" );\\n\\tinput.setAttribute( \"name\", \"t\" );\\n\\n\\tdiv.appendChild( input );\\n\\n\\t// Support: Android <=4.1 only\\n\\t// Older WebKit doesn\\'t clone checked state correctly in fragments\\n\\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\\n\\n\\t// Support: IE <=11 only\\n\\t// Make sure textarea (and checkbox) defaultValue is properly cloned\\n\\tdiv.innerHTML = \"<textarea>x</textarea>\";\\n\\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\\n} )();\\nvar documentElement = document.documentElement;\\n\\n\\n\\nvar\\n\\trkeyEvent = /^key/,\\n\\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\\n\\trtypenamespace = /^([^.]*)(?:\\\\.(.+)|)/;\\n\\nfunction returnTrue() {\\n\\treturn true;\\n}\\n\\nfunction returnFalse() {\\n\\treturn false;\\n}\\n\\n// Support: IE <=9 only\\n// See #13393 for more info\\nfunction safeActiveElement() {\\n\\ttry {\\n\\t\\treturn document.activeElement;\\n\\t} catch ( err ) { }\\n}\\n\\nfunction on( elem, types, selector, data, fn, one ) {\\n\\tvar origFn, type;\\n\\n\\t// Types can be a map of types/handlers\\n\\tif ( typeof types === \"object\" ) {\\n\\n\\t\\t// ( types-Object, selector, data )\\n\\t\\tif ( typeof selector !== \"string\" ) {\\n\\n\\t\\t\\t// ( types-Object, data )\\n\\t\\t\\tdata = data || selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t\\tfor ( type in types ) {\\n\\t\\t\\ton( elem, type, selector, data, types[ type ], one );\\n\\t\\t}\\n\\t\\treturn elem;\\n\\t}\\n\\n\\tif ( data == null && fn == null ) {\\n\\n\\t\\t// ( types, fn )\\n\\t\\tfn = selector;\\n\\t\\tdata = selector = undefined;\\n\\t} else if ( fn == null ) {\\n\\t\\tif ( typeof selector === \"string\" ) {\\n\\n\\t\\t\\t// ( types, selector, fn )\\n\\t\\t\\tfn = data;\\n\\t\\t\\tdata = undefined;\\n\\t\\t} else {\\n\\n\\t\\t\\t// ( types, data, fn )\\n\\t\\t\\tfn = data;\\n\\t\\t\\tdata = selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t}\\n\\tif ( fn === false ) {\\n\\t\\tfn = returnFalse;\\n\\t} else if ( !fn ) {\\n\\t\\treturn elem;\\n\\t}\\n\\n\\tif ( one === 1 ) {\\n\\t\\torigFn = fn;\\n\\t\\tfn = function( event ) {\\n\\n\\t\\t\\t// Can use an empty set, since event contains the info\\n\\t\\t\\tjQuery().off( event );\\n\\t\\t\\treturn origFn.apply( this, arguments );\\n\\t\\t};\\n\\n\\t\\t// Use same guid so caller can remove using origFn\\n\\t\\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\\n\\t}\\n\\treturn elem.each( function() {\\n\\t\\tjQuery.event.add( this, types, fn, data, selector );\\n\\t} );\\n}\\n\\n/*\\n * Helper functions for managing events -- not part of the public interface.\\n * Props to Dean Edwards\\' addEvent library for many of the ideas.\\n */\\njQuery.event = {\\n\\n\\tglobal: {},\\n\\n\\tadd: function( elem, types, handler, data, selector ) {\\n\\n\\t\\tvar handleObjIn, eventHandle, tmp,\\n\\t\\t\\tevents, t, handleObj,\\n\\t\\t\\tspecial, handlers, type, namespaces, origType,\\n\\t\\t\\telemData = dataPriv.get( elem );\\n\\n\\t\\t// Don\\'t attach events to noData or text/comment nodes (but allow plain objects)\\n\\t\\tif ( !elemData ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Caller can pass in an object of custom data in lieu of the handler\\n\\t\\tif ( handler.handler ) {\\n\\t\\t\\thandleObjIn = handler;\\n\\t\\t\\thandler = handleObjIn.handler;\\n\\t\\t\\tselector = handleObjIn.selector;\\n\\t\\t}\\n\\n\\t\\t// Ensure that invalid selectors throw exceptions at attach time\\n\\t\\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\\n\\t\\tif ( selector ) {\\n\\t\\t\\tjQuery.find.matchesSelector( documentElement, selector );\\n\\t\\t}\\n\\n\\t\\t// Make sure that the handler has a unique ID, used to find/remove it later\\n\\t\\tif ( !handler.guid ) {\\n\\t\\t\\thandler.guid = jQuery.guid++;\\n\\t\\t}\\n\\n\\t\\t// Init the element\\'s event structure and main handler, if this is the first\\n\\t\\tif ( !( events = elemData.events ) ) {\\n\\t\\t\\tevents = elemData.events = {};\\n\\t\\t}\\n\\t\\tif ( !( eventHandle = elemData.handle ) ) {\\n\\t\\t\\teventHandle = elemData.handle = function( e ) {\\n\\n\\t\\t\\t\\t// Discard the second event of a jQuery.event.trigger() and\\n\\t\\t\\t\\t// when an event is called after a page has unloaded\\n\\t\\t\\t\\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\\n\\t\\t\\t\\t\\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\t// Handle multiple events separated by a space\\n\\t\\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\\n\\t\\tt = types.length;\\n\\t\\twhile ( t-- ) {\\n\\t\\t\\ttmp = rtypenamespace.exec( types[ t ] ) || [];\\n\\t\\t\\ttype = origType = tmp[ 1 ];\\n\\t\\t\\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\\n\\n\\t\\t\\t// There *must* be a type, no attaching namespace-only handlers\\n\\t\\t\\tif ( !type ) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If event changes its type, use the special event handlers for the changed type\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\n\\t\\t\\t// If selector defined, determine special event api type, otherwise given type\\n\\t\\t\\ttype = ( selector ? special.delegateType : special.bindType ) || type;\\n\\n\\t\\t\\t// Update special based on newly reset type\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\n\\t\\t\\t// handleObj is passed to all event handlers\\n\\t\\t\\thandleObj = jQuery.extend( {\\n\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\torigType: origType,\\n\\t\\t\\t\\tdata: data,\\n\\t\\t\\t\\thandler: handler,\\n\\t\\t\\t\\tguid: handler.guid,\\n\\t\\t\\t\\tselector: selector,\\n\\t\\t\\t\\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\\n\\t\\t\\t\\tnamespace: namespaces.join( \".\" )\\n\\t\\t\\t}, handleObjIn );\\n\\n\\t\\t\\t// Init the event handler queue if we\\'re the first\\n\\t\\t\\tif ( !( handlers = events[ type ] ) ) {\\n\\t\\t\\t\\thandlers = events[ type ] = [];\\n\\t\\t\\t\\thandlers.delegateCount = 0;\\n\\n\\t\\t\\t\\t// Only use addEventListener if the special events handler returns false\\n\\t\\t\\t\\tif ( !special.setup ||\\n\\t\\t\\t\\t\\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\\n\\n\\t\\t\\t\\t\\tif ( elem.addEventListener ) {\\n\\t\\t\\t\\t\\t\\telem.addEventListener( type, eventHandle );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( special.add ) {\\n\\t\\t\\t\\tspecial.add.call( elem, handleObj );\\n\\n\\t\\t\\t\\tif ( !handleObj.handler.guid ) {\\n\\t\\t\\t\\t\\thandleObj.handler.guid = handler.guid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add to the element\\'s handler list, delegates in front\\n\\t\\t\\tif ( selector ) {\\n\\t\\t\\t\\thandlers.splice( handlers.delegateCount++, 0, handleObj );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\thandlers.push( handleObj );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Keep track of which events have ever been used, for event optimization\\n\\t\\t\\tjQuery.event.global[ type ] = true;\\n\\t\\t}\\n\\n\\t},\\n\\n\\t// Detach an event or set of events from an element\\n\\tremove: function( elem, types, handler, selector, mappedTypes ) {\\n\\n\\t\\tvar j, origCount, tmp,\\n\\t\\t\\tevents, t, handleObj,\\n\\t\\t\\tspecial, handlers, type, namespaces, origType,\\n\\t\\t\\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\\n\\n\\t\\tif ( !elemData || !( events = elemData.events ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Once for each type.namespace in types; type may be omitted\\n\\t\\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\\n\\t\\tt = types.length;\\n\\t\\twhile ( t-- ) {\\n\\t\\t\\ttmp = rtypenamespace.exec( types[ t ] ) || [];\\n\\t\\t\\ttype = origType = tmp[ 1 ];\\n\\t\\t\\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\\n\\n\\t\\t\\t// Unbind all events (on this namespace, if provided) for the element\\n\\t\\t\\tif ( !type ) {\\n\\t\\t\\t\\tfor ( type in events ) {\\n\\t\\t\\t\\t\\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\t\\t\\ttype = ( selector ? special.delegateType : special.bindType ) || type;\\n\\t\\t\\thandlers = events[ type ] || [];\\n\\t\\t\\ttmp = tmp[ 2 ] &&\\n\\t\\t\\t\\tnew RegExp( \"(^|\\\\\\\\.)\" + namespaces.join( \"\\\\\\\\.(?:.*\\\\\\\\.|)\" ) + \"(\\\\\\\\.|$)\" );\\n\\n\\t\\t\\t// Remove matching events\\n\\t\\t\\torigCount = j = handlers.length;\\n\\t\\t\\twhile ( j-- ) {\\n\\t\\t\\t\\thandleObj = handlers[ j ];\\n\\n\\t\\t\\t\\tif ( ( mappedTypes || origType === handleObj.origType ) &&\\n\\t\\t\\t\\t\\t( !handler || handler.guid === handleObj.guid ) &&\\n\\t\\t\\t\\t\\t( !tmp || tmp.test( handleObj.namespace ) ) &&\\n\\t\\t\\t\\t\\t( !selector || selector === handleObj.selector ||\\n\\t\\t\\t\\t\\t\\tselector === \"**\" && handleObj.selector ) ) {\\n\\t\\t\\t\\t\\thandlers.splice( j, 1 );\\n\\n\\t\\t\\t\\t\\tif ( handleObj.selector ) {\\n\\t\\t\\t\\t\\t\\thandlers.delegateCount--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( special.remove ) {\\n\\t\\t\\t\\t\\t\\tspecial.remove.call( elem, handleObj );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Remove generic event handler if we removed something and no more handlers exist\\n\\t\\t\\t// (avoids potential for endless recursion during removal of special event handlers)\\n\\t\\t\\tif ( origCount && !handlers.length ) {\\n\\t\\t\\t\\tif ( !special.teardown ||\\n\\t\\t\\t\\t\\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\\n\\n\\t\\t\\t\\t\\tjQuery.removeEvent( elem, type, elemData.handle );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdelete events[ type ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Remove data and the expando if it\\'s no longer used\\n\\t\\tif ( jQuery.isEmptyObject( events ) ) {\\n\\t\\t\\tdataPriv.remove( elem, \"handle events\" );\\n\\t\\t}\\n\\t},\\n\\n\\tdispatch: function( nativeEvent ) {\\n\\n\\t\\t// Make a writable jQuery.Event from the native event object\\n\\t\\tvar event = jQuery.event.fix( nativeEvent );\\n\\n\\t\\tvar i, j, ret, matched, handleObj, handlerQueue,\\n\\t\\t\\targs = new Array( arguments.length ),\\n\\t\\t\\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\\n\\t\\t\\tspecial = jQuery.event.special[ event.type ] || {};\\n\\n\\t\\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\\n\\t\\targs[ 0 ] = event;\\n\\n\\t\\tfor ( i = 1; i < arguments.length; i++ ) {\\n\\t\\t\\targs[ i ] = arguments[ i ];\\n\\t\\t}\\n\\n\\t\\tevent.delegateTarget = this;\\n\\n\\t\\t// Call the preDispatch hook for the mapped type, and let it bail if desired\\n\\t\\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Determine handlers\\n\\t\\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\\n\\n\\t\\t// Run delegates first; they may want to stop propagation beneath us\\n\\t\\ti = 0;\\n\\t\\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\\n\\t\\t\\tevent.currentTarget = matched.elem;\\n\\n\\t\\t\\tj = 0;\\n\\t\\t\\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\\n\\t\\t\\t\\t!event.isImmediatePropagationStopped() ) {\\n\\n\\t\\t\\t\\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\\n\\t\\t\\t\\t// a subset or equal to those in the bound event (both can have no namespace).\\n\\t\\t\\t\\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\\n\\n\\t\\t\\t\\t\\tevent.handleObj = handleObj;\\n\\t\\t\\t\\t\\tevent.data = handleObj.data;\\n\\n\\t\\t\\t\\t\\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\\n\\t\\t\\t\\t\\t\\thandleObj.handler ).apply( matched.elem, args );\\n\\n\\t\\t\\t\\t\\tif ( ret !== undefined ) {\\n\\t\\t\\t\\t\\t\\tif ( ( event.result = ret ) === false ) {\\n\\t\\t\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\t\\t\\tevent.stopPropagation();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Call the postDispatch hook for the mapped type\\n\\t\\tif ( special.postDispatch ) {\\n\\t\\t\\tspecial.postDispatch.call( this, event );\\n\\t\\t}\\n\\n\\t\\treturn event.result;\\n\\t},\\n\\n\\thandlers: function( event, handlers ) {\\n\\t\\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\\n\\t\\t\\thandlerQueue = [],\\n\\t\\t\\tdelegateCount = handlers.delegateCount,\\n\\t\\t\\tcur = event.target;\\n\\n\\t\\t// Find delegate handlers\\n\\t\\tif ( delegateCount &&\\n\\n\\t\\t\\t// Support: IE <=9\\n\\t\\t\\t// Black-hole SVG <use> instance trees (trac-13180)\\n\\t\\t\\tcur.nodeType &&\\n\\n\\t\\t\\t// Support: Firefox <=42\\n\\t\\t\\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\\n\\t\\t\\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\\n\\t\\t\\t// Support: IE 11 only\\n\\t\\t\\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\\n\\t\\t\\t!( event.type === \"click\" && event.button >= 1 ) ) {\\n\\n\\t\\t\\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\\n\\n\\t\\t\\t\\t// Don\\'t check non-elements (#13208)\\n\\t\\t\\t\\t// Don\\'t process clicks on disabled elements (#6911, #8165, #11382, #11764)\\n\\t\\t\\t\\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\\n\\t\\t\\t\\t\\tmatchedHandlers = [];\\n\\t\\t\\t\\t\\tmatchedSelectors = {};\\n\\t\\t\\t\\t\\tfor ( i = 0; i < delegateCount; i++ ) {\\n\\t\\t\\t\\t\\t\\thandleObj = handlers[ i ];\\n\\n\\t\\t\\t\\t\\t\\t// Don\\'t conflict with Object.prototype properties (#13203)\\n\\t\\t\\t\\t\\t\\tsel = handleObj.selector + \" \";\\n\\n\\t\\t\\t\\t\\t\\tif ( matchedSelectors[ sel ] === undefined ) {\\n\\t\\t\\t\\t\\t\\t\\tmatchedSelectors[ sel ] = handleObj.needsContext ?\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery( sel, this ).index( cur ) > -1 :\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.find( sel, this, null, [ cur ] ).length;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif ( matchedSelectors[ sel ] ) {\\n\\t\\t\\t\\t\\t\\t\\tmatchedHandlers.push( handleObj );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( matchedHandlers.length ) {\\n\\t\\t\\t\\t\\t\\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Add the remaining (directly-bound) handlers\\n\\t\\tcur = this;\\n\\t\\tif ( delegateCount < handlers.length ) {\\n\\t\\t\\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\\n\\t\\t}\\n\\n\\t\\treturn handlerQueue;\\n\\t},\\n\\n\\taddProp: function( name, hook ) {\\n\\t\\tObject.defineProperty( jQuery.Event.prototype, name, {\\n\\t\\t\\tenumerable: true,\\n\\t\\t\\tconfigurable: true,\\n\\n\\t\\t\\tget: isFunction( hook ) ?\\n\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\tif ( this.originalEvent ) {\\n\\t\\t\\t\\t\\t\\t\\treturn hook( this.originalEvent );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} :\\n\\t\\t\\t\\tfunction() {\\n\\t\\t\\t\\t\\tif ( this.originalEvent ) {\\n\\t\\t\\t\\t\\t\\t\\treturn this.originalEvent[ name ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\tset: function( value ) {\\n\\t\\t\\t\\tObject.defineProperty( this, name, {\\n\\t\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\t\\tconfigurable: true,\\n\\t\\t\\t\\t\\twritable: true,\\n\\t\\t\\t\\t\\tvalue: value\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tfix: function( originalEvent ) {\\n\\t\\treturn originalEvent[ jQuery.expando ] ?\\n\\t\\t\\toriginalEvent :\\n\\t\\t\\tnew jQuery.Event( originalEvent );\\n\\t},\\n\\n\\tspecial: {\\n\\t\\tload: {\\n\\n\\t\\t\\t// Prevent triggered image.load events from bubbling to window.load\\n\\t\\t\\tnoBubble: true\\n\\t\\t},\\n\\t\\tfocus: {\\n\\n\\t\\t\\t// Fire native event if possible so blur/focus sequence is correct\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this !== safeActiveElement() && this.focus ) {\\n\\t\\t\\t\\t\\tthis.focus();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdelegateType: \"focusin\"\\n\\t\\t},\\n\\t\\tblur: {\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this === safeActiveElement() && this.blur ) {\\n\\t\\t\\t\\t\\tthis.blur();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tdelegateType: \"focusout\"\\n\\t\\t},\\n\\t\\tclick: {\\n\\n\\t\\t\\t// For checkbox, fire native event so checked state will be right\\n\\t\\t\\ttrigger: function() {\\n\\t\\t\\t\\tif ( this.type === \"checkbox\" && this.click && nodeName( this, \"input\" ) ) {\\n\\t\\t\\t\\t\\tthis.click();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\t// For cross-browser consistency, don\\'t fire native .click() on links\\n\\t\\t\\t_default: function( event ) {\\n\\t\\t\\t\\treturn nodeName( event.target, \"a\" );\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tbeforeunload: {\\n\\t\\t\\tpostDispatch: function( event ) {\\n\\n\\t\\t\\t\\t// Support: Firefox 20+\\n\\t\\t\\t\\t// Firefox doesn\\'t alert if the returnValue field is not set.\\n\\t\\t\\t\\tif ( event.result !== undefined && event.originalEvent ) {\\n\\t\\t\\t\\t\\tevent.originalEvent.returnValue = event.result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.removeEvent = function( elem, type, handle ) {\\n\\n\\t// This \"if\" is needed for plain objects\\n\\tif ( elem.removeEventListener ) {\\n\\t\\telem.removeEventListener( type, handle );\\n\\t}\\n};\\n\\njQuery.Event = function( src, props ) {\\n\\n\\t// Allow instantiation without the \\'new\\' keyword\\n\\tif ( !( this instanceof jQuery.Event ) ) {\\n\\t\\treturn new jQuery.Event( src, props );\\n\\t}\\n\\n\\t// Event object\\n\\tif ( src && src.type ) {\\n\\t\\tthis.originalEvent = src;\\n\\t\\tthis.type = src.type;\\n\\n\\t\\t// Events bubbling up the document may have been marked as prevented\\n\\t\\t// by a handler lower down the tree; reflect the correct value.\\n\\t\\tthis.isDefaultPrevented = src.defaultPrevented ||\\n\\t\\t\\t\\tsrc.defaultPrevented === undefined &&\\n\\n\\t\\t\\t\\t// Support: Android <=2.3 only\\n\\t\\t\\t\\tsrc.returnValue === false ?\\n\\t\\t\\treturnTrue :\\n\\t\\t\\treturnFalse;\\n\\n\\t\\t// Create target properties\\n\\t\\t// Support: Safari <=6 - 7 only\\n\\t\\t// Target should not be a text node (#504, #13143)\\n\\t\\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\\n\\t\\t\\tsrc.target.parentNode :\\n\\t\\t\\tsrc.target;\\n\\n\\t\\tthis.currentTarget = src.currentTarget;\\n\\t\\tthis.relatedTarget = src.relatedTarget;\\n\\n\\t// Event type\\n\\t} else {\\n\\t\\tthis.type = src;\\n\\t}\\n\\n\\t// Put explicitly provided properties onto the event object\\n\\tif ( props ) {\\n\\t\\tjQuery.extend( this, props );\\n\\t}\\n\\n\\t// Create a timestamp if incoming event doesn\\'t have one\\n\\tthis.timeStamp = src && src.timeStamp || Date.now();\\n\\n\\t// Mark it as fixed\\n\\tthis[ jQuery.expando ] = true;\\n};\\n\\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\\njQuery.Event.prototype = {\\n\\tconstructor: jQuery.Event,\\n\\tisDefaultPrevented: returnFalse,\\n\\tisPropagationStopped: returnFalse,\\n\\tisImmediatePropagationStopped: returnFalse,\\n\\tisSimulated: false,\\n\\n\\tpreventDefault: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isDefaultPrevented = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.preventDefault();\\n\\t\\t}\\n\\t},\\n\\tstopPropagation: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isPropagationStopped = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.stopPropagation();\\n\\t\\t}\\n\\t},\\n\\tstopImmediatePropagation: function() {\\n\\t\\tvar e = this.originalEvent;\\n\\n\\t\\tthis.isImmediatePropagationStopped = returnTrue;\\n\\n\\t\\tif ( e && !this.isSimulated ) {\\n\\t\\t\\te.stopImmediatePropagation();\\n\\t\\t}\\n\\n\\t\\tthis.stopPropagation();\\n\\t}\\n};\\n\\n// Includes all common event props including KeyEvent and MouseEvent specific props\\njQuery.each( {\\n\\taltKey: true,\\n\\tbubbles: true,\\n\\tcancelable: true,\\n\\tchangedTouches: true,\\n\\tctrlKey: true,\\n\\tdetail: true,\\n\\teventPhase: true,\\n\\tmetaKey: true,\\n\\tpageX: true,\\n\\tpageY: true,\\n\\tshiftKey: true,\\n\\tview: true,\\n\\t\"char\": true,\\n\\tcharCode: true,\\n\\tkey: true,\\n\\tkeyCode: true,\\n\\tbutton: true,\\n\\tbuttons: true,\\n\\tclientX: true,\\n\\tclientY: true,\\n\\toffsetX: true,\\n\\toffsetY: true,\\n\\tpointerId: true,\\n\\tpointerType: true,\\n\\tscreenX: true,\\n\\tscreenY: true,\\n\\ttargetTouches: true,\\n\\ttoElement: true,\\n\\ttouches: true,\\n\\n\\twhich: function( event ) {\\n\\t\\tvar button = event.button;\\n\\n\\t\\t// Add which for key events\\n\\t\\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\\n\\t\\t\\treturn event.charCode != null ? event.charCode : event.keyCode;\\n\\t\\t}\\n\\n\\t\\t// Add which for click: 1 === left; 2 === middle; 3 === right\\n\\t\\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\\n\\t\\t\\tif ( button & 1 ) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( button & 2 ) {\\n\\t\\t\\t\\treturn 3;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( button & 4 ) {\\n\\t\\t\\t\\treturn 2;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\treturn event.which;\\n\\t}\\n}, jQuery.event.addProp );\\n\\n// Create mouseenter/leave events using mouseover/out and event-time checks\\n// so that event delegation works in jQuery.\\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\\n//\\n// Support: Safari 7 only\\n// Safari sends mouseenter too often; see:\\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\\n// for the description of the bug (it existed in older Chrome versions as well).\\njQuery.each( {\\n\\tmouseenter: \"mouseover\",\\n\\tmouseleave: \"mouseout\",\\n\\tpointerenter: \"pointerover\",\\n\\tpointerleave: \"pointerout\"\\n}, function( orig, fix ) {\\n\\tjQuery.event.special[ orig ] = {\\n\\t\\tdelegateType: fix,\\n\\t\\tbindType: fix,\\n\\n\\t\\thandle: function( event ) {\\n\\t\\t\\tvar ret,\\n\\t\\t\\t\\ttarget = this,\\n\\t\\t\\t\\trelated = event.relatedTarget,\\n\\t\\t\\t\\thandleObj = event.handleObj;\\n\\n\\t\\t\\t// For mouseenter/leave call the handler if related is outside the target.\\n\\t\\t\\t// NB: No relatedTarget if the mouse left/entered the browser window\\n\\t\\t\\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\\n\\t\\t\\t\\tevent.type = handleObj.origType;\\n\\t\\t\\t\\tret = handleObj.handler.apply( this, arguments );\\n\\t\\t\\t\\tevent.type = fix;\\n\\t\\t\\t}\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\t};\\n} );\\n\\njQuery.fn.extend( {\\n\\n\\ton: function( types, selector, data, fn ) {\\n\\t\\treturn on( this, types, selector, data, fn );\\n\\t},\\n\\tone: function( types, selector, data, fn ) {\\n\\t\\treturn on( this, types, selector, data, fn, 1 );\\n\\t},\\n\\toff: function( types, selector, fn ) {\\n\\t\\tvar handleObj, type;\\n\\t\\tif ( types && types.preventDefault && types.handleObj ) {\\n\\n\\t\\t\\t// ( event )  dispatched jQuery.Event\\n\\t\\t\\thandleObj = types.handleObj;\\n\\t\\t\\tjQuery( types.delegateTarget ).off(\\n\\t\\t\\t\\thandleObj.namespace ?\\n\\t\\t\\t\\t\\thandleObj.origType + \".\" + handleObj.namespace :\\n\\t\\t\\t\\t\\thandleObj.origType,\\n\\t\\t\\t\\thandleObj.selector,\\n\\t\\t\\t\\thandleObj.handler\\n\\t\\t\\t);\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\tif ( typeof types === \"object\" ) {\\n\\n\\t\\t\\t// ( types-object [, selector] )\\n\\t\\t\\tfor ( type in types ) {\\n\\t\\t\\t\\tthis.off( type, selector, types[ type ] );\\n\\t\\t\\t}\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\tif ( selector === false || typeof selector === \"function\" ) {\\n\\n\\t\\t\\t// ( types [, fn] )\\n\\t\\t\\tfn = selector;\\n\\t\\t\\tselector = undefined;\\n\\t\\t}\\n\\t\\tif ( fn === false ) {\\n\\t\\t\\tfn = returnFalse;\\n\\t\\t}\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.event.remove( this, types, fn, selector );\\n\\t\\t} );\\n\\t}\\n} );\\n\\n\\nvar\\n\\n\\t/* eslint-disable max-len */\\n\\n\\t// See https://github.com/eslint/eslint/issues/3229\\n\\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\\\/\\\\0>\\\\x20\\\\t\\\\r\\\\n\\\\f]*)[^>]*)\\\\/>/gi,\\n\\n\\t/* eslint-enable */\\n\\n\\t// Support: IE <=10 - 11, Edge 12 - 13 only\\n\\t// In IE/Edge using regex groups here causes severe slowdowns.\\n\\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\\n\\trnoInnerhtml = /<script|<style|<link/i,\\n\\n\\t// checked=\"checked\" or checked\\n\\trchecked = /checked\\\\s*(?:[^=]|=\\\\s*.checked.)/i,\\n\\trcleanScript = /^\\\\s*<!(?:\\\\[CDATA\\\\[|--)|(?:\\\\]\\\\]|--)>\\\\s*$/g;\\n\\n// Prefer a tbody over its parent table for containing new rows\\nfunction manipulationTarget( elem, content ) {\\n\\tif ( nodeName( elem, \"table\" ) &&\\n\\t\\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\\n\\n\\t\\treturn jQuery( elem ).children( \"tbody\" )[ 0 ] || elem;\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\n// Replace/restore the type attribute of script elements for safe DOM manipulation\\nfunction disableScript( elem ) {\\n\\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\\n\\treturn elem;\\n}\\nfunction restoreScript( elem ) {\\n\\tif ( ( elem.type || \"\" ).slice( 0, 5 ) === \"true/\" ) {\\n\\t\\telem.type = elem.type.slice( 5 );\\n\\t} else {\\n\\t\\telem.removeAttribute( \"type\" );\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\nfunction cloneCopyEvent( src, dest ) {\\n\\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\\n\\n\\tif ( dest.nodeType !== 1 ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// 1. Copy private data: events, handlers, etc.\\n\\tif ( dataPriv.hasData( src ) ) {\\n\\t\\tpdataOld = dataPriv.access( src );\\n\\t\\tpdataCur = dataPriv.set( dest, pdataOld );\\n\\t\\tevents = pdataOld.events;\\n\\n\\t\\tif ( events ) {\\n\\t\\t\\tdelete pdataCur.handle;\\n\\t\\t\\tpdataCur.events = {};\\n\\n\\t\\t\\tfor ( type in events ) {\\n\\t\\t\\t\\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\\n\\t\\t\\t\\t\\tjQuery.event.add( dest, type, events[ type ][ i ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// 2. Copy user data\\n\\tif ( dataUser.hasData( src ) ) {\\n\\t\\tudataOld = dataUser.access( src );\\n\\t\\tudataCur = jQuery.extend( {}, udataOld );\\n\\n\\t\\tdataUser.set( dest, udataCur );\\n\\t}\\n}\\n\\n// Fix IE bugs, see support tests\\nfunction fixInput( src, dest ) {\\n\\tvar nodeName = dest.nodeName.toLowerCase();\\n\\n\\t// Fails to persist the checked state of a cloned checkbox or radio button.\\n\\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\\n\\t\\tdest.checked = src.checked;\\n\\n\\t// Fails to return the selected option to the default selected state when cloning options\\n\\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\\n\\t\\tdest.defaultValue = src.defaultValue;\\n\\t}\\n}\\n\\nfunction domManip( collection, args, callback, ignored ) {\\n\\n\\t// Flatten any nested arrays\\n\\targs = concat.apply( [], args );\\n\\n\\tvar fragment, first, scripts, hasScripts, node, doc,\\n\\t\\ti = 0,\\n\\t\\tl = collection.length,\\n\\t\\tiNoClone = l - 1,\\n\\t\\tvalue = args[ 0 ],\\n\\t\\tvalueIsFunction = isFunction( value );\\n\\n\\t// We can\\'t cloneNode fragments that contain checked, in WebKit\\n\\tif ( valueIsFunction ||\\n\\t\\t\\t( l > 1 && typeof value === \"string\" &&\\n\\t\\t\\t\\t!support.checkClone && rchecked.test( value ) ) ) {\\n\\t\\treturn collection.each( function( index ) {\\n\\t\\t\\tvar self = collection.eq( index );\\n\\t\\t\\tif ( valueIsFunction ) {\\n\\t\\t\\t\\targs[ 0 ] = value.call( this, index, self.html() );\\n\\t\\t\\t}\\n\\t\\t\\tdomManip( self, args, callback, ignored );\\n\\t\\t} );\\n\\t}\\n\\n\\tif ( l ) {\\n\\t\\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\\n\\t\\tfirst = fragment.firstChild;\\n\\n\\t\\tif ( fragment.childNodes.length === 1 ) {\\n\\t\\t\\tfragment = first;\\n\\t\\t}\\n\\n\\t\\t// Require either new content or an interest in ignored elements to invoke the callback\\n\\t\\tif ( first || ignored ) {\\n\\t\\t\\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\\n\\t\\t\\thasScripts = scripts.length;\\n\\n\\t\\t\\t// Use the original fragment for the last item\\n\\t\\t\\t// instead of the first because it can end up\\n\\t\\t\\t// being emptied incorrectly in certain situations (#8070).\\n\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\tnode = fragment;\\n\\n\\t\\t\\t\\tif ( i !== iNoClone ) {\\n\\t\\t\\t\\t\\tnode = jQuery.clone( node, true, true );\\n\\n\\t\\t\\t\\t\\t// Keep references to cloned scripts for later restoration\\n\\t\\t\\t\\t\\tif ( hasScripts ) {\\n\\n\\t\\t\\t\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t\\t\\t\\t// push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\t\\t\\t\\tjQuery.merge( scripts, getAll( node, \"script\" ) );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcallback.call( collection[ i ], node, i );\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hasScripts ) {\\n\\t\\t\\t\\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\\n\\n\\t\\t\\t\\t// Reenable scripts\\n\\t\\t\\t\\tjQuery.map( scripts, restoreScript );\\n\\n\\t\\t\\t\\t// Evaluate executable scripts on first document insertion\\n\\t\\t\\t\\tfor ( i = 0; i < hasScripts; i++ ) {\\n\\t\\t\\t\\t\\tnode = scripts[ i ];\\n\\t\\t\\t\\t\\tif ( rscriptType.test( node.type || \"\" ) &&\\n\\t\\t\\t\\t\\t\\t!dataPriv.access( node, \"globalEval\" ) &&\\n\\t\\t\\t\\t\\t\\tjQuery.contains( doc, node ) ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( node.src && ( node.type || \"\" ).toLowerCase()  !== \"module\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Optional AJAX dependency, but won\\'t run scripts if not present\\n\\t\\t\\t\\t\\t\\t\\tif ( jQuery._evalUrl ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery._evalUrl( node.src );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc, node );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn collection;\\n}\\n\\nfunction remove( elem, selector, keepData ) {\\n\\tvar node,\\n\\t\\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\\n\\t\\ti = 0;\\n\\n\\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\\n\\t\\tif ( !keepData && node.nodeType === 1 ) {\\n\\t\\t\\tjQuery.cleanData( getAll( node ) );\\n\\t\\t}\\n\\n\\t\\tif ( node.parentNode ) {\\n\\t\\t\\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\\n\\t\\t\\t\\tsetGlobalEval( getAll( node, \"script\" ) );\\n\\t\\t\\t}\\n\\t\\t\\tnode.parentNode.removeChild( node );\\n\\t\\t}\\n\\t}\\n\\n\\treturn elem;\\n}\\n\\njQuery.extend( {\\n\\thtmlPrefilter: function( html ) {\\n\\t\\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\\n\\t},\\n\\n\\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\\n\\t\\tvar i, l, srcElements, destElements,\\n\\t\\t\\tclone = elem.cloneNode( true ),\\n\\t\\t\\tinPage = jQuery.contains( elem.ownerDocument, elem );\\n\\n\\t\\t// Fix IE cloning issues\\n\\t\\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\\n\\t\\t\\t\\t!jQuery.isXMLDoc( elem ) ) {\\n\\n\\t\\t\\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\\n\\t\\t\\tdestElements = getAll( clone );\\n\\t\\t\\tsrcElements = getAll( elem );\\n\\n\\t\\t\\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\\n\\t\\t\\t\\tfixInput( srcElements[ i ], destElements[ i ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Copy the events from the original to the clone\\n\\t\\tif ( dataAndEvents ) {\\n\\t\\t\\tif ( deepDataAndEvents ) {\\n\\t\\t\\t\\tsrcElements = srcElements || getAll( elem );\\n\\t\\t\\t\\tdestElements = destElements || getAll( clone );\\n\\n\\t\\t\\t\\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\\n\\t\\t\\t\\t\\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcloneCopyEvent( elem, clone );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Preserve script evaluation history\\n\\t\\tdestElements = getAll( clone, \"script\" );\\n\\t\\tif ( destElements.length > 0 ) {\\n\\t\\t\\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\\n\\t\\t}\\n\\n\\t\\t// Return the cloned set\\n\\t\\treturn clone;\\n\\t},\\n\\n\\tcleanData: function( elems ) {\\n\\t\\tvar data, elem, type,\\n\\t\\t\\tspecial = jQuery.event.special,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\\n\\t\\t\\tif ( acceptData( elem ) ) {\\n\\t\\t\\t\\tif ( ( data = elem[ dataPriv.expando ] ) ) {\\n\\t\\t\\t\\t\\tif ( data.events ) {\\n\\t\\t\\t\\t\\t\\tfor ( type in data.events ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( special[ type ] ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.event.remove( elem, type );\\n\\n\\t\\t\\t\\t\\t\\t\\t// This is a shortcut to avoid jQuery.event.remove\\'s overhead\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tjQuery.removeEvent( elem, type, data.handle );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Support: Chrome <=35 - 45+\\n\\t\\t\\t\\t\\t// Assign undefined instead of using delete, see Data#remove\\n\\t\\t\\t\\t\\telem[ dataPriv.expando ] = undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( elem[ dataUser.expando ] ) {\\n\\n\\t\\t\\t\\t\\t// Support: Chrome <=35 - 45+\\n\\t\\t\\t\\t\\t// Assign undefined instead of using delete, see Data#remove\\n\\t\\t\\t\\t\\telem[ dataUser.expando ] = undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tdetach: function( selector ) {\\n\\t\\treturn remove( this, selector, true );\\n\\t},\\n\\n\\tremove: function( selector ) {\\n\\t\\treturn remove( this, selector );\\n\\t},\\n\\n\\ttext: function( value ) {\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\treturn value === undefined ?\\n\\t\\t\\t\\tjQuery.text( this ) :\\n\\t\\t\\t\\tthis.empty().each( function() {\\n\\t\\t\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\t\\t\\tthis.textContent = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} );\\n\\t\\t}, null, value, arguments.length );\\n\\t},\\n\\n\\tappend: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\tvar target = manipulationTarget( this, elem );\\n\\t\\t\\t\\ttarget.appendChild( elem );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tprepend: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\\n\\t\\t\\t\\tvar target = manipulationTarget( this, elem );\\n\\t\\t\\t\\ttarget.insertBefore( elem, target.firstChild );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tbefore: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.parentNode ) {\\n\\t\\t\\t\\tthis.parentNode.insertBefore( elem, this );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tafter: function() {\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tif ( this.parentNode ) {\\n\\t\\t\\t\\tthis.parentNode.insertBefore( elem, this.nextSibling );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\tempty: function() {\\n\\t\\tvar elem,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\\n\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t// Prevent memory leaks\\n\\t\\t\\t\\tjQuery.cleanData( getAll( elem, false ) );\\n\\n\\t\\t\\t\\t// Remove any remaining nodes\\n\\t\\t\\t\\telem.textContent = \"\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\tclone: function( dataAndEvents, deepDataAndEvents ) {\\n\\t\\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\\n\\t\\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\\n\\n\\t\\treturn this.map( function() {\\n\\t\\t\\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\\n\\t\\t} );\\n\\t},\\n\\n\\thtml: function( value ) {\\n\\t\\treturn access( this, function( value ) {\\n\\t\\t\\tvar elem = this[ 0 ] || {},\\n\\t\\t\\t\\ti = 0,\\n\\t\\t\\t\\tl = this.length;\\n\\n\\t\\t\\tif ( value === undefined && elem.nodeType === 1 ) {\\n\\t\\t\\t\\treturn elem.innerHTML;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// See if we can take a shortcut and just use innerHTML\\n\\t\\t\\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\\n\\t\\t\\t\\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\\n\\n\\t\\t\\t\\tvalue = jQuery.htmlPrefilter( value );\\n\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tfor ( ; i < l; i++ ) {\\n\\t\\t\\t\\t\\t\\telem = this[ i ] || {};\\n\\n\\t\\t\\t\\t\\t\\t// Remove element nodes and prevent memory leaks\\n\\t\\t\\t\\t\\t\\tif ( elem.nodeType === 1 ) {\\n\\t\\t\\t\\t\\t\\t\\tjQuery.cleanData( getAll( elem, false ) );\\n\\t\\t\\t\\t\\t\\t\\telem.innerHTML = value;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telem = 0;\\n\\n\\t\\t\\t\\t// If using innerHTML throws an exception, use the fallback method\\n\\t\\t\\t\\t} catch ( e ) {}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( elem ) {\\n\\t\\t\\t\\tthis.empty().append( value );\\n\\t\\t\\t}\\n\\t\\t}, null, value, arguments.length );\\n\\t},\\n\\n\\treplaceWith: function() {\\n\\t\\tvar ignored = [];\\n\\n\\t\\t// Make the changes, replacing each non-ignored context element with the new content\\n\\t\\treturn domManip( this, arguments, function( elem ) {\\n\\t\\t\\tvar parent = this.parentNode;\\n\\n\\t\\t\\tif ( jQuery.inArray( this, ignored ) < 0 ) {\\n\\t\\t\\t\\tjQuery.cleanData( getAll( this ) );\\n\\t\\t\\t\\tif ( parent ) {\\n\\t\\t\\t\\t\\tparent.replaceChild( elem, this );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t// Force callback invocation\\n\\t\\t}, ignored );\\n\\t}\\n} );\\n\\njQuery.each( {\\n\\tappendTo: \"append\",\\n\\tprependTo: \"prepend\",\\n\\tinsertBefore: \"before\",\\n\\tinsertAfter: \"after\",\\n\\treplaceAll: \"replaceWith\"\\n}, function( name, original ) {\\n\\tjQuery.fn[ name ] = function( selector ) {\\n\\t\\tvar elems,\\n\\t\\t\\tret = [],\\n\\t\\t\\tinsert = jQuery( selector ),\\n\\t\\t\\tlast = insert.length - 1,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tfor ( ; i <= last; i++ ) {\\n\\t\\t\\telems = i === last ? this : this.clone( true );\\n\\t\\t\\tjQuery( insert[ i ] )[ original ]( elems );\\n\\n\\t\\t\\t// Support: Android <=4.0 only, PhantomJS 1 only\\n\\t\\t\\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\\n\\t\\t\\tpush.apply( ret, elems.get() );\\n\\t\\t}\\n\\n\\t\\treturn this.pushStack( ret );\\n\\t};\\n} );\\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\\n\\nvar getStyles = function( elem ) {\\n\\n\\t\\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\\n\\t\\t// IE throws on elements created in popups\\n\\t\\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\\n\\t\\tvar view = elem.ownerDocument.defaultView;\\n\\n\\t\\tif ( !view || !view.opener ) {\\n\\t\\t\\tview = window;\\n\\t\\t}\\n\\n\\t\\treturn view.getComputedStyle( elem );\\n\\t};\\n\\nvar rboxStyle = new RegExp( cssExpand.join( \"|\" ), \"i\" );\\n\\n\\n\\n( function() {\\n\\n\\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\\n\\t// so they\\'re executed at the same time to save the second computation.\\n\\tfunction computeStyleTests() {\\n\\n\\t\\t// This is a singleton, we need to execute it only once\\n\\t\\tif ( !div ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tcontainer.style.cssText = \"position:absolute;left:-11111px;width:60px;\" +\\n\\t\\t\\t\"margin-top:1px;padding:0;border:0\";\\n\\t\\tdiv.style.cssText =\\n\\t\\t\\t\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" +\\n\\t\\t\\t\"margin:auto;border:1px;padding:1px;\" +\\n\\t\\t\\t\"width:60%;top:1%\";\\n\\t\\tdocumentElement.appendChild( container ).appendChild( div );\\n\\n\\t\\tvar divStyle = window.getComputedStyle( div );\\n\\t\\tpixelPositionVal = divStyle.top !== \"1%\";\\n\\n\\t\\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\\n\\t\\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\\n\\n\\t\\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\\n\\t\\t// Some styles come back with percentage values, even though they shouldn\\'t\\n\\t\\tdiv.style.right = \"60%\";\\n\\t\\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\\n\\n\\t\\t// Support: IE 9 - 11 only\\n\\t\\t// Detect misreporting of content dimensions for box-sizing:border-box elements\\n\\t\\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\\n\\n\\t\\t// Support: IE 9 only\\n\\t\\t// Detect overflow:scroll screwiness (gh-3699)\\n\\t\\tdiv.style.position = \"absolute\";\\n\\t\\tscrollboxSizeVal = div.offsetWidth === 36 || \"absolute\";\\n\\n\\t\\tdocumentElement.removeChild( container );\\n\\n\\t\\t// Nullify the div so it wouldn\\'t be stored in the memory and\\n\\t\\t// it will also be a sign that checks already performed\\n\\t\\tdiv = null;\\n\\t}\\n\\n\\tfunction roundPixelMeasures( measure ) {\\n\\t\\treturn Math.round( parseFloat( measure ) );\\n\\t}\\n\\n\\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\\n\\t\\treliableMarginLeftVal,\\n\\t\\tcontainer = document.createElement( \"div\" ),\\n\\t\\tdiv = document.createElement( \"div\" );\\n\\n\\t// Finish early in limited (non-browser) environments\\n\\tif ( !div.style ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// Support: IE <=9 - 11 only\\n\\t// Style of cloned element affects source element cloned (#8908)\\n\\tdiv.style.backgroundClip = \"content-box\";\\n\\tdiv.cloneNode( true ).style.backgroundClip = \"\";\\n\\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\\n\\n\\tjQuery.extend( support, {\\n\\t\\tboxSizingReliable: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn boxSizingReliableVal;\\n\\t\\t},\\n\\t\\tpixelBoxStyles: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn pixelBoxStylesVal;\\n\\t\\t},\\n\\t\\tpixelPosition: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn pixelPositionVal;\\n\\t\\t},\\n\\t\\treliableMarginLeft: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn reliableMarginLeftVal;\\n\\t\\t},\\n\\t\\tscrollboxSize: function() {\\n\\t\\t\\tcomputeStyleTests();\\n\\t\\t\\treturn scrollboxSizeVal;\\n\\t\\t}\\n\\t} );\\n} )();\\n\\n\\nfunction curCSS( elem, name, computed ) {\\n\\tvar width, minWidth, maxWidth, ret,\\n\\n\\t\\t// Support: Firefox 51+\\n\\t\\t// Retrieving style before computed somehow\\n\\t\\t// fixes an issue with getting wrong values\\n\\t\\t// on detached elements\\n\\t\\tstyle = elem.style;\\n\\n\\tcomputed = computed || getStyles( elem );\\n\\n\\t// getPropertyValue is needed for:\\n\\t//   .css(\\'filter\\') (IE 9 only, #12537)\\n\\t//   .css(\\'--customProperty) (#3144)\\n\\tif ( computed ) {\\n\\t\\tret = computed.getPropertyValue( name ) || computed[ name ];\\n\\n\\t\\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\\n\\t\\t\\tret = jQuery.style( elem, name );\\n\\t\\t}\\n\\n\\t\\t// A tribute to the \"awesome hack by Dean Edwards\"\\n\\t\\t// Android Browser returns percentage for some values,\\n\\t\\t// but width seems to be reliably pixels.\\n\\t\\t// This is against the CSSOM draft spec:\\n\\t\\t// https://drafts.csswg.org/cssom/#resolved-values\\n\\t\\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\\n\\n\\t\\t\\t// Remember the original values\\n\\t\\t\\twidth = style.width;\\n\\t\\t\\tminWidth = style.minWidth;\\n\\t\\t\\tmaxWidth = style.maxWidth;\\n\\n\\t\\t\\t// Put in the new values to get a computed value out\\n\\t\\t\\tstyle.minWidth = style.maxWidth = style.width = ret;\\n\\t\\t\\tret = computed.width;\\n\\n\\t\\t\\t// Revert the changed values\\n\\t\\t\\tstyle.width = width;\\n\\t\\t\\tstyle.minWidth = minWidth;\\n\\t\\t\\tstyle.maxWidth = maxWidth;\\n\\t\\t}\\n\\t}\\n\\n\\treturn ret !== undefined ?\\n\\n\\t\\t// Support: IE <=9 - 11 only\\n\\t\\t// IE returns zIndex value as an integer.\\n\\t\\tret + \"\" :\\n\\t\\tret;\\n}\\n\\n\\nfunction addGetHookIf( conditionFn, hookFn ) {\\n\\n\\t// Define the hook, we\\'ll check on the first run if it\\'s really needed.\\n\\treturn {\\n\\t\\tget: function() {\\n\\t\\t\\tif ( conditionFn() ) {\\n\\n\\t\\t\\t\\t// Hook not needed (or it\\'s not possible to use it due\\n\\t\\t\\t\\t// to missing dependency), remove it.\\n\\t\\t\\t\\tdelete this.get;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Hook needed; redefine it so that the support test is not executed again.\\n\\t\\t\\treturn ( this.get = hookFn ).apply( this, arguments );\\n\\t\\t}\\n\\t};\\n}\\n\\n\\nvar\\n\\n\\t// Swappable if display is none or starts with table\\n\\t// except \"table\", \"table-cell\", or \"table-caption\"\\n\\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\\n\\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\\n\\trcustomProp = /^--/,\\n\\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\\n\\tcssNormalTransform = {\\n\\t\\tletterSpacing: \"0\",\\n\\t\\tfontWeight: \"400\"\\n\\t},\\n\\n\\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\\n\\temptyStyle = document.createElement( \"div\" ).style;\\n\\n// Return a css property mapped to a potentially vendor prefixed property\\nfunction vendorPropName( name ) {\\n\\n\\t// Shortcut for names that are not vendor prefixed\\n\\tif ( name in emptyStyle ) {\\n\\t\\treturn name;\\n\\t}\\n\\n\\t// Check for vendor prefixed names\\n\\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\\n\\t\\ti = cssPrefixes.length;\\n\\n\\twhile ( i-- ) {\\n\\t\\tname = cssPrefixes[ i ] + capName;\\n\\t\\tif ( name in emptyStyle ) {\\n\\t\\t\\treturn name;\\n\\t\\t}\\n\\t}\\n}\\n\\n// Return a property mapped along what jQuery.cssProps suggests or to\\n// a vendor prefixed property.\\nfunction finalPropName( name ) {\\n\\tvar ret = jQuery.cssProps[ name ];\\n\\tif ( !ret ) {\\n\\t\\tret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;\\n\\t}\\n\\treturn ret;\\n}\\n\\nfunction setPositiveNumber( elem, value, subtract ) {\\n\\n\\t// Any relative (+/-) values have already been\\n\\t// normalized at this point\\n\\tvar matches = rcssNum.exec( value );\\n\\treturn matches ?\\n\\n\\t\\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\\n\\t\\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\\n\\t\\tvalue;\\n}\\n\\nfunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\\n\\tvar i = dimension === \"width\" ? 1 : 0,\\n\\t\\textra = 0,\\n\\t\\tdelta = 0;\\n\\n\\t// Adjustment may not be necessary\\n\\tif ( box === ( isBorderBox ? \"border\" : \"content\" ) ) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tfor ( ; i < 4; i += 2 ) {\\n\\n\\t\\t// Both box models exclude margin\\n\\t\\tif ( box === \"margin\" ) {\\n\\t\\t\\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\\n\\t\\t}\\n\\n\\t\\t// If we get here with a content-box, we\\'re seeking \"padding\" or \"border\" or \"margin\"\\n\\t\\tif ( !isBorderBox ) {\\n\\n\\t\\t\\t// Add padding\\n\\t\\t\\tdelta += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\\n\\n\\t\\t\\t// For \"border\" or \"margin\", add border\\n\\t\\t\\tif ( box !== \"padding\" ) {\\n\\t\\t\\t\\tdelta += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\\n\\n\\t\\t\\t// But still keep track of it otherwise\\n\\t\\t\\t} else {\\n\\t\\t\\t\\textra += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\\n\\t\\t\\t}\\n\\n\\t\\t// If we get here with a border-box (content + padding + border), we\\'re seeking \"content\" or\\n\\t\\t// \"padding\" or \"margin\"\\n\\t\\t} else {\\n\\n\\t\\t\\t// For \"content\", subtract padding\\n\\t\\t\\tif ( box === \"content\" ) {\\n\\t\\t\\t\\tdelta -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// For \"content\" or \"padding\", subtract border\\n\\t\\t\\tif ( box !== \"margin\" ) {\\n\\t\\t\\t\\tdelta -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Account for positive content-box scroll gutter when requested by providing computedVal\\n\\tif ( !isBorderBox && computedVal >= 0 ) {\\n\\n\\t\\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\\n\\t\\t// Assuming integer scroll gutter, subtract the rest and round down\\n\\t\\tdelta += Math.max( 0, Math.ceil(\\n\\t\\t\\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\\n\\t\\t\\tcomputedVal -\\n\\t\\t\\tdelta -\\n\\t\\t\\textra -\\n\\t\\t\\t0.5\\n\\t\\t) );\\n\\t}\\n\\n\\treturn delta;\\n}\\n\\nfunction getWidthOrHeight( elem, dimension, extra ) {\\n\\n\\t// Start with computed style\\n\\tvar styles = getStyles( elem ),\\n\\t\\tval = curCSS( elem, dimension, styles ),\\n\\t\\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\\n\\t\\tvalueIsBorderBox = isBorderBox;\\n\\n\\t// Support: Firefox <=54\\n\\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\\n\\tif ( rnumnonpx.test( val ) ) {\\n\\t\\tif ( !extra ) {\\n\\t\\t\\treturn val;\\n\\t\\t}\\n\\t\\tval = \"auto\";\\n\\t}\\n\\n\\t// Check for style in case a browser which returns unreliable values\\n\\t// for getComputedStyle silently falls back to the reliable elem.style\\n\\tvalueIsBorderBox = valueIsBorderBox &&\\n\\t\\t( support.boxSizingReliable() || val === elem.style[ dimension ] );\\n\\n\\t// Fall back to offsetWidth/offsetHeight when value is \"auto\"\\n\\t// This happens for inline elements with no explicit setting (gh-3571)\\n\\t// Support: Android <=4.1 - 4.3 only\\n\\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\\n\\tif ( val === \"auto\" ||\\n\\t\\t!parseFloat( val ) && jQuery.css( elem, \"display\", false, styles ) === \"inline\" ) {\\n\\n\\t\\tval = elem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];\\n\\n\\t\\t// offsetWidth/offsetHeight provide border-box values\\n\\t\\tvalueIsBorderBox = true;\\n\\t}\\n\\n\\t// Normalize \"\" and auto\\n\\tval = parseFloat( val ) || 0;\\n\\n\\t// Adjust for the element\\'s box model\\n\\treturn ( val +\\n\\t\\tboxModelAdjustment(\\n\\t\\t\\telem,\\n\\t\\t\\tdimension,\\n\\t\\t\\textra || ( isBorderBox ? \"border\" : \"content\" ),\\n\\t\\t\\tvalueIsBorderBox,\\n\\t\\t\\tstyles,\\n\\n\\t\\t\\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\\n\\t\\t\\tval\\n\\t\\t)\\n\\t) + \"px\";\\n}\\n\\njQuery.extend( {\\n\\n\\t// Add in style property hooks for overriding the default\\n\\t// behavior of getting and setting a style property\\n\\tcssHooks: {\\n\\t\\topacity: {\\n\\t\\t\\tget: function( elem, computed ) {\\n\\t\\t\\t\\tif ( computed ) {\\n\\n\\t\\t\\t\\t\\t// We should always get a number back from opacity\\n\\t\\t\\t\\t\\tvar ret = curCSS( elem, \"opacity\" );\\n\\t\\t\\t\\t\\treturn ret === \"\" ? \"1\" : ret;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\t// Don\\'t automatically add \"px\" to these possibly-unitless properties\\n\\tcssNumber: {\\n\\t\\t\"animationIterationCount\": true,\\n\\t\\t\"columnCount\": true,\\n\\t\\t\"fillOpacity\": true,\\n\\t\\t\"flexGrow\": true,\\n\\t\\t\"flexShrink\": true,\\n\\t\\t\"fontWeight\": true,\\n\\t\\t\"lineHeight\": true,\\n\\t\\t\"opacity\": true,\\n\\t\\t\"order\": true,\\n\\t\\t\"orphans\": true,\\n\\t\\t\"widows\": true,\\n\\t\\t\"zIndex\": true,\\n\\t\\t\"zoom\": true\\n\\t},\\n\\n\\t// Add in properties whose names you wish to fix before\\n\\t// setting or getting the value\\n\\tcssProps: {},\\n\\n\\t// Get and set the style property on a DOM Node\\n\\tstyle: function( elem, name, value, extra ) {\\n\\n\\t\\t// Don\\'t set styles on text and comment nodes\\n\\t\\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Make sure that we\\'re working with the right name\\n\\t\\tvar ret, type, hooks,\\n\\t\\t\\torigName = camelCase( name ),\\n\\t\\t\\tisCustomProp = rcustomProp.test( name ),\\n\\t\\t\\tstyle = elem.style;\\n\\n\\t\\t// Make sure that we\\'re working with the right name. We don\\'t\\n\\t\\t// want to query the value if it is a CSS custom property\\n\\t\\t// since they are user-defined.\\n\\t\\tif ( !isCustomProp ) {\\n\\t\\t\\tname = finalPropName( origName );\\n\\t\\t}\\n\\n\\t\\t// Gets hook for the prefixed version, then unprefixed version\\n\\t\\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\\n\\n\\t\\t// Check if we\\'re setting a value\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\ttype = typeof value;\\n\\n\\t\\t\\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\\n\\t\\t\\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\\n\\t\\t\\t\\tvalue = adjustCSS( elem, name, ret );\\n\\n\\t\\t\\t\\t// Fixes bug #9237\\n\\t\\t\\t\\ttype = \"number\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Make sure that null and NaN values aren\\'t set (#7116)\\n\\t\\t\\tif ( value == null || value !== value ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If a number was passed in, add the unit (except for certain CSS properties)\\n\\t\\t\\tif ( type === \"number\" ) {\\n\\t\\t\\t\\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// background-* props affect original clone\\'s values\\n\\t\\t\\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\\n\\t\\t\\t\\tstyle[ name ] = \"inherit\";\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If a hook was provided, use that value, otherwise just set the specified value\\n\\t\\t\\tif ( !hooks || !( \"set\" in hooks ) ||\\n\\t\\t\\t\\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\\n\\n\\t\\t\\t\\tif ( isCustomProp ) {\\n\\t\\t\\t\\t\\tstyle.setProperty( name, value );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstyle[ name ] = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// If a hook was provided get the non-computed value from there\\n\\t\\t\\tif ( hooks && \"get\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\\n\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Otherwise just get the value from the style object\\n\\t\\t\\treturn style[ name ];\\n\\t\\t}\\n\\t},\\n\\n\\tcss: function( elem, name, extra, styles ) {\\n\\t\\tvar val, num, hooks,\\n\\t\\t\\torigName = camelCase( name ),\\n\\t\\t\\tisCustomProp = rcustomProp.test( name );\\n\\n\\t\\t// Make sure that we\\'re working with the right name. We don\\'t\\n\\t\\t// want to modify the value if it is a CSS custom property\\n\\t\\t// since they are user-defined.\\n\\t\\tif ( !isCustomProp ) {\\n\\t\\t\\tname = finalPropName( origName );\\n\\t\\t}\\n\\n\\t\\t// Try prefixed name followed by the unprefixed name\\n\\t\\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\\n\\n\\t\\t// If a hook was provided get the computed value from there\\n\\t\\tif ( hooks && \"get\" in hooks ) {\\n\\t\\t\\tval = hooks.get( elem, true, extra );\\n\\t\\t}\\n\\n\\t\\t// Otherwise, if a way to get the computed value exists, use that\\n\\t\\tif ( val === undefined ) {\\n\\t\\t\\tval = curCSS( elem, name, styles );\\n\\t\\t}\\n\\n\\t\\t// Convert \"normal\" to computed value\\n\\t\\tif ( val === \"normal\" && name in cssNormalTransform ) {\\n\\t\\t\\tval = cssNormalTransform[ name ];\\n\\t\\t}\\n\\n\\t\\t// Make numeric if forced or a qualifier was provided and val looks numeric\\n\\t\\tif ( extra === \"\" || extra ) {\\n\\t\\t\\tnum = parseFloat( val );\\n\\t\\t\\treturn extra === true || isFinite( num ) ? num || 0 : val;\\n\\t\\t}\\n\\n\\t\\treturn val;\\n\\t}\\n} );\\n\\njQuery.each( [ \"height\", \"width\" ], function( i, dimension ) {\\n\\tjQuery.cssHooks[ dimension ] = {\\n\\t\\tget: function( elem, computed, extra ) {\\n\\t\\t\\tif ( computed ) {\\n\\n\\t\\t\\t\\t// Certain elements can have dimension info if we invisibly show them\\n\\t\\t\\t\\t// but it must have a current display style that would benefit\\n\\t\\t\\t\\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\\n\\n\\t\\t\\t\\t\\t// Support: Safari 8+\\n\\t\\t\\t\\t\\t// Table columns in Safari have non-zero offsetWidth & zero\\n\\t\\t\\t\\t\\t// getBoundingClientRect().width unless display is changed.\\n\\t\\t\\t\\t\\t// Support: IE <=11 only\\n\\t\\t\\t\\t\\t// Running getBoundingClientRect on a disconnected node\\n\\t\\t\\t\\t\\t// in IE throws an error.\\n\\t\\t\\t\\t\\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\\n\\t\\t\\t\\t\\t\\tswap( elem, cssShow, function() {\\n\\t\\t\\t\\t\\t\\t\\treturn getWidthOrHeight( elem, dimension, extra );\\n\\t\\t\\t\\t\\t\\t} ) :\\n\\t\\t\\t\\t\\t\\tgetWidthOrHeight( elem, dimension, extra );\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tset: function( elem, value, extra ) {\\n\\t\\t\\tvar matches,\\n\\t\\t\\t\\tstyles = getStyles( elem ),\\n\\t\\t\\t\\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\\n\\t\\t\\t\\tsubtract = extra && boxModelAdjustment(\\n\\t\\t\\t\\t\\telem,\\n\\t\\t\\t\\t\\tdimension,\\n\\t\\t\\t\\t\\textra,\\n\\t\\t\\t\\t\\tisBorderBox,\\n\\t\\t\\t\\t\\tstyles\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t// Account for unreliable border-box dimensions by comparing offset* to computed and\\n\\t\\t\\t// faking a content-box to get border and padding (gh-3699)\\n\\t\\t\\tif ( isBorderBox && support.scrollboxSize() === styles.position ) {\\n\\t\\t\\t\\tsubtract -= Math.ceil(\\n\\t\\t\\t\\t\\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\\n\\t\\t\\t\\t\\tparseFloat( styles[ dimension ] ) -\\n\\t\\t\\t\\t\\tboxModelAdjustment( elem, dimension, \"border\", false, styles ) -\\n\\t\\t\\t\\t\\t0.5\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Convert to pixels if value adjustment is needed\\n\\t\\t\\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\\n\\t\\t\\t\\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\\n\\n\\t\\t\\t\\telem.style[ dimension ] = value;\\n\\t\\t\\t\\tvalue = jQuery.css( elem, dimension );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn setPositiveNumber( elem, value, subtract );\\n\\t\\t}\\n\\t};\\n} );\\n\\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\\n\\tfunction( elem, computed ) {\\n\\t\\tif ( computed ) {\\n\\t\\t\\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\\n\\t\\t\\t\\telem.getBoundingClientRect().left -\\n\\t\\t\\t\\t\\tswap( elem, { marginLeft: 0 }, function() {\\n\\t\\t\\t\\t\\t\\treturn elem.getBoundingClientRect().left;\\n\\t\\t\\t\\t\\t} )\\n\\t\\t\\t\\t) + \"px\";\\n\\t\\t}\\n\\t}\\n);\\n\\n// These hooks are used by animate to expand properties\\njQuery.each( {\\n\\tmargin: \"\",\\n\\tpadding: \"\",\\n\\tborder: \"Width\"\\n}, function( prefix, suffix ) {\\n\\tjQuery.cssHooks[ prefix + suffix ] = {\\n\\t\\texpand: function( value ) {\\n\\t\\t\\tvar i = 0,\\n\\t\\t\\t\\texpanded = {},\\n\\n\\t\\t\\t\\t// Assumes a single number if not a string\\n\\t\\t\\t\\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\\n\\n\\t\\t\\tfor ( ; i < 4; i++ ) {\\n\\t\\t\\t\\texpanded[ prefix + cssExpand[ i ] + suffix ] =\\n\\t\\t\\t\\t\\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn expanded;\\n\\t\\t}\\n\\t};\\n\\n\\tif ( prefix !== \"margin\" ) {\\n\\t\\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\\n\\t}\\n} );\\n\\njQuery.fn.extend( {\\n\\tcss: function( name, value ) {\\n\\t\\treturn access( this, function( elem, name, value ) {\\n\\t\\t\\tvar styles, len,\\n\\t\\t\\t\\tmap = {},\\n\\t\\t\\t\\ti = 0;\\n\\n\\t\\t\\tif ( Array.isArray( name ) ) {\\n\\t\\t\\t\\tstyles = getStyles( elem );\\n\\t\\t\\t\\tlen = name.length;\\n\\n\\t\\t\\t\\tfor ( ; i < len; i++ ) {\\n\\t\\t\\t\\t\\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn map;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn value !== undefined ?\\n\\t\\t\\t\\tjQuery.style( elem, name, value ) :\\n\\t\\t\\t\\tjQuery.css( elem, name );\\n\\t\\t}, name, value, arguments.length > 1 );\\n\\t}\\n} );\\n\\n\\nfunction Tween( elem, options, prop, end, easing ) {\\n\\treturn new Tween.prototype.init( elem, options, prop, end, easing );\\n}\\njQuery.Tween = Tween;\\n\\nTween.prototype = {\\n\\tconstructor: Tween,\\n\\tinit: function( elem, options, prop, end, easing, unit ) {\\n\\t\\tthis.elem = elem;\\n\\t\\tthis.prop = prop;\\n\\t\\tthis.easing = easing || jQuery.easing._default;\\n\\t\\tthis.options = options;\\n\\t\\tthis.start = this.now = this.cur();\\n\\t\\tthis.end = end;\\n\\t\\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\\n\\t},\\n\\tcur: function() {\\n\\t\\tvar hooks = Tween.propHooks[ this.prop ];\\n\\n\\t\\treturn hooks && hooks.get ?\\n\\t\\t\\thooks.get( this ) :\\n\\t\\t\\tTween.propHooks._default.get( this );\\n\\t},\\n\\trun: function( percent ) {\\n\\t\\tvar eased,\\n\\t\\t\\thooks = Tween.propHooks[ this.prop ];\\n\\n\\t\\tif ( this.options.duration ) {\\n\\t\\t\\tthis.pos = eased = jQuery.easing[ this.easing ](\\n\\t\\t\\t\\tpercent, this.options.duration * percent, 0, 1, this.options.duration\\n\\t\\t\\t);\\n\\t\\t} else {\\n\\t\\t\\tthis.pos = eased = percent;\\n\\t\\t}\\n\\t\\tthis.now = ( this.end - this.start ) * eased + this.start;\\n\\n\\t\\tif ( this.options.step ) {\\n\\t\\t\\tthis.options.step.call( this.elem, this.now, this );\\n\\t\\t}\\n\\n\\t\\tif ( hooks && hooks.set ) {\\n\\t\\t\\thooks.set( this );\\n\\t\\t} else {\\n\\t\\t\\tTween.propHooks._default.set( this );\\n\\t\\t}\\n\\t\\treturn this;\\n\\t}\\n};\\n\\nTween.prototype.init.prototype = Tween.prototype;\\n\\nTween.propHooks = {\\n\\t_default: {\\n\\t\\tget: function( tween ) {\\n\\t\\t\\tvar result;\\n\\n\\t\\t\\t// Use a property on the element directly when it is not a DOM element,\\n\\t\\t\\t// or when there is no matching style property that exists.\\n\\t\\t\\tif ( tween.elem.nodeType !== 1 ||\\n\\t\\t\\t\\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\\n\\t\\t\\t\\treturn tween.elem[ tween.prop ];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Passing an empty string as a 3rd parameter to .css will automatically\\n\\t\\t\\t// attempt a parseFloat and fallback to a string if the parse fails.\\n\\t\\t\\t// Simple values such as \"10px\" are parsed to Float;\\n\\t\\t\\t// complex values such as \"rotate(1rad)\" are returned as-is.\\n\\t\\t\\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\\n\\n\\t\\t\\t// Empty strings, null, undefined and \"auto\" are converted to 0.\\n\\t\\t\\treturn !result || result === \"auto\" ? 0 : result;\\n\\t\\t},\\n\\t\\tset: function( tween ) {\\n\\n\\t\\t\\t// Use step hook for back compat.\\n\\t\\t\\t// Use cssHook if its there.\\n\\t\\t\\t// Use .style if available and use plain properties where available.\\n\\t\\t\\tif ( jQuery.fx.step[ tween.prop ] ) {\\n\\t\\t\\t\\tjQuery.fx.step[ tween.prop ]( tween );\\n\\t\\t\\t} else if ( tween.elem.nodeType === 1 &&\\n\\t\\t\\t\\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\\n\\t\\t\\t\\t\\tjQuery.cssHooks[ tween.prop ] ) ) {\\n\\t\\t\\t\\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttween.elem[ tween.prop ] = tween.now;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\n// Support: IE <=9 only\\n// Panic based approach to setting things on disconnected nodes\\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\\n\\tset: function( tween ) {\\n\\t\\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\\n\\t\\t\\ttween.elem[ tween.prop ] = tween.now;\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.easing = {\\n\\tlinear: function( p ) {\\n\\t\\treturn p;\\n\\t},\\n\\tswing: function( p ) {\\n\\t\\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\\n\\t},\\n\\t_default: \"swing\"\\n};\\n\\njQuery.fx = Tween.prototype.init;\\n\\n// Back compat <1.8 extension point\\njQuery.fx.step = {};\\n\\n\\n\\n\\nvar\\n\\tfxNow, inProgress,\\n\\trfxtypes = /^(?:toggle|show|hide)$/,\\n\\trrun = /queueHooks$/;\\n\\nfunction schedule() {\\n\\tif ( inProgress ) {\\n\\t\\tif ( document.hidden === false && window.requestAnimationFrame ) {\\n\\t\\t\\twindow.requestAnimationFrame( schedule );\\n\\t\\t} else {\\n\\t\\t\\twindow.setTimeout( schedule, jQuery.fx.interval );\\n\\t\\t}\\n\\n\\t\\tjQuery.fx.tick();\\n\\t}\\n}\\n\\n// Animations created synchronously will run synchronously\\nfunction createFxNow() {\\n\\twindow.setTimeout( function() {\\n\\t\\tfxNow = undefined;\\n\\t} );\\n\\treturn ( fxNow = Date.now() );\\n}\\n\\n// Generate parameters to create a standard animation\\nfunction genFx( type, includeWidth ) {\\n\\tvar which,\\n\\t\\ti = 0,\\n\\t\\tattrs = { height: type };\\n\\n\\t// If we include width, step value is 1 to do all cssExpand values,\\n\\t// otherwise step value is 2 to skip over Left and Right\\n\\tincludeWidth = includeWidth ? 1 : 0;\\n\\tfor ( ; i < 4; i += 2 - includeWidth ) {\\n\\t\\twhich = cssExpand[ i ];\\n\\t\\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\\n\\t}\\n\\n\\tif ( includeWidth ) {\\n\\t\\tattrs.opacity = attrs.width = type;\\n\\t}\\n\\n\\treturn attrs;\\n}\\n\\nfunction createTween( value, prop, animation ) {\\n\\tvar tween,\\n\\t\\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\\n\\t\\tindex = 0,\\n\\t\\tlength = collection.length;\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\\n\\n\\t\\t\\t// We\\'re done with this property\\n\\t\\t\\treturn tween;\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction defaultPrefilter( elem, props, opts ) {\\n\\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\\n\\t\\tisBox = \"width\" in props || \"height\" in props,\\n\\t\\tanim = this,\\n\\t\\torig = {},\\n\\t\\tstyle = elem.style,\\n\\t\\thidden = elem.nodeType && isHiddenWithinTree( elem ),\\n\\t\\tdataShow = dataPriv.get( elem, \"fxshow\" );\\n\\n\\t// Queue-skipping animations hijack the fx hooks\\n\\tif ( !opts.queue ) {\\n\\t\\thooks = jQuery._queueHooks( elem, \"fx\" );\\n\\t\\tif ( hooks.unqueued == null ) {\\n\\t\\t\\thooks.unqueued = 0;\\n\\t\\t\\toldfire = hooks.empty.fire;\\n\\t\\t\\thooks.empty.fire = function() {\\n\\t\\t\\t\\tif ( !hooks.unqueued ) {\\n\\t\\t\\t\\t\\toldfire();\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\thooks.unqueued++;\\n\\n\\t\\tanim.always( function() {\\n\\n\\t\\t\\t// Ensure the complete handler is called before this completes\\n\\t\\t\\tanim.always( function() {\\n\\t\\t\\t\\thooks.unqueued--;\\n\\t\\t\\t\\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\\n\\t\\t\\t\\t\\thooks.empty.fire();\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\t}\\n\\n\\t// Detect show/hide animations\\n\\tfor ( prop in props ) {\\n\\t\\tvalue = props[ prop ];\\n\\t\\tif ( rfxtypes.test( value ) ) {\\n\\t\\t\\tdelete props[ prop ];\\n\\t\\t\\ttoggle = toggle || value === \"toggle\";\\n\\t\\t\\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\\n\\n\\t\\t\\t\\t// Pretend to be hidden if this is a \"show\" and\\n\\t\\t\\t\\t// there is still data from a stopped show/hide\\n\\t\\t\\t\\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\\n\\t\\t\\t\\t\\thidden = true;\\n\\n\\t\\t\\t\\t// Ignore all other no-op show/hide data\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\\n\\t\\t}\\n\\t}\\n\\n\\t// Bail out if this is a no-op like .hide().hide()\\n\\tpropTween = !jQuery.isEmptyObject( props );\\n\\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\t// Restrict \"overflow\" and \"display\" styles during box animations\\n\\tif ( isBox && elem.nodeType === 1 ) {\\n\\n\\t\\t// Support: IE <=9 - 11, Edge 12 - 15\\n\\t\\t// Record all 3 overflow attributes because IE does not infer the shorthand\\n\\t\\t// from identically-valued overflowX and overflowY and Edge just mirrors\\n\\t\\t// the overflowX value there.\\n\\t\\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\\n\\n\\t\\t// Identify a display type, preferring old show/hide data over the CSS cascade\\n\\t\\trestoreDisplay = dataShow && dataShow.display;\\n\\t\\tif ( restoreDisplay == null ) {\\n\\t\\t\\trestoreDisplay = dataPriv.get( elem, \"display\" );\\n\\t\\t}\\n\\t\\tdisplay = jQuery.css( elem, \"display\" );\\n\\t\\tif ( display === \"none\" ) {\\n\\t\\t\\tif ( restoreDisplay ) {\\n\\t\\t\\t\\tdisplay = restoreDisplay;\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Get nonempty value(s) by temporarily forcing visibility\\n\\t\\t\\t\\tshowHide( [ elem ], true );\\n\\t\\t\\t\\trestoreDisplay = elem.style.display || restoreDisplay;\\n\\t\\t\\t\\tdisplay = jQuery.css( elem, \"display\" );\\n\\t\\t\\t\\tshowHide( [ elem ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Animate inline elements as inline-block\\n\\t\\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\\n\\t\\t\\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\\n\\n\\t\\t\\t\\t// Restore the original display value at the end of pure show/hide animations\\n\\t\\t\\t\\tif ( !propTween ) {\\n\\t\\t\\t\\t\\tanim.done( function() {\\n\\t\\t\\t\\t\\t\\tstyle.display = restoreDisplay;\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\tif ( restoreDisplay == null ) {\\n\\t\\t\\t\\t\\t\\tdisplay = style.display;\\n\\t\\t\\t\\t\\t\\trestoreDisplay = display === \"none\" ? \"\" : display;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstyle.display = \"inline-block\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif ( opts.overflow ) {\\n\\t\\tstyle.overflow = \"hidden\";\\n\\t\\tanim.always( function() {\\n\\t\\t\\tstyle.overflow = opts.overflow[ 0 ];\\n\\t\\t\\tstyle.overflowX = opts.overflow[ 1 ];\\n\\t\\t\\tstyle.overflowY = opts.overflow[ 2 ];\\n\\t\\t} );\\n\\t}\\n\\n\\t// Implement show/hide animations\\n\\tpropTween = false;\\n\\tfor ( prop in orig ) {\\n\\n\\t\\t// General show/hide setup for this element animation\\n\\t\\tif ( !propTween ) {\\n\\t\\t\\tif ( dataShow ) {\\n\\t\\t\\t\\tif ( \"hidden\" in dataShow ) {\\n\\t\\t\\t\\t\\thidden = dataShow.hidden;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\\n\\t\\t\\tif ( toggle ) {\\n\\t\\t\\t\\tdataShow.hidden = !hidden;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Show elements before animating them\\n\\t\\t\\tif ( hidden ) {\\n\\t\\t\\t\\tshowHide( [ elem ], true );\\n\\t\\t\\t}\\n\\n\\t\\t\\t/* eslint-disable no-loop-func */\\n\\n\\t\\t\\tanim.done( function() {\\n\\n\\t\\t\\t/* eslint-enable no-loop-func */\\n\\n\\t\\t\\t\\t// The final step of a \"hide\" animation is actually hiding the element\\n\\t\\t\\t\\tif ( !hidden ) {\\n\\t\\t\\t\\t\\tshowHide( [ elem ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdataPriv.remove( elem, \"fxshow\" );\\n\\t\\t\\t\\tfor ( prop in orig ) {\\n\\t\\t\\t\\t\\tjQuery.style( elem, prop, orig[ prop ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\t// Per-property setup\\n\\t\\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\\n\\t\\tif ( !( prop in dataShow ) ) {\\n\\t\\t\\tdataShow[ prop ] = propTween.start;\\n\\t\\t\\tif ( hidden ) {\\n\\t\\t\\t\\tpropTween.end = propTween.start;\\n\\t\\t\\t\\tpropTween.start = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction propFilter( props, specialEasing ) {\\n\\tvar index, name, easing, value, hooks;\\n\\n\\t// camelCase, specialEasing and expand cssHook pass\\n\\tfor ( index in props ) {\\n\\t\\tname = camelCase( index );\\n\\t\\teasing = specialEasing[ name ];\\n\\t\\tvalue = props[ index ];\\n\\t\\tif ( Array.isArray( value ) ) {\\n\\t\\t\\teasing = value[ 1 ];\\n\\t\\t\\tvalue = props[ index ] = value[ 0 ];\\n\\t\\t}\\n\\n\\t\\tif ( index !== name ) {\\n\\t\\t\\tprops[ name ] = value;\\n\\t\\t\\tdelete props[ index ];\\n\\t\\t}\\n\\n\\t\\thooks = jQuery.cssHooks[ name ];\\n\\t\\tif ( hooks && \"expand\" in hooks ) {\\n\\t\\t\\tvalue = hooks.expand( value );\\n\\t\\t\\tdelete props[ name ];\\n\\n\\t\\t\\t// Not quite $.extend, this won\\'t overwrite existing keys.\\n\\t\\t\\t// Reusing \\'index\\' because we have the correct \"name\"\\n\\t\\t\\tfor ( index in value ) {\\n\\t\\t\\t\\tif ( !( index in props ) ) {\\n\\t\\t\\t\\t\\tprops[ index ] = value[ index ];\\n\\t\\t\\t\\t\\tspecialEasing[ index ] = easing;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tspecialEasing[ name ] = easing;\\n\\t\\t}\\n\\t}\\n}\\n\\nfunction Animation( elem, properties, options ) {\\n\\tvar result,\\n\\t\\tstopped,\\n\\t\\tindex = 0,\\n\\t\\tlength = Animation.prefilters.length,\\n\\t\\tdeferred = jQuery.Deferred().always( function() {\\n\\n\\t\\t\\t// Don\\'t match elem in the :animated selector\\n\\t\\t\\tdelete tick.elem;\\n\\t\\t} ),\\n\\t\\ttick = function() {\\n\\t\\t\\tif ( stopped ) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tvar currentTime = fxNow || createFxNow(),\\n\\t\\t\\t\\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\\n\\n\\t\\t\\t\\t// Support: Android 2.3 only\\n\\t\\t\\t\\t// Archaic crash bug won\\'t allow us to use `1 - ( 0.5 || 0 )` (#12497)\\n\\t\\t\\t\\ttemp = remaining / animation.duration || 0,\\n\\t\\t\\t\\tpercent = 1 - temp,\\n\\t\\t\\t\\tindex = 0,\\n\\t\\t\\t\\tlength = animation.tweens.length;\\n\\n\\t\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\t\\tanimation.tweens[ index ].run( percent );\\n\\t\\t\\t}\\n\\n\\t\\t\\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\\n\\n\\t\\t\\t// If there\\'s more to do, yield\\n\\t\\t\\tif ( percent < 1 && length ) {\\n\\t\\t\\t\\treturn remaining;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If this was an empty animation, synthesize a final progress notification\\n\\t\\t\\tif ( !length ) {\\n\\t\\t\\t\\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Resolve the animation and report its conclusion\\n\\t\\t\\tdeferred.resolveWith( elem, [ animation ] );\\n\\t\\t\\treturn false;\\n\\t\\t},\\n\\t\\tanimation = deferred.promise( {\\n\\t\\t\\telem: elem,\\n\\t\\t\\tprops: jQuery.extend( {}, properties ),\\n\\t\\t\\topts: jQuery.extend( true, {\\n\\t\\t\\t\\tspecialEasing: {},\\n\\t\\t\\t\\teasing: jQuery.easing._default\\n\\t\\t\\t}, options ),\\n\\t\\t\\toriginalProperties: properties,\\n\\t\\t\\toriginalOptions: options,\\n\\t\\t\\tstartTime: fxNow || createFxNow(),\\n\\t\\t\\tduration: options.duration,\\n\\t\\t\\ttweens: [],\\n\\t\\t\\tcreateTween: function( prop, end ) {\\n\\t\\t\\t\\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\\n\\t\\t\\t\\t\\t\\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\\n\\t\\t\\t\\tanimation.tweens.push( tween );\\n\\t\\t\\t\\treturn tween;\\n\\t\\t\\t},\\n\\t\\t\\tstop: function( gotoEnd ) {\\n\\t\\t\\t\\tvar index = 0,\\n\\n\\t\\t\\t\\t\\t// If we are going to the end, we want to run all the tweens\\n\\t\\t\\t\\t\\t// otherwise we skip this part\\n\\t\\t\\t\\t\\tlength = gotoEnd ? animation.tweens.length : 0;\\n\\t\\t\\t\\tif ( stopped ) {\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstopped = true;\\n\\t\\t\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\t\\t\\tanimation.tweens[ index ].run( 1 );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Resolve when we played the last frame; otherwise, reject\\n\\t\\t\\t\\tif ( gotoEnd ) {\\n\\t\\t\\t\\t\\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\\n\\t\\t\\t\\t\\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t} ),\\n\\t\\tprops = animation.props;\\n\\n\\tpropFilter( props, animation.opts.specialEasing );\\n\\n\\tfor ( ; index < length; index++ ) {\\n\\t\\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\\n\\t\\tif ( result ) {\\n\\t\\t\\tif ( isFunction( result.stop ) ) {\\n\\t\\t\\t\\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\\n\\t\\t\\t\\t\\tresult.stop.bind( result );\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}\\n\\n\\tjQuery.map( props, createTween, animation );\\n\\n\\tif ( isFunction( animation.opts.start ) ) {\\n\\t\\tanimation.opts.start.call( elem, animation );\\n\\t}\\n\\n\\t// Attach callbacks from options\\n\\tanimation\\n\\t\\t.progress( animation.opts.progress )\\n\\t\\t.done( animation.opts.done, animation.opts.complete )\\n\\t\\t.fail( animation.opts.fail )\\n\\t\\t.always( animation.opts.always );\\n\\n\\tjQuery.fx.timer(\\n\\t\\tjQuery.extend( tick, {\\n\\t\\t\\telem: elem,\\n\\t\\t\\tanim: animation,\\n\\t\\t\\tqueue: animation.opts.queue\\n\\t\\t} )\\n\\t);\\n\\n\\treturn animation;\\n}\\n\\njQuery.Animation = jQuery.extend( Animation, {\\n\\n\\ttweeners: {\\n\\t\\t\"*\": [ function( prop, value ) {\\n\\t\\t\\tvar tween = this.createTween( prop, value );\\n\\t\\t\\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\\n\\t\\t\\treturn tween;\\n\\t\\t} ]\\n\\t},\\n\\n\\ttweener: function( props, callback ) {\\n\\t\\tif ( isFunction( props ) ) {\\n\\t\\t\\tcallback = props;\\n\\t\\t\\tprops = [ \"*\" ];\\n\\t\\t} else {\\n\\t\\t\\tprops = props.match( rnothtmlwhite );\\n\\t\\t}\\n\\n\\t\\tvar prop,\\n\\t\\t\\tindex = 0,\\n\\t\\t\\tlength = props.length;\\n\\n\\t\\tfor ( ; index < length; index++ ) {\\n\\t\\t\\tprop = props[ index ];\\n\\t\\t\\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\\n\\t\\t\\tAnimation.tweeners[ prop ].unshift( callback );\\n\\t\\t}\\n\\t},\\n\\n\\tprefilters: [ defaultPrefilter ],\\n\\n\\tprefilter: function( callback, prepend ) {\\n\\t\\tif ( prepend ) {\\n\\t\\t\\tAnimation.prefilters.unshift( callback );\\n\\t\\t} else {\\n\\t\\t\\tAnimation.prefilters.push( callback );\\n\\t\\t}\\n\\t}\\n} );\\n\\njQuery.speed = function( speed, easing, fn ) {\\n\\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\\n\\t\\tcomplete: fn || !fn && easing ||\\n\\t\\t\\tisFunction( speed ) && speed,\\n\\t\\tduration: speed,\\n\\t\\teasing: fn && easing || easing && !isFunction( easing ) && easing\\n\\t};\\n\\n\\t// Go to the end state if fx are off\\n\\tif ( jQuery.fx.off ) {\\n\\t\\topt.duration = 0;\\n\\n\\t} else {\\n\\t\\tif ( typeof opt.duration !== \"number\" ) {\\n\\t\\t\\tif ( opt.duration in jQuery.fx.speeds ) {\\n\\t\\t\\t\\topt.duration = jQuery.fx.speeds[ opt.duration ];\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\topt.duration = jQuery.fx.speeds._default;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Normalize opt.queue - true/undefined/null -> \"fx\"\\n\\tif ( opt.queue == null || opt.queue === true ) {\\n\\t\\topt.queue = \"fx\";\\n\\t}\\n\\n\\t// Queueing\\n\\topt.old = opt.complete;\\n\\n\\topt.complete = function() {\\n\\t\\tif ( isFunction( opt.old ) ) {\\n\\t\\t\\topt.old.call( this );\\n\\t\\t}\\n\\n\\t\\tif ( opt.queue ) {\\n\\t\\t\\tjQuery.dequeue( this, opt.queue );\\n\\t\\t}\\n\\t};\\n\\n\\treturn opt;\\n};\\n\\njQuery.fn.extend( {\\n\\tfadeTo: function( speed, to, easing, callback ) {\\n\\n\\t\\t// Show any hidden elements after setting opacity to 0\\n\\t\\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\\n\\n\\t\\t\\t// Animate to the value specified\\n\\t\\t\\t.end().animate( { opacity: to }, speed, easing, callback );\\n\\t},\\n\\tanimate: function( prop, speed, easing, callback ) {\\n\\t\\tvar empty = jQuery.isEmptyObject( prop ),\\n\\t\\t\\toptall = jQuery.speed( speed, easing, callback ),\\n\\t\\t\\tdoAnimation = function() {\\n\\n\\t\\t\\t\\t// Operate on a copy of prop so per-property easing won\\'t be lost\\n\\t\\t\\t\\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\\n\\n\\t\\t\\t\\t// Empty animations, or finishing resolves immediately\\n\\t\\t\\t\\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\\n\\t\\t\\t\\t\\tanim.stop( true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tdoAnimation.finish = doAnimation;\\n\\n\\t\\treturn empty || optall.queue === false ?\\n\\t\\t\\tthis.each( doAnimation ) :\\n\\t\\t\\tthis.queue( optall.queue, doAnimation );\\n\\t},\\n\\tstop: function( type, clearQueue, gotoEnd ) {\\n\\t\\tvar stopQueue = function( hooks ) {\\n\\t\\t\\tvar stop = hooks.stop;\\n\\t\\t\\tdelete hooks.stop;\\n\\t\\t\\tstop( gotoEnd );\\n\\t\\t};\\n\\n\\t\\tif ( typeof type !== \"string\" ) {\\n\\t\\t\\tgotoEnd = clearQueue;\\n\\t\\t\\tclearQueue = type;\\n\\t\\t\\ttype = undefined;\\n\\t\\t}\\n\\t\\tif ( clearQueue && type !== false ) {\\n\\t\\t\\tthis.queue( type || \"fx\", [] );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar dequeue = true,\\n\\t\\t\\t\\tindex = type != null && type + \"queueHooks\",\\n\\t\\t\\t\\ttimers = jQuery.timers,\\n\\t\\t\\t\\tdata = dataPriv.get( this );\\n\\n\\t\\t\\tif ( index ) {\\n\\t\\t\\t\\tif ( data[ index ] && data[ index ].stop ) {\\n\\t\\t\\t\\t\\tstopQueue( data[ index ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor ( index in data ) {\\n\\t\\t\\t\\t\\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\\n\\t\\t\\t\\t\\t\\tstopQueue( data[ index ] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( index = timers.length; index--; ) {\\n\\t\\t\\t\\tif ( timers[ index ].elem === this &&\\n\\t\\t\\t\\t\\t( type == null || timers[ index ].queue === type ) ) {\\n\\n\\t\\t\\t\\t\\ttimers[ index ].anim.stop( gotoEnd );\\n\\t\\t\\t\\t\\tdequeue = false;\\n\\t\\t\\t\\t\\ttimers.splice( index, 1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Start the next in the queue if the last step wasn\\'t forced.\\n\\t\\t\\t// Timers currently will call their complete callbacks, which\\n\\t\\t\\t// will dequeue but only if they were gotoEnd.\\n\\t\\t\\tif ( dequeue || !gotoEnd ) {\\n\\t\\t\\t\\tjQuery.dequeue( this, type );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\tfinish: function( type ) {\\n\\t\\tif ( type !== false ) {\\n\\t\\t\\ttype = type || \"fx\";\\n\\t\\t}\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar index,\\n\\t\\t\\t\\tdata = dataPriv.get( this ),\\n\\t\\t\\t\\tqueue = data[ type + \"queue\" ],\\n\\t\\t\\t\\thooks = data[ type + \"queueHooks\" ],\\n\\t\\t\\t\\ttimers = jQuery.timers,\\n\\t\\t\\t\\tlength = queue ? queue.length : 0;\\n\\n\\t\\t\\t// Enable finishing flag on private data\\n\\t\\t\\tdata.finish = true;\\n\\n\\t\\t\\t// Empty the queue first\\n\\t\\t\\tjQuery.queue( this, type, [] );\\n\\n\\t\\t\\tif ( hooks && hooks.stop ) {\\n\\t\\t\\t\\thooks.stop.call( this, true );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Look for any active animations, and finish them\\n\\t\\t\\tfor ( index = timers.length; index--; ) {\\n\\t\\t\\t\\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\\n\\t\\t\\t\\t\\ttimers[ index ].anim.stop( true );\\n\\t\\t\\t\\t\\ttimers.splice( index, 1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Look for any animations in the old queue and finish them\\n\\t\\t\\tfor ( index = 0; index < length; index++ ) {\\n\\t\\t\\t\\tif ( queue[ index ] && queue[ index ].finish ) {\\n\\t\\t\\t\\t\\tqueue[ index ].finish.call( this );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Turn off finishing flag\\n\\t\\t\\tdelete data.finish;\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\\n\\tvar cssFn = jQuery.fn[ name ];\\n\\tjQuery.fn[ name ] = function( speed, easing, callback ) {\\n\\t\\treturn speed == null || typeof speed === \"boolean\" ?\\n\\t\\t\\tcssFn.apply( this, arguments ) :\\n\\t\\t\\tthis.animate( genFx( name, true ), speed, easing, callback );\\n\\t};\\n} );\\n\\n// Generate shortcuts for custom animations\\njQuery.each( {\\n\\tslideDown: genFx( \"show\" ),\\n\\tslideUp: genFx( \"hide\" ),\\n\\tslideToggle: genFx( \"toggle\" ),\\n\\tfadeIn: { opacity: \"show\" },\\n\\tfadeOut: { opacity: \"hide\" },\\n\\tfadeToggle: { opacity: \"toggle\" }\\n}, function( name, props ) {\\n\\tjQuery.fn[ name ] = function( speed, easing, callback ) {\\n\\t\\treturn this.animate( props, speed, easing, callback );\\n\\t};\\n} );\\n\\njQuery.timers = [];\\njQuery.fx.tick = function() {\\n\\tvar timer,\\n\\t\\ti = 0,\\n\\t\\ttimers = jQuery.timers;\\n\\n\\tfxNow = Date.now();\\n\\n\\tfor ( ; i < timers.length; i++ ) {\\n\\t\\ttimer = timers[ i ];\\n\\n\\t\\t// Run the timer and safely remove it when done (allowing for external removal)\\n\\t\\tif ( !timer() && timers[ i ] === timer ) {\\n\\t\\t\\ttimers.splice( i--, 1 );\\n\\t\\t}\\n\\t}\\n\\n\\tif ( !timers.length ) {\\n\\t\\tjQuery.fx.stop();\\n\\t}\\n\\tfxNow = undefined;\\n};\\n\\njQuery.fx.timer = function( timer ) {\\n\\tjQuery.timers.push( timer );\\n\\tjQuery.fx.start();\\n};\\n\\njQuery.fx.interval = 13;\\njQuery.fx.start = function() {\\n\\tif ( inProgress ) {\\n\\t\\treturn;\\n\\t}\\n\\n\\tinProgress = true;\\n\\tschedule();\\n};\\n\\njQuery.fx.stop = function() {\\n\\tinProgress = null;\\n};\\n\\njQuery.fx.speeds = {\\n\\tslow: 600,\\n\\tfast: 200,\\n\\n\\t// Default speed\\n\\t_default: 400\\n};\\n\\n\\n// Based off of the plugin by Clint Helfers, with permission.\\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\\njQuery.fn.delay = function( time, type ) {\\n\\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\\n\\ttype = type || \"fx\";\\n\\n\\treturn this.queue( type, function( next, hooks ) {\\n\\t\\tvar timeout = window.setTimeout( next, time );\\n\\t\\thooks.stop = function() {\\n\\t\\t\\twindow.clearTimeout( timeout );\\n\\t\\t};\\n\\t} );\\n};\\n\\n\\n( function() {\\n\\tvar input = document.createElement( \"input\" ),\\n\\t\\tselect = document.createElement( \"select\" ),\\n\\t\\topt = select.appendChild( document.createElement( \"option\" ) );\\n\\n\\tinput.type = \"checkbox\";\\n\\n\\t// Support: Android <=4.3 only\\n\\t// Default value for a checkbox should be \"on\"\\n\\tsupport.checkOn = input.value !== \"\";\\n\\n\\t// Support: IE <=11 only\\n\\t// Must access selectedIndex to make default options select\\n\\tsupport.optSelected = opt.selected;\\n\\n\\t// Support: IE <=11 only\\n\\t// An input loses its value after becoming a radio\\n\\tinput = document.createElement( \"input\" );\\n\\tinput.value = \"t\";\\n\\tinput.type = \"radio\";\\n\\tsupport.radioValue = input.value === \"t\";\\n} )();\\n\\n\\nvar boolHook,\\n\\tattrHandle = jQuery.expr.attrHandle;\\n\\njQuery.fn.extend( {\\n\\tattr: function( name, value ) {\\n\\t\\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\\n\\t},\\n\\n\\tremoveAttr: function( name ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.removeAttr( this, name );\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tattr: function( elem, name, value ) {\\n\\t\\tvar ret, hooks,\\n\\t\\t\\tnType = elem.nodeType;\\n\\n\\t\\t// Don\\'t get/set attributes on text, comment and attribute nodes\\n\\t\\tif ( nType === 3 || nType === 8 || nType === 2 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Fallback to prop when attributes are not supported\\n\\t\\tif ( typeof elem.getAttribute === \"undefined\" ) {\\n\\t\\t\\treturn jQuery.prop( elem, name, value );\\n\\t\\t}\\n\\n\\t\\t// Attribute hooks are determined by the lowercase version\\n\\t\\t// Grab necessary hook if one is defined\\n\\t\\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\\n\\t\\t\\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\\n\\t\\t\\t\\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\\n\\t\\t}\\n\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\tif ( value === null ) {\\n\\t\\t\\t\\tjQuery.removeAttr( elem, name );\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( hooks && \"set\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\telem.setAttribute( name, value + \"\" );\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\n\\t\\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\n\\t\\tret = jQuery.find.attr( elem, name );\\n\\n\\t\\t// Non-existent attributes return null, we normalize to undefined\\n\\t\\treturn ret == null ? undefined : ret;\\n\\t},\\n\\n\\tattrHooks: {\\n\\t\\ttype: {\\n\\t\\t\\tset: function( elem, value ) {\\n\\t\\t\\t\\tif ( !support.radioValue && value === \"radio\" &&\\n\\t\\t\\t\\t\\tnodeName( elem, \"input\" ) ) {\\n\\t\\t\\t\\t\\tvar val = elem.value;\\n\\t\\t\\t\\t\\telem.setAttribute( \"type\", value );\\n\\t\\t\\t\\t\\tif ( val ) {\\n\\t\\t\\t\\t\\t\\telem.value = val;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tremoveAttr: function( elem, value ) {\\n\\t\\tvar name,\\n\\t\\t\\ti = 0,\\n\\n\\t\\t\\t// Attribute names can contain non-HTML whitespace characters\\n\\t\\t\\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\\n\\t\\t\\tattrNames = value && value.match( rnothtmlwhite );\\n\\n\\t\\tif ( attrNames && elem.nodeType === 1 ) {\\n\\t\\t\\twhile ( ( name = attrNames[ i++ ] ) ) {\\n\\t\\t\\t\\telem.removeAttribute( name );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Hooks for boolean attributes\\nboolHook = {\\n\\tset: function( elem, value, name ) {\\n\\t\\tif ( value === false ) {\\n\\n\\t\\t\\t// Remove boolean attributes when set to false\\n\\t\\t\\tjQuery.removeAttr( elem, name );\\n\\t\\t} else {\\n\\t\\t\\telem.setAttribute( name, name );\\n\\t\\t}\\n\\t\\treturn name;\\n\\t}\\n};\\n\\njQuery.each( jQuery.expr.match.bool.source.match( /\\\\w+/g ), function( i, name ) {\\n\\tvar getter = attrHandle[ name ] || jQuery.find.attr;\\n\\n\\tattrHandle[ name ] = function( elem, name, isXML ) {\\n\\t\\tvar ret, handle,\\n\\t\\t\\tlowercaseName = name.toLowerCase();\\n\\n\\t\\tif ( !isXML ) {\\n\\n\\t\\t\\t// Avoid an infinite loop by temporarily removing this function from the getter\\n\\t\\t\\thandle = attrHandle[ lowercaseName ];\\n\\t\\t\\tattrHandle[ lowercaseName ] = ret;\\n\\t\\t\\tret = getter( elem, name, isXML ) != null ?\\n\\t\\t\\t\\tlowercaseName :\\n\\t\\t\\t\\tnull;\\n\\t\\t\\tattrHandle[ lowercaseName ] = handle;\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t};\\n} );\\n\\n\\n\\n\\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\\n\\trclickable = /^(?:a|area)$/i;\\n\\njQuery.fn.extend( {\\n\\tprop: function( name, value ) {\\n\\t\\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\\n\\t},\\n\\n\\tremoveProp: function( name ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tdelete this[ jQuery.propFix[ name ] || name ];\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tprop: function( elem, name, value ) {\\n\\t\\tvar ret, hooks,\\n\\t\\t\\tnType = elem.nodeType;\\n\\n\\t\\t// Don\\'t get/set properties on text, comment and attribute nodes\\n\\t\\tif ( nType === 3 || nType === 8 || nType === 2 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\\n\\n\\t\\t\\t// Fix name and attach hooks\\n\\t\\t\\tname = jQuery.propFix[ name ] || name;\\n\\t\\t\\thooks = jQuery.propHooks[ name ];\\n\\t\\t}\\n\\n\\t\\tif ( value !== undefined ) {\\n\\t\\t\\tif ( hooks && \"set\" in hooks &&\\n\\t\\t\\t\\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ( elem[ name ] = value );\\n\\t\\t}\\n\\n\\t\\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\\n\\t\\t\\treturn ret;\\n\\t\\t}\\n\\n\\t\\treturn elem[ name ];\\n\\t},\\n\\n\\tpropHooks: {\\n\\t\\ttabIndex: {\\n\\t\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t\\t// Support: IE <=9 - 11 only\\n\\t\\t\\t\\t// elem.tabIndex doesn\\'t always return the\\n\\t\\t\\t\\t// correct value when it hasn\\'t been explicitly set\\n\\t\\t\\t\\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\\n\\t\\t\\t\\t// Use proper attribute retrieval(#12072)\\n\\t\\t\\t\\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\\n\\n\\t\\t\\t\\tif ( tabindex ) {\\n\\t\\t\\t\\t\\treturn parseInt( tabindex, 10 );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (\\n\\t\\t\\t\\t\\trfocusable.test( elem.nodeName ) ||\\n\\t\\t\\t\\t\\trclickable.test( elem.nodeName ) &&\\n\\t\\t\\t\\t\\telem.href\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tpropFix: {\\n\\t\\t\"for\": \"htmlFor\",\\n\\t\\t\"class\": \"className\"\\n\\t}\\n} );\\n\\n// Support: IE <=11 only\\n// Accessing the selectedIndex property\\n// forces the browser to respect setting selected\\n// on the option\\n// The getter ensures a default option is selected\\n// when in an optgroup\\n// eslint rule \"no-unused-expressions\" is disabled for this code\\n// since it considers such accessions noop\\nif ( !support.optSelected ) {\\n\\tjQuery.propHooks.selected = {\\n\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t/* eslint no-unused-expressions: \"off\" */\\n\\n\\t\\t\\tvar parent = elem.parentNode;\\n\\t\\t\\tif ( parent && parent.parentNode ) {\\n\\t\\t\\t\\tparent.parentNode.selectedIndex;\\n\\t\\t\\t}\\n\\t\\t\\treturn null;\\n\\t\\t},\\n\\t\\tset: function( elem ) {\\n\\n\\t\\t\\t/* eslint no-unused-expressions: \"off\" */\\n\\n\\t\\t\\tvar parent = elem.parentNode;\\n\\t\\t\\tif ( parent ) {\\n\\t\\t\\t\\tparent.selectedIndex;\\n\\n\\t\\t\\t\\tif ( parent.parentNode ) {\\n\\t\\t\\t\\t\\tparent.parentNode.selectedIndex;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n}\\n\\njQuery.each( [\\n\\t\"tabIndex\",\\n\\t\"readOnly\",\\n\\t\"maxLength\",\\n\\t\"cellSpacing\",\\n\\t\"cellPadding\",\\n\\t\"rowSpan\",\\n\\t\"colSpan\",\\n\\t\"useMap\",\\n\\t\"frameBorder\",\\n\\t\"contentEditable\"\\n], function() {\\n\\tjQuery.propFix[ this.toLowerCase() ] = this;\\n} );\\n\\n\\n\\n\\n\\t// Strip and collapse whitespace according to HTML spec\\n\\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\\n\\tfunction stripAndCollapse( value ) {\\n\\t\\tvar tokens = value.match( rnothtmlwhite ) || [];\\n\\t\\treturn tokens.join( \" \" );\\n\\t}\\n\\n\\nfunction getClass( elem ) {\\n\\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\\n}\\n\\nfunction classesToArray( value ) {\\n\\tif ( Array.isArray( value ) ) {\\n\\t\\treturn value;\\n\\t}\\n\\tif ( typeof value === \"string\" ) {\\n\\t\\treturn value.match( rnothtmlwhite ) || [];\\n\\t}\\n\\treturn [];\\n}\\n\\njQuery.fn.extend( {\\n\\taddClass: function( value ) {\\n\\t\\tvar classes, elem, cur, curValue, clazz, j, finalValue,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tif ( isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( j ) {\\n\\t\\t\\t\\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tclasses = classesToArray( value );\\n\\n\\t\\tif ( classes.length ) {\\n\\t\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\t\\tcurValue = getClass( elem );\\n\\t\\t\\t\\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\\n\\n\\t\\t\\t\\tif ( cur ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\twhile ( ( clazz = classes[ j++ ] ) ) {\\n\\t\\t\\t\\t\\t\\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\\n\\t\\t\\t\\t\\t\\t\\tcur += clazz + \" \";\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Only assign if different to avoid unneeded rendering.\\n\\t\\t\\t\\t\\tfinalValue = stripAndCollapse( cur );\\n\\t\\t\\t\\t\\tif ( curValue !== finalValue ) {\\n\\t\\t\\t\\t\\t\\telem.setAttribute( \"class\", finalValue );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\tremoveClass: function( value ) {\\n\\t\\tvar classes, elem, cur, curValue, clazz, j, finalValue,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tif ( isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( j ) {\\n\\t\\t\\t\\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tif ( !arguments.length ) {\\n\\t\\t\\treturn this.attr( \"class\", \"\" );\\n\\t\\t}\\n\\n\\t\\tclasses = classesToArray( value );\\n\\n\\t\\tif ( classes.length ) {\\n\\t\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\t\\tcurValue = getClass( elem );\\n\\n\\t\\t\\t\\t// This expression is here for better compressibility (see addClass)\\n\\t\\t\\t\\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\\n\\n\\t\\t\\t\\tif ( cur ) {\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t\\twhile ( ( clazz = classes[ j++ ] ) ) {\\n\\n\\t\\t\\t\\t\\t\\t// Remove *all* instances\\n\\t\\t\\t\\t\\t\\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\\n\\t\\t\\t\\t\\t\\t\\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Only assign if different to avoid unneeded rendering.\\n\\t\\t\\t\\t\\tfinalValue = stripAndCollapse( cur );\\n\\t\\t\\t\\t\\tif ( curValue !== finalValue ) {\\n\\t\\t\\t\\t\\t\\telem.setAttribute( \"class\", finalValue );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\ttoggleClass: function( value, stateVal ) {\\n\\t\\tvar type = typeof value,\\n\\t\\t\\tisValidValue = type === \"string\" || Array.isArray( value );\\n\\n\\t\\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\\n\\t\\t\\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\\n\\t\\t}\\n\\n\\t\\tif ( isFunction( value ) ) {\\n\\t\\t\\treturn this.each( function( i ) {\\n\\t\\t\\t\\tjQuery( this ).toggleClass(\\n\\t\\t\\t\\t\\tvalue.call( this, i, getClass( this ), stateVal ),\\n\\t\\t\\t\\t\\tstateVal\\n\\t\\t\\t\\t);\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar className, i, self, classNames;\\n\\n\\t\\t\\tif ( isValidValue ) {\\n\\n\\t\\t\\t\\t// Toggle individual class names\\n\\t\\t\\t\\ti = 0;\\n\\t\\t\\t\\tself = jQuery( this );\\n\\t\\t\\t\\tclassNames = classesToArray( value );\\n\\n\\t\\t\\t\\twhile ( ( className = classNames[ i++ ] ) ) {\\n\\n\\t\\t\\t\\t\\t// Check each className given, space separated list\\n\\t\\t\\t\\t\\tif ( self.hasClass( className ) ) {\\n\\t\\t\\t\\t\\t\\tself.removeClass( className );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tself.addClass( className );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t// Toggle whole class name\\n\\t\\t\\t} else if ( value === undefined || type === \"boolean\" ) {\\n\\t\\t\\t\\tclassName = getClass( this );\\n\\t\\t\\t\\tif ( className ) {\\n\\n\\t\\t\\t\\t\\t// Store className if set\\n\\t\\t\\t\\t\\tdataPriv.set( this, \"__className__\", className );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If the element has a class name or if we\\'re passed `false`,\\n\\t\\t\\t\\t// then remove the whole classname (if there was one, the above saved it).\\n\\t\\t\\t\\t// Otherwise bring back whatever was previously saved (if anything),\\n\\t\\t\\t\\t// falling back to the empty string if nothing was stored.\\n\\t\\t\\t\\tif ( this.setAttribute ) {\\n\\t\\t\\t\\t\\tthis.setAttribute( \"class\",\\n\\t\\t\\t\\t\\t\\tclassName || value === false ?\\n\\t\\t\\t\\t\\t\\t\"\" :\\n\\t\\t\\t\\t\\t\\tdataPriv.get( this, \"__className__\" ) || \"\"\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\thasClass: function( selector ) {\\n\\t\\tvar className, elem,\\n\\t\\t\\ti = 0;\\n\\n\\t\\tclassName = \" \" + selector + \" \";\\n\\t\\twhile ( ( elem = this[ i++ ] ) ) {\\n\\t\\t\\tif ( elem.nodeType === 1 &&\\n\\t\\t\\t\\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n} );\\n\\n\\n\\n\\nvar rreturn = /\\\\r/g;\\n\\njQuery.fn.extend( {\\n\\tval: function( value ) {\\n\\t\\tvar hooks, ret, valueIsFunction,\\n\\t\\t\\telem = this[ 0 ];\\n\\n\\t\\tif ( !arguments.length ) {\\n\\t\\t\\tif ( elem ) {\\n\\t\\t\\t\\thooks = jQuery.valHooks[ elem.type ] ||\\n\\t\\t\\t\\t\\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\\n\\n\\t\\t\\t\\tif ( hooks &&\\n\\t\\t\\t\\t\\t\"get\" in hooks &&\\n\\t\\t\\t\\t\\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\treturn ret;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tret = elem.value;\\n\\n\\t\\t\\t\\t// Handle most common string cases\\n\\t\\t\\t\\tif ( typeof ret === \"string\" ) {\\n\\t\\t\\t\\t\\treturn ret.replace( rreturn, \"\" );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Handle cases where value is null/undef or number\\n\\t\\t\\t\\treturn ret == null ? \"\" : ret;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvalueIsFunction = isFunction( value );\\n\\n\\t\\treturn this.each( function( i ) {\\n\\t\\t\\tvar val;\\n\\n\\t\\t\\tif ( this.nodeType !== 1 ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( valueIsFunction ) {\\n\\t\\t\\t\\tval = value.call( this, i, jQuery( this ).val() );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tval = value;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Treat null/undefined as \"\"; convert numbers to string\\n\\t\\t\\tif ( val == null ) {\\n\\t\\t\\t\\tval = \"\";\\n\\n\\t\\t\\t} else if ( typeof val === \"number\" ) {\\n\\t\\t\\t\\tval += \"\";\\n\\n\\t\\t\\t} else if ( Array.isArray( val ) ) {\\n\\t\\t\\t\\tval = jQuery.map( val, function( value ) {\\n\\t\\t\\t\\t\\treturn value == null ? \"\" : value + \"\";\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\n\\t\\t\\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\\n\\n\\t\\t\\t// If set returns undefined, fall back to normal setting\\n\\t\\t\\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\\n\\t\\t\\t\\tthis.value = val;\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t}\\n} );\\n\\njQuery.extend( {\\n\\tvalHooks: {\\n\\t\\toption: {\\n\\t\\t\\tget: function( elem ) {\\n\\n\\t\\t\\t\\tvar val = jQuery.find.attr( elem, \"value\" );\\n\\t\\t\\t\\treturn val != null ?\\n\\t\\t\\t\\t\\tval :\\n\\n\\t\\t\\t\\t\\t// Support: IE <=10 - 11 only\\n\\t\\t\\t\\t\\t// option.text throws exceptions (#14686, #14858)\\n\\t\\t\\t\\t\\t// Strip and collapse whitespace\\n\\t\\t\\t\\t\\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\\n\\t\\t\\t\\t\\tstripAndCollapse( jQuery.text( elem ) );\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tselect: {\\n\\t\\t\\tget: function( elem ) {\\n\\t\\t\\t\\tvar value, option, i,\\n\\t\\t\\t\\t\\toptions = elem.options,\\n\\t\\t\\t\\t\\tindex = elem.selectedIndex,\\n\\t\\t\\t\\t\\tone = elem.type === \"select-one\",\\n\\t\\t\\t\\t\\tvalues = one ? null : [],\\n\\t\\t\\t\\t\\tmax = one ? index + 1 : options.length;\\n\\n\\t\\t\\t\\tif ( index < 0 ) {\\n\\t\\t\\t\\t\\ti = max;\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ti = one ? index : 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Loop through all the selected options\\n\\t\\t\\t\\tfor ( ; i < max; i++ ) {\\n\\t\\t\\t\\t\\toption = options[ i ];\\n\\n\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t// IE8-9 doesn\\'t update selected after form reset (#2551)\\n\\t\\t\\t\\t\\tif ( ( option.selected || i === index ) &&\\n\\n\\t\\t\\t\\t\\t\\t\\t// Don\\'t return options that are disabled or in a disabled optgroup\\n\\t\\t\\t\\t\\t\\t\\t!option.disabled &&\\n\\t\\t\\t\\t\\t\\t\\t( !option.parentNode.disabled ||\\n\\t\\t\\t\\t\\t\\t\\t\\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\t// Get the specific value for the option\\n\\t\\t\\t\\t\\t\\tvalue = jQuery( option ).val();\\n\\n\\t\\t\\t\\t\\t\\t// We don\\'t need an array for one selects\\n\\t\\t\\t\\t\\t\\tif ( one ) {\\n\\t\\t\\t\\t\\t\\t\\treturn value;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Multi-Selects return an array\\n\\t\\t\\t\\t\\t\\tvalues.push( value );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn values;\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function( elem, value ) {\\n\\t\\t\\t\\tvar optionSet, option,\\n\\t\\t\\t\\t\\toptions = elem.options,\\n\\t\\t\\t\\t\\tvalues = jQuery.makeArray( value ),\\n\\t\\t\\t\\t\\ti = options.length;\\n\\n\\t\\t\\t\\twhile ( i-- ) {\\n\\t\\t\\t\\t\\toption = options[ i ];\\n\\n\\t\\t\\t\\t\\t/* eslint-disable no-cond-assign */\\n\\n\\t\\t\\t\\t\\tif ( option.selected =\\n\\t\\t\\t\\t\\t\\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\\n\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\toptionSet = true;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t/* eslint-enable no-cond-assign */\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Force browsers to behave consistently when non-matching value is set\\n\\t\\t\\t\\tif ( !optionSet ) {\\n\\t\\t\\t\\t\\telem.selectedIndex = -1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn values;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Radios and checkboxes getter/setter\\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\\n\\tjQuery.valHooks[ this ] = {\\n\\t\\tset: function( elem, value ) {\\n\\t\\t\\tif ( Array.isArray( value ) ) {\\n\\t\\t\\t\\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\tif ( !support.checkOn ) {\\n\\t\\tjQuery.valHooks[ this ].get = function( elem ) {\\n\\t\\t\\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\n// Return jQuery for attributes-only inclusion\\n\\n\\nsupport.focusin = \"onfocusin\" in window;\\n\\n\\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\\n\\tstopPropagationCallback = function( e ) {\\n\\t\\te.stopPropagation();\\n\\t};\\n\\njQuery.extend( jQuery.event, {\\n\\n\\ttrigger: function( event, data, elem, onlyHandlers ) {\\n\\n\\t\\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\\n\\t\\t\\teventPath = [ elem || document ],\\n\\t\\t\\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\\n\\t\\t\\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\\n\\n\\t\\tcur = lastElement = tmp = elem = elem || document;\\n\\n\\t\\t// Don\\'t do events on text and comment nodes\\n\\t\\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// focus/blur morphs to focusin/out; ensure we\\'re not firing them right now\\n\\t\\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( type.indexOf( \".\" ) > -1 ) {\\n\\n\\t\\t\\t// Namespaced trigger; create a regexp to match event type in handle()\\n\\t\\t\\tnamespaces = type.split( \".\" );\\n\\t\\t\\ttype = namespaces.shift();\\n\\t\\t\\tnamespaces.sort();\\n\\t\\t}\\n\\t\\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\\n\\n\\t\\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\\n\\t\\tevent = event[ jQuery.expando ] ?\\n\\t\\t\\tevent :\\n\\t\\t\\tnew jQuery.Event( type, typeof event === \"object\" && event );\\n\\n\\t\\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\\n\\t\\tevent.isTrigger = onlyHandlers ? 2 : 3;\\n\\t\\tevent.namespace = namespaces.join( \".\" );\\n\\t\\tevent.rnamespace = event.namespace ?\\n\\t\\t\\tnew RegExp( \"(^|\\\\\\\\.)\" + namespaces.join( \"\\\\\\\\.(?:.*\\\\\\\\.|)\" ) + \"(\\\\\\\\.|$)\" ) :\\n\\t\\t\\tnull;\\n\\n\\t\\t// Clean up the event in case it is being reused\\n\\t\\tevent.result = undefined;\\n\\t\\tif ( !event.target ) {\\n\\t\\t\\tevent.target = elem;\\n\\t\\t}\\n\\n\\t\\t// Clone any incoming data and prepend the event, creating the handler arg list\\n\\t\\tdata = data == null ?\\n\\t\\t\\t[ event ] :\\n\\t\\t\\tjQuery.makeArray( data, [ event ] );\\n\\n\\t\\t// Allow special events to draw outside the lines\\n\\t\\tspecial = jQuery.event.special[ type ] || {};\\n\\t\\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Determine event propagation path in advance, per W3C events spec (#9951)\\n\\t\\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\\n\\t\\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\\n\\n\\t\\t\\tbubbleType = special.delegateType || type;\\n\\t\\t\\tif ( !rfocusMorph.test( bubbleType + type ) ) {\\n\\t\\t\\t\\tcur = cur.parentNode;\\n\\t\\t\\t}\\n\\t\\t\\tfor ( ; cur; cur = cur.parentNode ) {\\n\\t\\t\\t\\teventPath.push( cur );\\n\\t\\t\\t\\ttmp = cur;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\\n\\t\\t\\tif ( tmp === ( elem.ownerDocument || document ) ) {\\n\\t\\t\\t\\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Fire handlers on the event path\\n\\t\\ti = 0;\\n\\t\\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\\n\\t\\t\\tlastElement = cur;\\n\\t\\t\\tevent.type = i > 1 ?\\n\\t\\t\\t\\tbubbleType :\\n\\t\\t\\t\\tspecial.bindType || type;\\n\\n\\t\\t\\t// jQuery handler\\n\\t\\t\\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\\n\\t\\t\\t\\tdataPriv.get( cur, \"handle\" );\\n\\t\\t\\tif ( handle ) {\\n\\t\\t\\t\\thandle.apply( cur, data );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Native handler\\n\\t\\t\\thandle = ontype && cur[ ontype ];\\n\\t\\t\\tif ( handle && handle.apply && acceptData( cur ) ) {\\n\\t\\t\\t\\tevent.result = handle.apply( cur, data );\\n\\t\\t\\t\\tif ( event.result === false ) {\\n\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tevent.type = type;\\n\\n\\t\\t// If nobody prevented the default action, do it now\\n\\t\\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\\n\\n\\t\\t\\tif ( ( !special._default ||\\n\\t\\t\\t\\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\\n\\t\\t\\t\\tacceptData( elem ) ) {\\n\\n\\t\\t\\t\\t// Call a native DOM method on the target with the same name as the event.\\n\\t\\t\\t\\t// Don\\'t do default actions on window, that\\'s where global variables be (#6170)\\n\\t\\t\\t\\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\\n\\n\\t\\t\\t\\t\\t// Don\\'t re-trigger an onFOO event when we call its FOO() method\\n\\t\\t\\t\\t\\ttmp = elem[ ontype ];\\n\\n\\t\\t\\t\\t\\tif ( tmp ) {\\n\\t\\t\\t\\t\\t\\telem[ ontype ] = null;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Prevent re-triggering of the same event, since we already bubbled it above\\n\\t\\t\\t\\t\\tjQuery.event.triggered = type;\\n\\n\\t\\t\\t\\t\\tif ( event.isPropagationStopped() ) {\\n\\t\\t\\t\\t\\t\\tlastElement.addEventListener( type, stopPropagationCallback );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\telem[ type ]();\\n\\n\\t\\t\\t\\t\\tif ( event.isPropagationStopped() ) {\\n\\t\\t\\t\\t\\t\\tlastElement.removeEventListener( type, stopPropagationCallback );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tjQuery.event.triggered = undefined;\\n\\n\\t\\t\\t\\t\\tif ( tmp ) {\\n\\t\\t\\t\\t\\t\\telem[ ontype ] = tmp;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn event.result;\\n\\t},\\n\\n\\t// Piggyback on a donor event to simulate a different one\\n\\t// Used only for `focus(in | out)` events\\n\\tsimulate: function( type, elem, event ) {\\n\\t\\tvar e = jQuery.extend(\\n\\t\\t\\tnew jQuery.Event(),\\n\\t\\t\\tevent,\\n\\t\\t\\t{\\n\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\tisSimulated: true\\n\\t\\t\\t}\\n\\t\\t);\\n\\n\\t\\tjQuery.event.trigger( e, null, elem );\\n\\t}\\n\\n} );\\n\\njQuery.fn.extend( {\\n\\n\\ttrigger: function( type, data ) {\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tjQuery.event.trigger( type, data, this );\\n\\t\\t} );\\n\\t},\\n\\ttriggerHandler: function( type, data ) {\\n\\t\\tvar elem = this[ 0 ];\\n\\t\\tif ( elem ) {\\n\\t\\t\\treturn jQuery.event.trigger( type, data, elem, true );\\n\\t\\t}\\n\\t}\\n} );\\n\\n\\n// Support: Firefox <=44\\n// Firefox doesn\\'t have focus(in | out) events\\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\\n//\\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\\n// focus(in | out) events fire after focus & blur events,\\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\\nif ( !support.focusin ) {\\n\\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\\n\\n\\t\\t// Attach a single capturing handler on the document while someone wants focusin/focusout\\n\\t\\tvar handler = function( event ) {\\n\\t\\t\\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\\n\\t\\t};\\n\\n\\t\\tjQuery.event.special[ fix ] = {\\n\\t\\t\\tsetup: function() {\\n\\t\\t\\t\\tvar doc = this.ownerDocument || this,\\n\\t\\t\\t\\t\\tattaches = dataPriv.access( doc, fix );\\n\\n\\t\\t\\t\\tif ( !attaches ) {\\n\\t\\t\\t\\t\\tdoc.addEventListener( orig, handler, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\\n\\t\\t\\t},\\n\\t\\t\\tteardown: function() {\\n\\t\\t\\t\\tvar doc = this.ownerDocument || this,\\n\\t\\t\\t\\t\\tattaches = dataPriv.access( doc, fix ) - 1;\\n\\n\\t\\t\\t\\tif ( !attaches ) {\\n\\t\\t\\t\\t\\tdoc.removeEventListener( orig, handler, true );\\n\\t\\t\\t\\t\\tdataPriv.remove( doc, fix );\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdataPriv.access( doc, fix, attaches );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t} );\\n}\\nvar location = window.location;\\n\\nvar nonce = Date.now();\\n\\nvar rquery = ( /\\\\?/ );\\n\\n\\n\\n// Cross-browser xml parsing\\njQuery.parseXML = function( data ) {\\n\\tvar xml;\\n\\tif ( !data || typeof data !== \"string\" ) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// Support: IE 9 - 11 only\\n\\t// IE throws on parseFromString with invalid input.\\n\\ttry {\\n\\t\\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\\n\\t} catch ( e ) {\\n\\t\\txml = undefined;\\n\\t}\\n\\n\\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\\n\\t\\tjQuery.error( \"Invalid XML: \" + data );\\n\\t}\\n\\treturn xml;\\n};\\n\\n\\nvar\\n\\trbracket = /\\\\[\\\\]$/,\\n\\trCRLF = /\\\\r?\\\\n/g,\\n\\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\\n\\trsubmittable = /^(?:input|select|textarea|keygen)/i;\\n\\nfunction buildParams( prefix, obj, traditional, add ) {\\n\\tvar name;\\n\\n\\tif ( Array.isArray( obj ) ) {\\n\\n\\t\\t// Serialize array item.\\n\\t\\tjQuery.each( obj, function( i, v ) {\\n\\t\\t\\tif ( traditional || rbracket.test( prefix ) ) {\\n\\n\\t\\t\\t\\t// Treat each array item as a scalar.\\n\\t\\t\\t\\tadd( prefix, v );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Item is non-scalar (array or object), encode its numeric index.\\n\\t\\t\\t\\tbuildParams(\\n\\t\\t\\t\\t\\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\\n\\t\\t\\t\\t\\tv,\\n\\t\\t\\t\\t\\ttraditional,\\n\\t\\t\\t\\t\\tadd\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t} else if ( !traditional && toType( obj ) === \"object\" ) {\\n\\n\\t\\t// Serialize object item.\\n\\t\\tfor ( name in obj ) {\\n\\t\\t\\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\\n\\t\\t}\\n\\n\\t} else {\\n\\n\\t\\t// Serialize scalar item.\\n\\t\\tadd( prefix, obj );\\n\\t}\\n}\\n\\n// Serialize an array of form elements or a set of\\n// key/values into a query string\\njQuery.param = function( a, traditional ) {\\n\\tvar prefix,\\n\\t\\ts = [],\\n\\t\\tadd = function( key, valueOrFunction ) {\\n\\n\\t\\t\\t// If value is a function, invoke it and use its return value\\n\\t\\t\\tvar value = isFunction( valueOrFunction ) ?\\n\\t\\t\\t\\tvalueOrFunction() :\\n\\t\\t\\t\\tvalueOrFunction;\\n\\n\\t\\t\\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\\n\\t\\t\\t\\tencodeURIComponent( value == null ? \"\" : value );\\n\\t\\t};\\n\\n\\t// If an array was passed in, assume that it is an array of form elements.\\n\\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\\n\\n\\t\\t// Serialize the form elements\\n\\t\\tjQuery.each( a, function() {\\n\\t\\t\\tadd( this.name, this.value );\\n\\t\\t} );\\n\\n\\t} else {\\n\\n\\t\\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\\n\\t\\t// did it), otherwise encode params recursively.\\n\\t\\tfor ( prefix in a ) {\\n\\t\\t\\tbuildParams( prefix, a[ prefix ], traditional, add );\\n\\t\\t}\\n\\t}\\n\\n\\t// Return the resulting serialization\\n\\treturn s.join( \"&\" );\\n};\\n\\njQuery.fn.extend( {\\n\\tserialize: function() {\\n\\t\\treturn jQuery.param( this.serializeArray() );\\n\\t},\\n\\tserializeArray: function() {\\n\\t\\treturn this.map( function() {\\n\\n\\t\\t\\t// Can add propHook for \"elements\" to filter or add form elements\\n\\t\\t\\tvar elements = jQuery.prop( this, \"elements\" );\\n\\t\\t\\treturn elements ? jQuery.makeArray( elements ) : this;\\n\\t\\t} )\\n\\t\\t.filter( function() {\\n\\t\\t\\tvar type = this.type;\\n\\n\\t\\t\\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\\n\\t\\t\\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\\n\\t\\t\\t\\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\\n\\t\\t\\t\\t( this.checked || !rcheckableType.test( type ) );\\n\\t\\t} )\\n\\t\\t.map( function( i, elem ) {\\n\\t\\t\\tvar val = jQuery( this ).val();\\n\\n\\t\\t\\tif ( val == null ) {\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( Array.isArray( val ) ) {\\n\\t\\t\\t\\treturn jQuery.map( val, function( val ) {\\n\\t\\t\\t\\t\\treturn { name: elem.name, value: val.replace( rCRLF, \"\\\\r\\\\n\" ) };\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn { name: elem.name, value: val.replace( rCRLF, \"\\\\r\\\\n\" ) };\\n\\t\\t} ).get();\\n\\t}\\n} );\\n\\n\\nvar\\n\\tr20 = /%20/g,\\n\\trhash = /#.*$/,\\n\\trantiCache = /([?&])_=[^&]*/,\\n\\trheaders = /^(.*?):[ \\\\t]*([^\\\\r\\\\n]*)$/mg,\\n\\n\\t// #7653, #8125, #8152: local protocol detection\\n\\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\\n\\trnoContent = /^(?:GET|HEAD)$/,\\n\\trprotocol = /^\\\\/\\\\//,\\n\\n\\t/* Prefilters\\n\\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\\n\\t * 2) These are called:\\n\\t *    - BEFORE asking for a transport\\n\\t *    - AFTER param serialization (s.data is a string if s.processData is true)\\n\\t * 3) key is the dataType\\n\\t * 4) the catchall symbol \"*\" can be used\\n\\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\\n\\t */\\n\\tprefilters = {},\\n\\n\\t/* Transports bindings\\n\\t * 1) key is the dataType\\n\\t * 2) the catchall symbol \"*\" can be used\\n\\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\\n\\t */\\n\\ttransports = {},\\n\\n\\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\\n\\tallTypes = \"*/\".concat( \"*\" ),\\n\\n\\t// Anchor tag for parsing the document origin\\n\\toriginAnchor = document.createElement( \"a\" );\\n\\toriginAnchor.href = location.href;\\n\\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\\nfunction addToPrefiltersOrTransports( structure ) {\\n\\n\\t// dataTypeExpression is optional and defaults to \"*\"\\n\\treturn function( dataTypeExpression, func ) {\\n\\n\\t\\tif ( typeof dataTypeExpression !== \"string\" ) {\\n\\t\\t\\tfunc = dataTypeExpression;\\n\\t\\t\\tdataTypeExpression = \"*\";\\n\\t\\t}\\n\\n\\t\\tvar dataType,\\n\\t\\t\\ti = 0,\\n\\t\\t\\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\\n\\n\\t\\tif ( isFunction( func ) ) {\\n\\n\\t\\t\\t// For each dataType in the dataTypeExpression\\n\\t\\t\\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\\n\\n\\t\\t\\t\\t// Prepend if requested\\n\\t\\t\\t\\tif ( dataType[ 0 ] === \"+\" ) {\\n\\t\\t\\t\\t\\tdataType = dataType.slice( 1 ) || \"*\";\\n\\t\\t\\t\\t\\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\\n\\n\\t\\t\\t\\t// Otherwise append\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n}\\n\\n// Base inspection function for prefilters and transports\\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\\n\\n\\tvar inspected = {},\\n\\t\\tseekingTransport = ( structure === transports );\\n\\n\\tfunction inspect( dataType ) {\\n\\t\\tvar selected;\\n\\t\\tinspected[ dataType ] = true;\\n\\t\\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\\n\\t\\t\\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\\n\\t\\t\\tif ( typeof dataTypeOrTransport === \"string\" &&\\n\\t\\t\\t\\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\\n\\n\\t\\t\\t\\toptions.dataTypes.unshift( dataTypeOrTransport );\\n\\t\\t\\t\\tinspect( dataTypeOrTransport );\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t} else if ( seekingTransport ) {\\n\\t\\t\\t\\treturn !( selected = dataTypeOrTransport );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t\\treturn selected;\\n\\t}\\n\\n\\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\\n}\\n\\n// A special extend for ajax options\\n// that takes \"flat\" options (not to be deep extended)\\n// Fixes #9887\\nfunction ajaxExtend( target, src ) {\\n\\tvar key, deep,\\n\\t\\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\\n\\n\\tfor ( key in src ) {\\n\\t\\tif ( src[ key ] !== undefined ) {\\n\\t\\t\\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\\n\\t\\t}\\n\\t}\\n\\tif ( deep ) {\\n\\t\\tjQuery.extend( true, target, deep );\\n\\t}\\n\\n\\treturn target;\\n}\\n\\n/* Handles responses to an ajax request:\\n * - finds the right dataType (mediates between content-type and expected dataType)\\n * - returns the corresponding response\\n */\\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\\n\\n\\tvar ct, type, finalDataType, firstDataType,\\n\\t\\tcontents = s.contents,\\n\\t\\tdataTypes = s.dataTypes;\\n\\n\\t// Remove auto dataType and get content-type in the process\\n\\twhile ( dataTypes[ 0 ] === \"*\" ) {\\n\\t\\tdataTypes.shift();\\n\\t\\tif ( ct === undefined ) {\\n\\t\\t\\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\\n\\t\\t}\\n\\t}\\n\\n\\t// Check if we\\'re dealing with a known content-type\\n\\tif ( ct ) {\\n\\t\\tfor ( type in contents ) {\\n\\t\\t\\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\\n\\t\\t\\t\\tdataTypes.unshift( type );\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// Check to see if we have a response for the expected dataType\\n\\tif ( dataTypes[ 0 ] in responses ) {\\n\\t\\tfinalDataType = dataTypes[ 0 ];\\n\\t} else {\\n\\n\\t\\t// Try convertible dataTypes\\n\\t\\tfor ( type in responses ) {\\n\\t\\t\\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\\n\\t\\t\\t\\tfinalDataType = type;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif ( !firstDataType ) {\\n\\t\\t\\t\\tfirstDataType = type;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Or just use first one\\n\\t\\tfinalDataType = finalDataType || firstDataType;\\n\\t}\\n\\n\\t// If we found a dataType\\n\\t// We add the dataType to the list if needed\\n\\t// and return the corresponding response\\n\\tif ( finalDataType ) {\\n\\t\\tif ( finalDataType !== dataTypes[ 0 ] ) {\\n\\t\\t\\tdataTypes.unshift( finalDataType );\\n\\t\\t}\\n\\t\\treturn responses[ finalDataType ];\\n\\t}\\n}\\n\\n/* Chain conversions given the request and the original response\\n * Also sets the responseXXX fields on the jqXHR instance\\n */\\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\\n\\tvar conv2, current, conv, tmp, prev,\\n\\t\\tconverters = {},\\n\\n\\t\\t// Work with a copy of dataTypes in case we need to modify it for conversion\\n\\t\\tdataTypes = s.dataTypes.slice();\\n\\n\\t// Create converters map with lowercased keys\\n\\tif ( dataTypes[ 1 ] ) {\\n\\t\\tfor ( conv in s.converters ) {\\n\\t\\t\\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\\n\\t\\t}\\n\\t}\\n\\n\\tcurrent = dataTypes.shift();\\n\\n\\t// Convert to each sequential dataType\\n\\twhile ( current ) {\\n\\n\\t\\tif ( s.responseFields[ current ] ) {\\n\\t\\t\\tjqXHR[ s.responseFields[ current ] ] = response;\\n\\t\\t}\\n\\n\\t\\t// Apply the dataFilter if provided\\n\\t\\tif ( !prev && isSuccess && s.dataFilter ) {\\n\\t\\t\\tresponse = s.dataFilter( response, s.dataType );\\n\\t\\t}\\n\\n\\t\\tprev = current;\\n\\t\\tcurrent = dataTypes.shift();\\n\\n\\t\\tif ( current ) {\\n\\n\\t\\t\\t// There\\'s only work to do if current dataType is non-auto\\n\\t\\t\\tif ( current === \"*\" ) {\\n\\n\\t\\t\\t\\tcurrent = prev;\\n\\n\\t\\t\\t// Convert response if prev dataType is non-auto and differs from current\\n\\t\\t\\t} else if ( prev !== \"*\" && prev !== current ) {\\n\\n\\t\\t\\t\\t// Seek a direct converter\\n\\t\\t\\t\\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\\n\\n\\t\\t\\t\\t// If none found, seek a pair\\n\\t\\t\\t\\tif ( !conv ) {\\n\\t\\t\\t\\t\\tfor ( conv2 in converters ) {\\n\\n\\t\\t\\t\\t\\t\\t// If conv2 outputs current\\n\\t\\t\\t\\t\\t\\ttmp = conv2.split( \" \" );\\n\\t\\t\\t\\t\\t\\tif ( tmp[ 1 ] === current ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// If prev can be converted to accepted input\\n\\t\\t\\t\\t\\t\\t\\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\tconverters[ \"* \" + tmp[ 0 ] ];\\n\\t\\t\\t\\t\\t\\t\\tif ( conv ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Condense equivalence converters\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( conv === true ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tconv = converters[ conv2 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Otherwise, insert the intermediate dataType\\n\\t\\t\\t\\t\\t\\t\\t\\t} else if ( converters[ conv2 ] !== true ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcurrent = tmp[ 0 ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdataTypes.unshift( tmp[ 1 ] );\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Apply converter (if not an equivalence)\\n\\t\\t\\t\\tif ( conv !== true ) {\\n\\n\\t\\t\\t\\t\\t// Unless errors are allowed to bubble, catch and return them\\n\\t\\t\\t\\t\\tif ( conv && s.throws ) {\\n\\t\\t\\t\\t\\t\\tresponse = conv( response );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\tresponse = conv( response );\\n\\t\\t\\t\\t\\t\\t} catch ( e ) {\\n\\t\\t\\t\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\t\\t\\tstate: \"parsererror\",\\n\\t\\t\\t\\t\\t\\t\\t\\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn { state: \"success\", data: response };\\n}\\n\\njQuery.extend( {\\n\\n\\t// Counter for holding the number of active queries\\n\\tactive: 0,\\n\\n\\t// Last-Modified header cache for next request\\n\\tlastModified: {},\\n\\tetag: {},\\n\\n\\tajaxSettings: {\\n\\t\\turl: location.href,\\n\\t\\ttype: \"GET\",\\n\\t\\tisLocal: rlocalProtocol.test( location.protocol ),\\n\\t\\tglobal: true,\\n\\t\\tprocessData: true,\\n\\t\\tasync: true,\\n\\t\\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\\n\\n\\t\\t/*\\n\\t\\ttimeout: 0,\\n\\t\\tdata: null,\\n\\t\\tdataType: null,\\n\\t\\tusername: null,\\n\\t\\tpassword: null,\\n\\t\\tcache: null,\\n\\t\\tthrows: false,\\n\\t\\ttraditional: false,\\n\\t\\theaders: {},\\n\\t\\t*/\\n\\n\\t\\taccepts: {\\n\\t\\t\\t\"*\": allTypes,\\n\\t\\t\\ttext: \"text/plain\",\\n\\t\\t\\thtml: \"text/html\",\\n\\t\\t\\txml: \"application/xml, text/xml\",\\n\\t\\t\\tjson: \"application/json, text/javascript\"\\n\\t\\t},\\n\\n\\t\\tcontents: {\\n\\t\\t\\txml: /\\\\bxml\\\\b/,\\n\\t\\t\\thtml: /\\\\bhtml/,\\n\\t\\t\\tjson: /\\\\bjson\\\\b/\\n\\t\\t},\\n\\n\\t\\tresponseFields: {\\n\\t\\t\\txml: \"responseXML\",\\n\\t\\t\\ttext: \"responseText\",\\n\\t\\t\\tjson: \"responseJSON\"\\n\\t\\t},\\n\\n\\t\\t// Data converters\\n\\t\\t// Keys separate source (or catchall \"*\") and destination types with a single space\\n\\t\\tconverters: {\\n\\n\\t\\t\\t// Convert anything to text\\n\\t\\t\\t\"* text\": String,\\n\\n\\t\\t\\t// Text to html (true = no transformation)\\n\\t\\t\\t\"text html\": true,\\n\\n\\t\\t\\t// Evaluate text as a json expression\\n\\t\\t\\t\"text json\": JSON.parse,\\n\\n\\t\\t\\t// Parse text as xml\\n\\t\\t\\t\"text xml\": jQuery.parseXML\\n\\t\\t},\\n\\n\\t\\t// For options that shouldn\\'t be deep extended:\\n\\t\\t// you can add your own custom options here if\\n\\t\\t// and when you create one that shouldn\\'t be\\n\\t\\t// deep extended (see ajaxExtend)\\n\\t\\tflatOptions: {\\n\\t\\t\\turl: true,\\n\\t\\t\\tcontext: true\\n\\t\\t}\\n\\t},\\n\\n\\t// Creates a full fledged settings object into target\\n\\t// with both ajaxSettings and settings fields.\\n\\t// If target is omitted, writes into ajaxSettings.\\n\\tajaxSetup: function( target, settings ) {\\n\\t\\treturn settings ?\\n\\n\\t\\t\\t// Building a settings object\\n\\t\\t\\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\\n\\n\\t\\t\\t// Extending ajaxSettings\\n\\t\\t\\tajaxExtend( jQuery.ajaxSettings, target );\\n\\t},\\n\\n\\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\\n\\tajaxTransport: addToPrefiltersOrTransports( transports ),\\n\\n\\t// Main method\\n\\tajax: function( url, options ) {\\n\\n\\t\\t// If url is an object, simulate pre-1.5 signature\\n\\t\\tif ( typeof url === \"object\" ) {\\n\\t\\t\\toptions = url;\\n\\t\\t\\turl = undefined;\\n\\t\\t}\\n\\n\\t\\t// Force options to be an object\\n\\t\\toptions = options || {};\\n\\n\\t\\tvar transport,\\n\\n\\t\\t\\t// URL without anti-cache param\\n\\t\\t\\tcacheURL,\\n\\n\\t\\t\\t// Response headers\\n\\t\\t\\tresponseHeadersString,\\n\\t\\t\\tresponseHeaders,\\n\\n\\t\\t\\t// timeout handle\\n\\t\\t\\ttimeoutTimer,\\n\\n\\t\\t\\t// Url cleanup var\\n\\t\\t\\turlAnchor,\\n\\n\\t\\t\\t// Request state (becomes false upon send and true upon completion)\\n\\t\\t\\tcompleted,\\n\\n\\t\\t\\t// To know if global events are to be dispatched\\n\\t\\t\\tfireGlobals,\\n\\n\\t\\t\\t// Loop variable\\n\\t\\t\\ti,\\n\\n\\t\\t\\t// uncached part of the url\\n\\t\\t\\tuncached,\\n\\n\\t\\t\\t// Create the final options object\\n\\t\\t\\ts = jQuery.ajaxSetup( {}, options ),\\n\\n\\t\\t\\t// Callbacks context\\n\\t\\t\\tcallbackContext = s.context || s,\\n\\n\\t\\t\\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\\n\\t\\t\\tglobalEventContext = s.context &&\\n\\t\\t\\t\\t( callbackContext.nodeType || callbackContext.jquery ) ?\\n\\t\\t\\t\\t\\tjQuery( callbackContext ) :\\n\\t\\t\\t\\t\\tjQuery.event,\\n\\n\\t\\t\\t// Deferreds\\n\\t\\t\\tdeferred = jQuery.Deferred(),\\n\\t\\t\\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\\n\\n\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\tstatusCode = s.statusCode || {},\\n\\n\\t\\t\\t// Headers (they are sent all at once)\\n\\t\\t\\trequestHeaders = {},\\n\\t\\t\\trequestHeadersNames = {},\\n\\n\\t\\t\\t// Default abort message\\n\\t\\t\\tstrAbort = \"canceled\",\\n\\n\\t\\t\\t// Fake xhr\\n\\t\\t\\tjqXHR = {\\n\\t\\t\\t\\treadyState: 0,\\n\\n\\t\\t\\t\\t// Builds headers hashtable if needed\\n\\t\\t\\t\\tgetResponseHeader: function( key ) {\\n\\t\\t\\t\\t\\tvar match;\\n\\t\\t\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\t\\t\\tif ( !responseHeaders ) {\\n\\t\\t\\t\\t\\t\\t\\tresponseHeaders = {};\\n\\t\\t\\t\\t\\t\\t\\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tmatch = responseHeaders[ key.toLowerCase() ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn match == null ? null : match;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Raw string\\n\\t\\t\\t\\tgetAllResponseHeaders: function() {\\n\\t\\t\\t\\t\\treturn completed ? responseHeadersString : null;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Caches the header\\n\\t\\t\\t\\tsetRequestHeader: function( name, value ) {\\n\\t\\t\\t\\t\\tif ( completed == null ) {\\n\\t\\t\\t\\t\\t\\tname = requestHeadersNames[ name.toLowerCase() ] =\\n\\t\\t\\t\\t\\t\\t\\trequestHeadersNames[ name.toLowerCase() ] || name;\\n\\t\\t\\t\\t\\t\\trequestHeaders[ name ] = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Overrides response content-type header\\n\\t\\t\\t\\toverrideMimeType: function( type ) {\\n\\t\\t\\t\\t\\tif ( completed == null ) {\\n\\t\\t\\t\\t\\t\\ts.mimeType = type;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\t\\tstatusCode: function( map ) {\\n\\t\\t\\t\\t\\tvar code;\\n\\t\\t\\t\\t\\tif ( map ) {\\n\\t\\t\\t\\t\\t\\tif ( completed ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Execute the appropriate callbacks\\n\\t\\t\\t\\t\\t\\t\\tjqXHR.always( map[ jqXHR.status ] );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Lazy-add the new callbacks in a way that preserves old ones\\n\\t\\t\\t\\t\\t\\t\\tfor ( code in map ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\t// Cancel the request\\n\\t\\t\\t\\tabort: function( statusText ) {\\n\\t\\t\\t\\t\\tvar finalText = statusText || strAbort;\\n\\t\\t\\t\\t\\tif ( transport ) {\\n\\t\\t\\t\\t\\t\\ttransport.abort( finalText );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdone( 0, finalText );\\n\\t\\t\\t\\t\\treturn this;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t// Attach deferreds\\n\\t\\tdeferred.promise( jqXHR );\\n\\n\\t\\t// Add protocol if not provided (prefilters might expect it)\\n\\t\\t// Handle falsy url in the settings object (#10093: consistency with old signature)\\n\\t\\t// We also use the url parameter if available\\n\\t\\ts.url = ( ( url || s.url || location.href ) + \"\" )\\n\\t\\t\\t.replace( rprotocol, location.protocol + \"//\" );\\n\\n\\t\\t// Alias method option to type as per ticket #12004\\n\\t\\ts.type = options.method || options.type || s.method || s.type;\\n\\n\\t\\t// Extract dataTypes list\\n\\t\\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\\n\\n\\t\\t// A cross-domain request is in order when the origin doesn\\'t match the current origin.\\n\\t\\tif ( s.crossDomain == null ) {\\n\\t\\t\\turlAnchor = document.createElement( \"a\" );\\n\\n\\t\\t\\t// Support: IE <=8 - 11, Edge 12 - 15\\n\\t\\t\\t// IE throws exception on accessing the href property if url is malformed,\\n\\t\\t\\t// e.g. http://example.com:80x/\\n\\t\\t\\ttry {\\n\\t\\t\\t\\turlAnchor.href = s.url;\\n\\n\\t\\t\\t\\t// Support: IE <=8 - 11 only\\n\\t\\t\\t\\t// Anchor\\'s host property isn\\'t correctly set when s.url is relative\\n\\t\\t\\t\\turlAnchor.href = urlAnchor.href;\\n\\t\\t\\t\\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\\n\\t\\t\\t\\t\\turlAnchor.protocol + \"//\" + urlAnchor.host;\\n\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t// If there is an error parsing the URL, assume it is crossDomain,\\n\\t\\t\\t\\t// it can be rejected by the transport if it is invalid\\n\\t\\t\\t\\ts.crossDomain = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Convert data if not already a string\\n\\t\\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\\n\\t\\t\\ts.data = jQuery.param( s.data, s.traditional );\\n\\t\\t}\\n\\n\\t\\t// Apply prefilters\\n\\t\\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\\n\\n\\t\\t// If request was aborted inside a prefilter, stop there\\n\\t\\tif ( completed ) {\\n\\t\\t\\treturn jqXHR;\\n\\t\\t}\\n\\n\\t\\t// We can fire global events as of now if asked to\\n\\t\\t// Don\\'t fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\\n\\t\\tfireGlobals = jQuery.event && s.global;\\n\\n\\t\\t// Watch for a new set of requests\\n\\t\\tif ( fireGlobals && jQuery.active++ === 0 ) {\\n\\t\\t\\tjQuery.event.trigger( \"ajaxStart\" );\\n\\t\\t}\\n\\n\\t\\t// Uppercase the type\\n\\t\\ts.type = s.type.toUpperCase();\\n\\n\\t\\t// Determine if request has content\\n\\t\\ts.hasContent = !rnoContent.test( s.type );\\n\\n\\t\\t// Save the URL in case we\\'re toying with the If-Modified-Since\\n\\t\\t// and/or If-None-Match header later on\\n\\t\\t// Remove hash to simplify url manipulation\\n\\t\\tcacheURL = s.url.replace( rhash, \"\" );\\n\\n\\t\\t// More options handling for requests with no content\\n\\t\\tif ( !s.hasContent ) {\\n\\n\\t\\t\\t// Remember the hash so we can put it back\\n\\t\\t\\tuncached = s.url.slice( cacheURL.length );\\n\\n\\t\\t\\t// If data is available and should be processed, append data to url\\n\\t\\t\\tif ( s.data && ( s.processData || typeof s.data === \"string\" ) ) {\\n\\t\\t\\t\\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\\n\\n\\t\\t\\t\\t// #9682: remove data so that it\\'s not used in an eventual retry\\n\\t\\t\\t\\tdelete s.data;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Add or update anti-cache param if needed\\n\\t\\t\\tif ( s.cache === false ) {\\n\\t\\t\\t\\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\\n\\t\\t\\t\\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\\n\\t\\t\\ts.url = cacheURL + uncached;\\n\\n\\t\\t// Change \\'%20\\' to \\'+\\' if this is encoded form body content (gh-2658)\\n\\t\\t} else if ( s.data && s.processData &&\\n\\t\\t\\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\\n\\t\\t\\ts.data = s.data.replace( r20, \"+\" );\\n\\t\\t}\\n\\n\\t\\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\\n\\t\\tif ( s.ifModified ) {\\n\\t\\t\\tif ( jQuery.lastModified[ cacheURL ] ) {\\n\\t\\t\\t\\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\\n\\t\\t\\t}\\n\\t\\t\\tif ( jQuery.etag[ cacheURL ] ) {\\n\\t\\t\\t\\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Set the correct header, if data is being sent\\n\\t\\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\\n\\t\\t\\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\\n\\t\\t}\\n\\n\\t\\t// Set the Accepts header for the server, depending on the dataType\\n\\t\\tjqXHR.setRequestHeader(\\n\\t\\t\\t\"Accept\",\\n\\t\\t\\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\\n\\t\\t\\t\\ts.accepts[ s.dataTypes[ 0 ] ] +\\n\\t\\t\\t\\t\\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\\n\\t\\t\\t\\ts.accepts[ \"*\" ]\\n\\t\\t);\\n\\n\\t\\t// Check for headers option\\n\\t\\tfor ( i in s.headers ) {\\n\\t\\t\\tjqXHR.setRequestHeader( i, s.headers[ i ] );\\n\\t\\t}\\n\\n\\t\\t// Allow custom headers/mimetypes and early abort\\n\\t\\tif ( s.beforeSend &&\\n\\t\\t\\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\\n\\n\\t\\t\\t// Abort if not done already and return\\n\\t\\t\\treturn jqXHR.abort();\\n\\t\\t}\\n\\n\\t\\t// Aborting is no longer a cancellation\\n\\t\\tstrAbort = \"abort\";\\n\\n\\t\\t// Install callbacks on deferreds\\n\\t\\tcompleteDeferred.add( s.complete );\\n\\t\\tjqXHR.done( s.success );\\n\\t\\tjqXHR.fail( s.error );\\n\\n\\t\\t// Get transport\\n\\t\\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\\n\\n\\t\\t// If no transport, we auto-abort\\n\\t\\tif ( !transport ) {\\n\\t\\t\\tdone( -1, \"No Transport\" );\\n\\t\\t} else {\\n\\t\\t\\tjqXHR.readyState = 1;\\n\\n\\t\\t\\t// Send global event\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If request was aborted inside ajaxSend, stop there\\n\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\treturn jqXHR;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Timeout\\n\\t\\t\\tif ( s.async && s.timeout > 0 ) {\\n\\t\\t\\t\\ttimeoutTimer = window.setTimeout( function() {\\n\\t\\t\\t\\t\\tjqXHR.abort( \"timeout\" );\\n\\t\\t\\t\\t}, s.timeout );\\n\\t\\t\\t}\\n\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tcompleted = false;\\n\\t\\t\\t\\ttransport.send( requestHeaders, done );\\n\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t// Rethrow post-completion exceptions\\n\\t\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\t\\tthrow e;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Propagate others as results\\n\\t\\t\\t\\tdone( -1, e );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Callback for when everything is done\\n\\t\\tfunction done( status, nativeStatusText, responses, headers ) {\\n\\t\\t\\tvar isSuccess, success, error, response, modified,\\n\\t\\t\\t\\tstatusText = nativeStatusText;\\n\\n\\t\\t\\t// Ignore repeat invocations\\n\\t\\t\\tif ( completed ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tcompleted = true;\\n\\n\\t\\t\\t// Clear timeout if it exists\\n\\t\\t\\tif ( timeoutTimer ) {\\n\\t\\t\\t\\twindow.clearTimeout( timeoutTimer );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Dereference transport for early garbage collection\\n\\t\\t\\t// (no matter how long the jqXHR object will be used)\\n\\t\\t\\ttransport = undefined;\\n\\n\\t\\t\\t// Cache response headers\\n\\t\\t\\tresponseHeadersString = headers || \"\";\\n\\n\\t\\t\\t// Set readyState\\n\\t\\t\\tjqXHR.readyState = status > 0 ? 4 : 0;\\n\\n\\t\\t\\t// Determine if successful\\n\\t\\t\\tisSuccess = status >= 200 && status < 300 || status === 304;\\n\\n\\t\\t\\t// Get response data\\n\\t\\t\\tif ( responses ) {\\n\\t\\t\\t\\tresponse = ajaxHandleResponses( s, jqXHR, responses );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Convert no matter what (that way responseXXX fields are always set)\\n\\t\\t\\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\\n\\n\\t\\t\\t// If successful, handle type chaining\\n\\t\\t\\tif ( isSuccess ) {\\n\\n\\t\\t\\t\\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\\n\\t\\t\\t\\tif ( s.ifModified ) {\\n\\t\\t\\t\\t\\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\\n\\t\\t\\t\\t\\tif ( modified ) {\\n\\t\\t\\t\\t\\t\\tjQuery.lastModified[ cacheURL ] = modified;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmodified = jqXHR.getResponseHeader( \"etag\" );\\n\\t\\t\\t\\t\\tif ( modified ) {\\n\\t\\t\\t\\t\\t\\tjQuery.etag[ cacheURL ] = modified;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if no content\\n\\t\\t\\t\\tif ( status === 204 || s.type === \"HEAD\" ) {\\n\\t\\t\\t\\t\\tstatusText = \"nocontent\";\\n\\n\\t\\t\\t\\t// if not modified\\n\\t\\t\\t\\t} else if ( status === 304 ) {\\n\\t\\t\\t\\t\\tstatusText = \"notmodified\";\\n\\n\\t\\t\\t\\t// If we have data, let\\'s convert it\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tstatusText = response.state;\\n\\t\\t\\t\\t\\tsuccess = response.data;\\n\\t\\t\\t\\t\\terror = response.error;\\n\\t\\t\\t\\t\\tisSuccess = !error;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Extract error from statusText and normalize for non-aborts\\n\\t\\t\\t\\terror = statusText;\\n\\t\\t\\t\\tif ( status || !statusText ) {\\n\\t\\t\\t\\t\\tstatusText = \"error\";\\n\\t\\t\\t\\t\\tif ( status < 0 ) {\\n\\t\\t\\t\\t\\t\\tstatus = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Set data for the fake xhr object\\n\\t\\t\\tjqXHR.status = status;\\n\\t\\t\\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\\n\\n\\t\\t\\t// Success/Error\\n\\t\\t\\tif ( isSuccess ) {\\n\\t\\t\\t\\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Status-dependent callbacks\\n\\t\\t\\tjqXHR.statusCode( statusCode );\\n\\t\\t\\tstatusCode = undefined;\\n\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\\n\\t\\t\\t\\t\\t[ jqXHR, s, isSuccess ? success : error ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Complete\\n\\t\\t\\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\\n\\n\\t\\t\\tif ( fireGlobals ) {\\n\\t\\t\\t\\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\\n\\n\\t\\t\\t\\t// Handle the global AJAX counter\\n\\t\\t\\t\\tif ( !( --jQuery.active ) ) {\\n\\t\\t\\t\\t\\tjQuery.event.trigger( \"ajaxStop\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn jqXHR;\\n\\t},\\n\\n\\tgetJSON: function( url, data, callback ) {\\n\\t\\treturn jQuery.get( url, data, callback, \"json\" );\\n\\t},\\n\\n\\tgetScript: function( url, callback ) {\\n\\t\\treturn jQuery.get( url, undefined, callback, \"script\" );\\n\\t}\\n} );\\n\\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\\n\\tjQuery[ method ] = function( url, data, callback, type ) {\\n\\n\\t\\t// Shift arguments if data argument was omitted\\n\\t\\tif ( isFunction( data ) ) {\\n\\t\\t\\ttype = type || callback;\\n\\t\\t\\tcallback = data;\\n\\t\\t\\tdata = undefined;\\n\\t\\t}\\n\\n\\t\\t// The url can be an options object (which then must have .url)\\n\\t\\treturn jQuery.ajax( jQuery.extend( {\\n\\t\\t\\turl: url,\\n\\t\\t\\ttype: method,\\n\\t\\t\\tdataType: type,\\n\\t\\t\\tdata: data,\\n\\t\\t\\tsuccess: callback\\n\\t\\t}, jQuery.isPlainObject( url ) && url ) );\\n\\t};\\n} );\\n\\n\\njQuery._evalUrl = function( url ) {\\n\\treturn jQuery.ajax( {\\n\\t\\turl: url,\\n\\n\\t\\t// Make this explicit, since user can override this through ajaxSetup (#11264)\\n\\t\\ttype: \"GET\",\\n\\t\\tdataType: \"script\",\\n\\t\\tcache: true,\\n\\t\\tasync: false,\\n\\t\\tglobal: false,\\n\\t\\t\"throws\": true\\n\\t} );\\n};\\n\\n\\njQuery.fn.extend( {\\n\\twrapAll: function( html ) {\\n\\t\\tvar wrap;\\n\\n\\t\\tif ( this[ 0 ] ) {\\n\\t\\t\\tif ( isFunction( html ) ) {\\n\\t\\t\\t\\thtml = html.call( this[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// The elements to wrap the target around\\n\\t\\t\\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\\n\\n\\t\\t\\tif ( this[ 0 ].parentNode ) {\\n\\t\\t\\t\\twrap.insertBefore( this[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\twrap.map( function() {\\n\\t\\t\\t\\tvar elem = this;\\n\\n\\t\\t\\t\\twhile ( elem.firstElementChild ) {\\n\\t\\t\\t\\t\\telem = elem.firstElementChild;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn elem;\\n\\t\\t\\t} ).append( this );\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\twrapInner: function( html ) {\\n\\t\\tif ( isFunction( html ) ) {\\n\\t\\t\\treturn this.each( function( i ) {\\n\\t\\t\\t\\tjQuery( this ).wrapInner( html.call( this, i ) );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\treturn this.each( function() {\\n\\t\\t\\tvar self = jQuery( this ),\\n\\t\\t\\t\\tcontents = self.contents();\\n\\n\\t\\t\\tif ( contents.length ) {\\n\\t\\t\\t\\tcontents.wrapAll( html );\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tself.append( html );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t},\\n\\n\\twrap: function( html ) {\\n\\t\\tvar htmlIsFunction = isFunction( html );\\n\\n\\t\\treturn this.each( function( i ) {\\n\\t\\t\\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\\n\\t\\t} );\\n\\t},\\n\\n\\tunwrap: function( selector ) {\\n\\t\\tthis.parent( selector ).not( \"body\" ).each( function() {\\n\\t\\t\\tjQuery( this ).replaceWith( this.childNodes );\\n\\t\\t} );\\n\\t\\treturn this;\\n\\t}\\n} );\\n\\n\\njQuery.expr.pseudos.hidden = function( elem ) {\\n\\treturn !jQuery.expr.pseudos.visible( elem );\\n};\\njQuery.expr.pseudos.visible = function( elem ) {\\n\\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\\n};\\n\\n\\n\\n\\njQuery.ajaxSettings.xhr = function() {\\n\\ttry {\\n\\t\\treturn new window.XMLHttpRequest();\\n\\t} catch ( e ) {}\\n};\\n\\nvar xhrSuccessStatus = {\\n\\n\\t\\t// File protocol always yields status code 0, assume 200\\n\\t\\t0: 200,\\n\\n\\t\\t// Support: IE <=9 only\\n\\t\\t// #1450: sometimes IE returns 1223 when it should be 204\\n\\t\\t1223: 204\\n\\t},\\n\\txhrSupported = jQuery.ajaxSettings.xhr();\\n\\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\\nsupport.ajax = xhrSupported = !!xhrSupported;\\n\\njQuery.ajaxTransport( function( options ) {\\n\\tvar callback, errorCallback;\\n\\n\\t// Cross domain only allowed if supported through XMLHttpRequest\\n\\tif ( support.cors || xhrSupported && !options.crossDomain ) {\\n\\t\\treturn {\\n\\t\\t\\tsend: function( headers, complete ) {\\n\\t\\t\\t\\tvar i,\\n\\t\\t\\t\\t\\txhr = options.xhr();\\n\\n\\t\\t\\t\\txhr.open(\\n\\t\\t\\t\\t\\toptions.type,\\n\\t\\t\\t\\t\\toptions.url,\\n\\t\\t\\t\\t\\toptions.async,\\n\\t\\t\\t\\t\\toptions.username,\\n\\t\\t\\t\\t\\toptions.password\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t// Apply custom fields if provided\\n\\t\\t\\t\\tif ( options.xhrFields ) {\\n\\t\\t\\t\\t\\tfor ( i in options.xhrFields ) {\\n\\t\\t\\t\\t\\t\\txhr[ i ] = options.xhrFields[ i ];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Override mime type if needed\\n\\t\\t\\t\\tif ( options.mimeType && xhr.overrideMimeType ) {\\n\\t\\t\\t\\t\\txhr.overrideMimeType( options.mimeType );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// X-Requested-With header\\n\\t\\t\\t\\t// For cross-domain requests, seeing as conditions for a preflight are\\n\\t\\t\\t\\t// akin to a jigsaw puzzle, we simply never set it to be sure.\\n\\t\\t\\t\\t// (it can always be set on a per-request basis or even using ajaxSetup)\\n\\t\\t\\t\\t// For same-domain requests, won\\'t change header if already provided.\\n\\t\\t\\t\\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\\n\\t\\t\\t\\t\\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Set headers\\n\\t\\t\\t\\tfor ( i in headers ) {\\n\\t\\t\\t\\t\\txhr.setRequestHeader( i, headers[ i ] );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Callback\\n\\t\\t\\t\\tcallback = function( type ) {\\n\\t\\t\\t\\t\\treturn function() {\\n\\t\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\t\\tcallback = errorCallback = xhr.onload =\\n\\t\\t\\t\\t\\t\\t\\t\\txhr.onerror = xhr.onabort = xhr.ontimeout =\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.onreadystatechange = null;\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( type === \"abort\" ) {\\n\\t\\t\\t\\t\\t\\t\\t\\txhr.abort();\\n\\t\\t\\t\\t\\t\\t\\t} else if ( type === \"error\" ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t// On a manual native abort, IE9 throws\\n\\t\\t\\t\\t\\t\\t\\t\\t// errors on any property access that is not readyState\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( typeof xhr.status !== \"number\" ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcomplete( 0, \"error\" );\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcomplete(\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// File: protocol always yields status 0; see #8605, #14207\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.status,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.statusText\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tcomplete(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhrSuccessStatus[ xhr.status ] || xhr.status,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.statusText,\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Support: IE <=9 only\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// IE9 has no XHR2 but throws on binary (trac-11426)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// For XHR2 non-text, let the caller handle it (gh-2498)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t( xhr.responseType || \"text\" ) !== \"text\"  ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttypeof xhr.responseText !== \"string\" ?\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{ binary: xhr.response } :\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t{ text: xhr.responseText },\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txhr.getAllResponseHeaders()\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t// Listen to events\\n\\t\\t\\t\\txhr.onload = callback();\\n\\t\\t\\t\\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \"error\" );\\n\\n\\t\\t\\t\\t// Support: IE 9 only\\n\\t\\t\\t\\t// Use onreadystatechange to replace onabort\\n\\t\\t\\t\\t// to handle uncaught aborts\\n\\t\\t\\t\\tif ( xhr.onabort !== undefined ) {\\n\\t\\t\\t\\t\\txhr.onabort = errorCallback;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\txhr.onreadystatechange = function() {\\n\\n\\t\\t\\t\\t\\t\\t// Check readyState before timeout as it changes\\n\\t\\t\\t\\t\\t\\tif ( xhr.readyState === 4 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Allow onerror to be called first,\\n\\t\\t\\t\\t\\t\\t\\t// but that will not handle a native abort\\n\\t\\t\\t\\t\\t\\t\\t// Also, save errorCallback to a variable\\n\\t\\t\\t\\t\\t\\t\\t// as xhr.onerror cannot be accessed\\n\\t\\t\\t\\t\\t\\t\\twindow.setTimeout( function() {\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\terrorCallback();\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Create the abort callback\\n\\t\\t\\t\\tcallback = callback( \"abort\" );\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\t// Do send the request (this may raise an exception)\\n\\t\\t\\t\\t\\txhr.send( options.hasContent && options.data || null );\\n\\t\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t\\t// #14683: Only rethrow if this hasn\\'t been notified as an error yet\\n\\t\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\t\\tthrow e;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\tabort: function() {\\n\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\\njQuery.ajaxPrefilter( function( s ) {\\n\\tif ( s.crossDomain ) {\\n\\t\\ts.contents.script = false;\\n\\t}\\n} );\\n\\n// Install script dataType\\njQuery.ajaxSetup( {\\n\\taccepts: {\\n\\t\\tscript: \"text/javascript, application/javascript, \" +\\n\\t\\t\\t\"application/ecmascript, application/x-ecmascript\"\\n\\t},\\n\\tcontents: {\\n\\t\\tscript: /\\\\b(?:java|ecma)script\\\\b/\\n\\t},\\n\\tconverters: {\\n\\t\\t\"text script\": function( text ) {\\n\\t\\t\\tjQuery.globalEval( text );\\n\\t\\t\\treturn text;\\n\\t\\t}\\n\\t}\\n} );\\n\\n// Handle cache\\'s special case and crossDomain\\njQuery.ajaxPrefilter( \"script\", function( s ) {\\n\\tif ( s.cache === undefined ) {\\n\\t\\ts.cache = false;\\n\\t}\\n\\tif ( s.crossDomain ) {\\n\\t\\ts.type = \"GET\";\\n\\t}\\n} );\\n\\n// Bind script tag hack transport\\njQuery.ajaxTransport( \"script\", function( s ) {\\n\\n\\t// This transport only deals with cross domain requests\\n\\tif ( s.crossDomain ) {\\n\\t\\tvar script, callback;\\n\\t\\treturn {\\n\\t\\t\\tsend: function( _, complete ) {\\n\\t\\t\\t\\tscript = jQuery( \"<script>\" ).prop( {\\n\\t\\t\\t\\t\\tcharset: s.scriptCharset,\\n\\t\\t\\t\\t\\tsrc: s.url\\n\\t\\t\\t\\t} ).on(\\n\\t\\t\\t\\t\\t\"load error\",\\n\\t\\t\\t\\t\\tcallback = function( evt ) {\\n\\t\\t\\t\\t\\t\\tscript.remove();\\n\\t\\t\\t\\t\\t\\tcallback = null;\\n\\t\\t\\t\\t\\t\\tif ( evt ) {\\n\\t\\t\\t\\t\\t\\t\\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t// Use native DOM manipulation to avoid our domManip AJAX trickery\\n\\t\\t\\t\\tdocument.head.appendChild( script[ 0 ] );\\n\\t\\t\\t},\\n\\t\\t\\tabort: function() {\\n\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n} );\\n\\n\\n\\n\\nvar oldCallbacks = [],\\n\\trjsonp = /(=)\\\\?(?=&|$)|\\\\?\\\\?/;\\n\\n// Default jsonp settings\\njQuery.ajaxSetup( {\\n\\tjsonp: \"callback\",\\n\\tjsonpCallback: function() {\\n\\t\\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\\n\\t\\tthis[ callback ] = true;\\n\\t\\treturn callback;\\n\\t}\\n} );\\n\\n// Detect, normalize options and install callbacks for jsonp requests\\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\\n\\n\\tvar callbackName, overwritten, responseContainer,\\n\\t\\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\\n\\t\\t\\t\"url\" :\\n\\t\\t\\ttypeof s.data === \"string\" &&\\n\\t\\t\\t\\t( s.contentType || \"\" )\\n\\t\\t\\t\\t\\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\\n\\t\\t\\t\\trjsonp.test( s.data ) && \"data\"\\n\\t\\t);\\n\\n\\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\\n\\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\\n\\n\\t\\t// Get callback name, remembering preexisting value associated with it\\n\\t\\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\\n\\t\\t\\ts.jsonpCallback() :\\n\\t\\t\\ts.jsonpCallback;\\n\\n\\t\\t// Insert callback into url or form data\\n\\t\\tif ( jsonProp ) {\\n\\t\\t\\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\\n\\t\\t} else if ( s.jsonp !== false ) {\\n\\t\\t\\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\\n\\t\\t}\\n\\n\\t\\t// Use data converter to retrieve json after script execution\\n\\t\\ts.converters[ \"script json\" ] = function() {\\n\\t\\t\\tif ( !responseContainer ) {\\n\\t\\t\\t\\tjQuery.error( callbackName + \" was not called\" );\\n\\t\\t\\t}\\n\\t\\t\\treturn responseContainer[ 0 ];\\n\\t\\t};\\n\\n\\t\\t// Force json dataType\\n\\t\\ts.dataTypes[ 0 ] = \"json\";\\n\\n\\t\\t// Install callback\\n\\t\\toverwritten = window[ callbackName ];\\n\\t\\twindow[ callbackName ] = function() {\\n\\t\\t\\tresponseContainer = arguments;\\n\\t\\t};\\n\\n\\t\\t// Clean-up function (fires after converters)\\n\\t\\tjqXHR.always( function() {\\n\\n\\t\\t\\t// If previous value didn\\'t exist - remove it\\n\\t\\t\\tif ( overwritten === undefined ) {\\n\\t\\t\\t\\tjQuery( window ).removeProp( callbackName );\\n\\n\\t\\t\\t// Otherwise restore preexisting value\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twindow[ callbackName ] = overwritten;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Save back as free\\n\\t\\t\\tif ( s[ callbackName ] ) {\\n\\n\\t\\t\\t\\t// Make sure that re-using the options doesn\\'t screw things around\\n\\t\\t\\t\\ts.jsonpCallback = originalSettings.jsonpCallback;\\n\\n\\t\\t\\t\\t// Save the callback name for future use\\n\\t\\t\\t\\toldCallbacks.push( callbackName );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Call if it was a function and we have a response\\n\\t\\t\\tif ( responseContainer && isFunction( overwritten ) ) {\\n\\t\\t\\t\\toverwritten( responseContainer[ 0 ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\tresponseContainer = overwritten = undefined;\\n\\t\\t} );\\n\\n\\t\\t// Delegate to script\\n\\t\\treturn \"script\";\\n\\t}\\n} );\\n\\n\\n\\n\\n// Support: Safari 8 only\\n// In Safari 8 documents created via document.implementation.createHTMLDocument\\n// collapse sibling forms: the second one becomes a child of the first one.\\n// Because of that, this security measure has to be disabled in Safari 8.\\n// https://bugs.webkit.org/show_bug.cgi?id=137337\\nsupport.createHTMLDocument = ( function() {\\n\\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\\n\\tbody.innerHTML = \"<form></form><form></form>\";\\n\\treturn body.childNodes.length === 2;\\n} )();\\n\\n\\n// Argument \"data\" should be string of html\\n// context (optional): If specified, the fragment will be created in this context,\\n// defaults to document\\n// keepScripts (optional): If true, will include scripts passed in the html string\\njQuery.parseHTML = function( data, context, keepScripts ) {\\n\\tif ( typeof data !== \"string\" ) {\\n\\t\\treturn [];\\n\\t}\\n\\tif ( typeof context === \"boolean\" ) {\\n\\t\\tkeepScripts = context;\\n\\t\\tcontext = false;\\n\\t}\\n\\n\\tvar base, parsed, scripts;\\n\\n\\tif ( !context ) {\\n\\n\\t\\t// Stop scripts or inline event handlers from being executed immediately\\n\\t\\t// by using document.implementation\\n\\t\\tif ( support.createHTMLDocument ) {\\n\\t\\t\\tcontext = document.implementation.createHTMLDocument( \"\" );\\n\\n\\t\\t\\t// Set the base href for the created document\\n\\t\\t\\t// so any parsed elements with URLs\\n\\t\\t\\t// are based on the document\\'s URL (gh-2965)\\n\\t\\t\\tbase = context.createElement( \"base\" );\\n\\t\\t\\tbase.href = document.location.href;\\n\\t\\t\\tcontext.head.appendChild( base );\\n\\t\\t} else {\\n\\t\\t\\tcontext = document;\\n\\t\\t}\\n\\t}\\n\\n\\tparsed = rsingleTag.exec( data );\\n\\tscripts = !keepScripts && [];\\n\\n\\t// Single tag\\n\\tif ( parsed ) {\\n\\t\\treturn [ context.createElement( parsed[ 1 ] ) ];\\n\\t}\\n\\n\\tparsed = buildFragment( [ data ], context, scripts );\\n\\n\\tif ( scripts && scripts.length ) {\\n\\t\\tjQuery( scripts ).remove();\\n\\t}\\n\\n\\treturn jQuery.merge( [], parsed.childNodes );\\n};\\n\\n\\n/**\\n * Load a url into a page\\n */\\njQuery.fn.load = function( url, params, callback ) {\\n\\tvar selector, type, response,\\n\\t\\tself = this,\\n\\t\\toff = url.indexOf( \" \" );\\n\\n\\tif ( off > -1 ) {\\n\\t\\tselector = stripAndCollapse( url.slice( off ) );\\n\\t\\turl = url.slice( 0, off );\\n\\t}\\n\\n\\t// If it\\'s a function\\n\\tif ( isFunction( params ) ) {\\n\\n\\t\\t// We assume that it\\'s the callback\\n\\t\\tcallback = params;\\n\\t\\tparams = undefined;\\n\\n\\t// Otherwise, build a param string\\n\\t} else if ( params && typeof params === \"object\" ) {\\n\\t\\ttype = \"POST\";\\n\\t}\\n\\n\\t// If we have elements to modify, make the request\\n\\tif ( self.length > 0 ) {\\n\\t\\tjQuery.ajax( {\\n\\t\\t\\turl: url,\\n\\n\\t\\t\\t// If \"type\" variable is undefined, then \"GET\" method will be used.\\n\\t\\t\\t// Make value of this field explicit since\\n\\t\\t\\t// user can override it through ajaxSetup method\\n\\t\\t\\ttype: type || \"GET\",\\n\\t\\t\\tdataType: \"html\",\\n\\t\\t\\tdata: params\\n\\t\\t} ).done( function( responseText ) {\\n\\n\\t\\t\\t// Save response for use in complete callback\\n\\t\\t\\tresponse = arguments;\\n\\n\\t\\t\\tself.html( selector ?\\n\\n\\t\\t\\t\\t// If a selector was specified, locate the right elements in a dummy div\\n\\t\\t\\t\\t// Exclude scripts to avoid IE \\'Permission Denied\\' errors\\n\\t\\t\\t\\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\\n\\n\\t\\t\\t\\t// Otherwise use the full result\\n\\t\\t\\t\\tresponseText );\\n\\n\\t\\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\\n\\t\\t// but they are ignored because response was set above.\\n\\t\\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\\n\\t\\t} ).always( callback && function( jqXHR, status ) {\\n\\t\\t\\tself.each( function() {\\n\\t\\t\\t\\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\t}\\n\\n\\treturn this;\\n};\\n\\n\\n\\n\\n// Attach a bunch of functions for handling common AJAX events\\njQuery.each( [\\n\\t\"ajaxStart\",\\n\\t\"ajaxStop\",\\n\\t\"ajaxComplete\",\\n\\t\"ajaxError\",\\n\\t\"ajaxSuccess\",\\n\\t\"ajaxSend\"\\n], function( i, type ) {\\n\\tjQuery.fn[ type ] = function( fn ) {\\n\\t\\treturn this.on( type, fn );\\n\\t};\\n} );\\n\\n\\n\\n\\njQuery.expr.pseudos.animated = function( elem ) {\\n\\treturn jQuery.grep( jQuery.timers, function( fn ) {\\n\\t\\treturn elem === fn.elem;\\n\\t} ).length;\\n};\\n\\n\\n\\n\\njQuery.offset = {\\n\\tsetOffset: function( elem, options, i ) {\\n\\t\\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\\n\\t\\t\\tposition = jQuery.css( elem, \"position\" ),\\n\\t\\t\\tcurElem = jQuery( elem ),\\n\\t\\t\\tprops = {};\\n\\n\\t\\t// Set position first, in-case top/left are set even on static elem\\n\\t\\tif ( position === \"static\" ) {\\n\\t\\t\\telem.style.position = \"relative\";\\n\\t\\t}\\n\\n\\t\\tcurOffset = curElem.offset();\\n\\t\\tcurCSSTop = jQuery.css( elem, \"top\" );\\n\\t\\tcurCSSLeft = jQuery.css( elem, \"left\" );\\n\\t\\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\\n\\t\\t\\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\\n\\n\\t\\t// Need to be able to calculate position if either\\n\\t\\t// top or left is auto and position is either absolute or fixed\\n\\t\\tif ( calculatePosition ) {\\n\\t\\t\\tcurPosition = curElem.position();\\n\\t\\t\\tcurTop = curPosition.top;\\n\\t\\t\\tcurLeft = curPosition.left;\\n\\n\\t\\t} else {\\n\\t\\t\\tcurTop = parseFloat( curCSSTop ) || 0;\\n\\t\\t\\tcurLeft = parseFloat( curCSSLeft ) || 0;\\n\\t\\t}\\n\\n\\t\\tif ( isFunction( options ) ) {\\n\\n\\t\\t\\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\\n\\t\\t\\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\\n\\t\\t}\\n\\n\\t\\tif ( options.top != null ) {\\n\\t\\t\\tprops.top = ( options.top - curOffset.top ) + curTop;\\n\\t\\t}\\n\\t\\tif ( options.left != null ) {\\n\\t\\t\\tprops.left = ( options.left - curOffset.left ) + curLeft;\\n\\t\\t}\\n\\n\\t\\tif ( \"using\" in options ) {\\n\\t\\t\\toptions.using.call( elem, props );\\n\\n\\t\\t} else {\\n\\t\\t\\tcurElem.css( props );\\n\\t\\t}\\n\\t}\\n};\\n\\njQuery.fn.extend( {\\n\\n\\t// offset() relates an element\\'s border box to the document origin\\n\\toffset: function( options ) {\\n\\n\\t\\t// Preserve chaining for setter\\n\\t\\tif ( arguments.length ) {\\n\\t\\t\\treturn options === undefined ?\\n\\t\\t\\t\\tthis :\\n\\t\\t\\t\\tthis.each( function( i ) {\\n\\t\\t\\t\\t\\tjQuery.offset.setOffset( this, options, i );\\n\\t\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tvar rect, win,\\n\\t\\t\\telem = this[ 0 ];\\n\\n\\t\\tif ( !elem ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\\n\\t\\t// Support: IE <=11 only\\n\\t\\t// Running getBoundingClientRect on a\\n\\t\\t// disconnected node in IE throws an error\\n\\t\\tif ( !elem.getClientRects().length ) {\\n\\t\\t\\treturn { top: 0, left: 0 };\\n\\t\\t}\\n\\n\\t\\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\\n\\t\\trect = elem.getBoundingClientRect();\\n\\t\\twin = elem.ownerDocument.defaultView;\\n\\t\\treturn {\\n\\t\\t\\ttop: rect.top + win.pageYOffset,\\n\\t\\t\\tleft: rect.left + win.pageXOffset\\n\\t\\t};\\n\\t},\\n\\n\\t// position() relates an element\\'s margin box to its offset parent\\'s padding box\\n\\t// This corresponds to the behavior of CSS absolute positioning\\n\\tposition: function() {\\n\\t\\tif ( !this[ 0 ] ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar offsetParent, offset, doc,\\n\\t\\t\\telem = this[ 0 ],\\n\\t\\t\\tparentOffset = { top: 0, left: 0 };\\n\\n\\t\\t// position:fixed elements are offset from the viewport, which itself always has zero offset\\n\\t\\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\\n\\n\\t\\t\\t// Assume position:fixed implies availability of getBoundingClientRect\\n\\t\\t\\toffset = elem.getBoundingClientRect();\\n\\n\\t\\t} else {\\n\\t\\t\\toffset = this.offset();\\n\\n\\t\\t\\t// Account for the *real* offset parent, which can be the document or its root element\\n\\t\\t\\t// when a statically positioned element is identified\\n\\t\\t\\tdoc = elem.ownerDocument;\\n\\t\\t\\toffsetParent = elem.offsetParent || doc.documentElement;\\n\\t\\t\\twhile ( offsetParent &&\\n\\t\\t\\t\\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\\n\\t\\t\\t\\tjQuery.css( offsetParent, \"position\" ) === \"static\" ) {\\n\\n\\t\\t\\t\\toffsetParent = offsetParent.parentNode;\\n\\t\\t\\t}\\n\\t\\t\\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\\n\\n\\t\\t\\t\\t// Incorporate borders into its offset, since they are outside its content origin\\n\\t\\t\\t\\tparentOffset = jQuery( offsetParent ).offset();\\n\\t\\t\\t\\tparentOffset.top += jQuery.css( offsetParent, \"borderTopWidth\", true );\\n\\t\\t\\t\\tparentOffset.left += jQuery.css( offsetParent, \"borderLeftWidth\", true );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Subtract parent offsets and element margins\\n\\t\\treturn {\\n\\t\\t\\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\\n\\t\\t\\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\\n\\t\\t};\\n\\t},\\n\\n\\t// This method will return documentElement in the following cases:\\n\\t// 1) For the element inside the iframe without offsetParent, this method will return\\n\\t//    documentElement of the parent window\\n\\t// 2) For the hidden or detached element\\n\\t// 3) For body or html element, i.e. in case of the html node - it will return itself\\n\\t//\\n\\t// but those exceptions were never presented as a real life use-cases\\n\\t// and might be considered as more preferable results.\\n\\t//\\n\\t// This logic, however, is not guaranteed and can change at any point in the future\\n\\toffsetParent: function() {\\n\\t\\treturn this.map( function() {\\n\\t\\t\\tvar offsetParent = this.offsetParent;\\n\\n\\t\\t\\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\\n\\t\\t\\t\\toffsetParent = offsetParent.offsetParent;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn offsetParent || documentElement;\\n\\t\\t} );\\n\\t}\\n} );\\n\\n// Create scrollLeft and scrollTop methods\\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\\n\\tvar top = \"pageYOffset\" === prop;\\n\\n\\tjQuery.fn[ method ] = function( val ) {\\n\\t\\treturn access( this, function( elem, method, val ) {\\n\\n\\t\\t\\t// Coalesce documents and windows\\n\\t\\t\\tvar win;\\n\\t\\t\\tif ( isWindow( elem ) ) {\\n\\t\\t\\t\\twin = elem;\\n\\t\\t\\t} else if ( elem.nodeType === 9 ) {\\n\\t\\t\\t\\twin = elem.defaultView;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( val === undefined ) {\\n\\t\\t\\t\\treturn win ? win[ prop ] : elem[ method ];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( win ) {\\n\\t\\t\\t\\twin.scrollTo(\\n\\t\\t\\t\\t\\t!top ? val : win.pageXOffset,\\n\\t\\t\\t\\t\\ttop ? val : win.pageYOffset\\n\\t\\t\\t\\t);\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\telem[ method ] = val;\\n\\t\\t\\t}\\n\\t\\t}, method, val, arguments.length );\\n\\t};\\n} );\\n\\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\\n// Add the top/left cssHooks using jQuery.fn.position\\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\\n// getComputedStyle returns percent when specified for top/left/bottom/right;\\n// rather than make the css module depend on the offset module, just check for it here\\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\\n\\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\\n\\t\\tfunction( elem, computed ) {\\n\\t\\t\\tif ( computed ) {\\n\\t\\t\\t\\tcomputed = curCSS( elem, prop );\\n\\n\\t\\t\\t\\t// If curCSS returns percentage, fallback to offset\\n\\t\\t\\t\\treturn rnumnonpx.test( computed ) ?\\n\\t\\t\\t\\t\\tjQuery( elem ).position()[ prop ] + \"px\" :\\n\\t\\t\\t\\t\\tcomputed;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t);\\n} );\\n\\n\\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\\n\\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\\n\\t\\tfunction( defaultExtra, funcName ) {\\n\\n\\t\\t// Margin is only for outerHeight, outerWidth\\n\\t\\tjQuery.fn[ funcName ] = function( margin, value ) {\\n\\t\\t\\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\\n\\t\\t\\t\\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\\n\\n\\t\\t\\treturn access( this, function( elem, type, value ) {\\n\\t\\t\\t\\tvar doc;\\n\\n\\t\\t\\t\\tif ( isWindow( elem ) ) {\\n\\n\\t\\t\\t\\t\\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\\n\\t\\t\\t\\t\\treturn funcName.indexOf( \"outer\" ) === 0 ?\\n\\t\\t\\t\\t\\t\\telem[ \"inner\" + name ] :\\n\\t\\t\\t\\t\\t\\telem.document.documentElement[ \"client\" + name ];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Get document width or height\\n\\t\\t\\t\\tif ( elem.nodeType === 9 ) {\\n\\t\\t\\t\\t\\tdoc = elem.documentElement;\\n\\n\\t\\t\\t\\t\\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\\n\\t\\t\\t\\t\\t// whichever is greatest\\n\\t\\t\\t\\t\\treturn Math.max(\\n\\t\\t\\t\\t\\t\\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\\n\\t\\t\\t\\t\\t\\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\\n\\t\\t\\t\\t\\t\\tdoc[ \"client\" + name ]\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn value === undefined ?\\n\\n\\t\\t\\t\\t\\t// Get width or height on the element, requesting but not forcing parseFloat\\n\\t\\t\\t\\t\\tjQuery.css( elem, type, extra ) :\\n\\n\\t\\t\\t\\t\\t// Set width or height on the element\\n\\t\\t\\t\\t\\tjQuery.style( elem, type, value, extra );\\n\\t\\t\\t}, type, chainable ? margin : undefined, chainable );\\n\\t\\t};\\n\\t} );\\n} );\\n\\n\\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\\n\\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\\n\\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\\n\\tfunction( i, name ) {\\n\\n\\t// Handle event binding\\n\\tjQuery.fn[ name ] = function( data, fn ) {\\n\\t\\treturn arguments.length > 0 ?\\n\\t\\t\\tthis.on( name, null, data, fn ) :\\n\\t\\t\\tthis.trigger( name );\\n\\t};\\n} );\\n\\njQuery.fn.extend( {\\n\\thover: function( fnOver, fnOut ) {\\n\\t\\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\\n\\t}\\n} );\\n\\n\\n\\n\\njQuery.fn.extend( {\\n\\n\\tbind: function( types, data, fn ) {\\n\\t\\treturn this.on( types, null, data, fn );\\n\\t},\\n\\tunbind: function( types, fn ) {\\n\\t\\treturn this.off( types, null, fn );\\n\\t},\\n\\n\\tdelegate: function( selector, types, data, fn ) {\\n\\t\\treturn this.on( types, selector, data, fn );\\n\\t},\\n\\tundelegate: function( selector, types, fn ) {\\n\\n\\t\\t// ( namespace ) or ( selector, types [, fn] )\\n\\t\\treturn arguments.length === 1 ?\\n\\t\\t\\tthis.off( selector, \"**\" ) :\\n\\t\\t\\tthis.off( types, selector || \"**\", fn );\\n\\t}\\n} );\\n\\n// Bind a function to a context, optionally partially applying any\\n// arguments.\\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\\n// However, it is not slated for removal any time soon\\njQuery.proxy = function( fn, context ) {\\n\\tvar tmp, args, proxy;\\n\\n\\tif ( typeof context === \"string\" ) {\\n\\t\\ttmp = fn[ context ];\\n\\t\\tcontext = fn;\\n\\t\\tfn = tmp;\\n\\t}\\n\\n\\t// Quick check to determine if target is callable, in the spec\\n\\t// this throws a TypeError, but we will just return undefined.\\n\\tif ( !isFunction( fn ) ) {\\n\\t\\treturn undefined;\\n\\t}\\n\\n\\t// Simulated bind\\n\\targs = slice.call( arguments, 2 );\\n\\tproxy = function() {\\n\\t\\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\\n\\t};\\n\\n\\t// Set the guid of unique handler to the same of original handler, so it can be removed\\n\\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\\n\\n\\treturn proxy;\\n};\\n\\njQuery.holdReady = function( hold ) {\\n\\tif ( hold ) {\\n\\t\\tjQuery.readyWait++;\\n\\t} else {\\n\\t\\tjQuery.ready( true );\\n\\t}\\n};\\njQuery.isArray = Array.isArray;\\njQuery.parseJSON = JSON.parse;\\njQuery.nodeName = nodeName;\\njQuery.isFunction = isFunction;\\njQuery.isWindow = isWindow;\\njQuery.camelCase = camelCase;\\njQuery.type = toType;\\n\\njQuery.now = Date.now;\\n\\njQuery.isNumeric = function( obj ) {\\n\\n\\t// As of jQuery 3.0, isNumeric is limited to\\n\\t// strings and numbers (primitives or objects)\\n\\t// that can be coerced to finite numbers (gh-2662)\\n\\tvar type = jQuery.type( obj );\\n\\treturn ( type === \"number\" || type === \"string\" ) &&\\n\\n\\t\\t// parseFloat NaNs numeric-cast false positives (\"\")\\n\\t\\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\\n\\t\\t// subtraction forces infinities to NaN\\n\\t\\t!isNaN( obj - parseFloat( obj ) );\\n};\\n\\n\\n\\n\\n// Register as a named AMD module, since jQuery can be concatenated with other\\n// files that may use define, but not via a proper concatenation script that\\n// understands anonymous AMD modules. A named AMD is safest and most robust\\n// way to register. Lowercase jquery is used because AMD module names are\\n// derived from file names, and jQuery is normally delivered in a lowercase\\n// file name. Do this after creating the global so that if an AMD module wants\\n// to call noConflict to hide this version of jQuery, it will work.\\n\\n// Note that for maximum portability, libraries that are not jQuery should\\n// declare themselves as anonymous modules, and avoid setting a global if an\\n// AMD loader is present. jQuery is a special case. For more information, see\\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\\n\\nif ( true ) {\\n\\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\\n\\t\\treturn jQuery;\\n\\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n}\\n\\n\\n\\n\\nvar\\n\\n\\t// Map over jQuery in case of overwrite\\n\\t_jQuery = window.jQuery,\\n\\n\\t// Map over the $ in case of overwrite\\n\\t_$ = window.$;\\n\\njQuery.noConflict = function( deep ) {\\n\\tif ( window.$ === jQuery ) {\\n\\t\\twindow.$ = _$;\\n\\t}\\n\\n\\tif ( deep && window.jQuery === jQuery ) {\\n\\t\\twindow.jQuery = _jQuery;\\n\\t}\\n\\n\\treturn jQuery;\\n};\\n\\n// Expose jQuery and $ identifiers, even in AMD\\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\\n// and CommonJS for browser emulators (#13566)\\nif ( !noGlobal ) {\\n\\twindow.jQuery = window.$ = jQuery;\\n}\\n\\n\\n\\n\\nreturn jQuery;\\n} );\\n\\n\\n//# sourceURL=webpack:///./node_modules/jquery/dist/jquery.js?')},\"./node_modules/sweetalert2/dist/sweetalert2.js\":function(module,exports,__webpack_require__){eval(\"/*!\\n* sweetalert2 v8.0.1\\n* Released under the MIT License.\\n*/\\n(function (global, factory) {\\n\\t true ? module.exports = factory() :\\n\\tundefined;\\n}(this, (function () { 'use strict';\\n\\nfunction _typeof(obj) {\\n  if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") {\\n    _typeof = function (obj) {\\n      return typeof obj;\\n    };\\n  } else {\\n    _typeof = function (obj) {\\n      return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj;\\n    };\\n  }\\n\\n  return _typeof(obj);\\n}\\n\\nfunction _classCallCheck(instance, Constructor) {\\n  if (!(instance instanceof Constructor)) {\\n    throw new TypeError(\\\"Cannot call a class as a function\\\");\\n  }\\n}\\n\\nfunction _defineProperties(target, props) {\\n  for (var i = 0; i < props.length; i++) {\\n    var descriptor = props[i];\\n    descriptor.enumerable = descriptor.enumerable || false;\\n    descriptor.configurable = true;\\n    if (\\\"value\\\" in descriptor) descriptor.writable = true;\\n    Object.defineProperty(target, descriptor.key, descriptor);\\n  }\\n}\\n\\nfunction _createClass(Constructor, protoProps, staticProps) {\\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\\n  if (staticProps) _defineProperties(Constructor, staticProps);\\n  return Constructor;\\n}\\n\\nfunction _extends() {\\n  _extends = Object.assign || function (target) {\\n    for (var i = 1; i < arguments.length; i++) {\\n      var source = arguments[i];\\n\\n      for (var key in source) {\\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\\n          target[key] = source[key];\\n        }\\n      }\\n    }\\n\\n    return target;\\n  };\\n\\n  return _extends.apply(this, arguments);\\n}\\n\\nfunction _inherits(subClass, superClass) {\\n  if (typeof superClass !== \\\"function\\\" && superClass !== null) {\\n    throw new TypeError(\\\"Super expression must either be null or a function\\\");\\n  }\\n\\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\\n    constructor: {\\n      value: subClass,\\n      writable: true,\\n      configurable: true\\n    }\\n  });\\n  if (superClass) _setPrototypeOf(subClass, superClass);\\n}\\n\\nfunction _getPrototypeOf(o) {\\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\\n    return o.__proto__ || Object.getPrototypeOf(o);\\n  };\\n  return _getPrototypeOf(o);\\n}\\n\\nfunction _setPrototypeOf(o, p) {\\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\\n    o.__proto__ = p;\\n    return o;\\n  };\\n\\n  return _setPrototypeOf(o, p);\\n}\\n\\nfunction isNativeReflectConstruct() {\\n  if (typeof Reflect === \\\"undefined\\\" || !Reflect.construct) return false;\\n  if (Reflect.construct.sham) return false;\\n  if (typeof Proxy === \\\"function\\\") return true;\\n\\n  try {\\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\\n    return true;\\n  } catch (e) {\\n    return false;\\n  }\\n}\\n\\nfunction _construct(Parent, args, Class) {\\n  if (isNativeReflectConstruct()) {\\n    _construct = Reflect.construct;\\n  } else {\\n    _construct = function _construct(Parent, args, Class) {\\n      var a = [null];\\n      a.push.apply(a, args);\\n      var Constructor = Function.bind.apply(Parent, a);\\n      var instance = new Constructor();\\n      if (Class) _setPrototypeOf(instance, Class.prototype);\\n      return instance;\\n    };\\n  }\\n\\n  return _construct.apply(null, arguments);\\n}\\n\\nfunction _assertThisInitialized(self) {\\n  if (self === void 0) {\\n    throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\");\\n  }\\n\\n  return self;\\n}\\n\\nfunction _possibleConstructorReturn(self, call) {\\n  if (call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\")) {\\n    return call;\\n  }\\n\\n  return _assertThisInitialized(self);\\n}\\n\\nfunction _superPropBase(object, property) {\\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\\n    object = _getPrototypeOf(object);\\n    if (object === null) break;\\n  }\\n\\n  return object;\\n}\\n\\nfunction _get(target, property, receiver) {\\n  if (typeof Reflect !== \\\"undefined\\\" && Reflect.get) {\\n    _get = Reflect.get;\\n  } else {\\n    _get = function _get(target, property, receiver) {\\n      var base = _superPropBase(target, property);\\n\\n      if (!base) return;\\n      var desc = Object.getOwnPropertyDescriptor(base, property);\\n\\n      if (desc.get) {\\n        return desc.get.call(receiver);\\n      }\\n\\n      return desc.value;\\n    };\\n  }\\n\\n  return _get(target, property, receiver || target);\\n}\\n\\nvar consolePrefix = 'SweetAlert2:';\\n/**\\n * Filter the unique values into a new array\\n * @param arr\\n */\\n\\nvar uniqueArray = function uniqueArray(arr) {\\n  var result = [];\\n\\n  for (var i = 0; i < arr.length; i++) {\\n    if (result.indexOf(arr[i]) === -1) {\\n      result.push(arr[i]);\\n    }\\n  }\\n\\n  return result;\\n};\\n/**\\n * Convert NodeList to Array\\n * @param nodeList\\n */\\n\\nvar toArray = function toArray(nodeList) {\\n  return Array.prototype.slice.call(nodeList);\\n};\\n/**\\n * Converts `inputOptions` into an array of `[value, label]`s\\n * @param inputOptions\\n */\\n\\nvar formatInputOptions = function formatInputOptions(inputOptions) {\\n  var result = [];\\n\\n  if (typeof Map !== 'undefined' && inputOptions instanceof Map) {\\n    inputOptions.forEach(function (value, key) {\\n      result.push([key, value]);\\n    });\\n  } else {\\n    Object.keys(inputOptions).forEach(function (key) {\\n      result.push([key, inputOptions[key]]);\\n    });\\n  }\\n\\n  return result;\\n};\\n/**\\n * Standardise console warnings\\n * @param message\\n */\\n\\nvar warn = function warn(message) {\\n  console.warn(\\\"\\\".concat(consolePrefix, \\\" \\\").concat(message));\\n};\\n/**\\n * Standardise console errors\\n * @param message\\n */\\n\\nvar error = function error(message) {\\n  console.error(\\\"\\\".concat(consolePrefix, \\\" \\\").concat(message));\\n};\\n/**\\n * Private global state for `warnOnce`\\n * @type {Array}\\n * @private\\n */\\n\\nvar previousWarnOnceMessages = [];\\n/**\\n * Show a console warning, but only if it hasn't already been shown\\n * @param message\\n */\\n\\nvar warnOnce = function warnOnce(message) {\\n  if (!(previousWarnOnceMessages.indexOf(message) !== -1)) {\\n    previousWarnOnceMessages.push(message);\\n    warn(message);\\n  }\\n};\\n/**\\n * If `arg` is a function, call it (with no arguments or context) and return the result.\\n * Otherwise, just pass the value through\\n * @param arg\\n */\\n\\nvar callIfFunction = function callIfFunction(arg) {\\n  return typeof arg === 'function' ? arg() : arg;\\n};\\nvar isPromise = function isPromise(arg) {\\n  return arg && Promise.resolve(arg) === arg;\\n};\\n\\nvar DismissReason = Object.freeze({\\n  cancel: 'cancel',\\n  backdrop: 'backdrop',\\n  close: 'close',\\n  esc: 'esc',\\n  timer: 'timer'\\n});\\n\\nvar argsToParams = function argsToParams(args) {\\n  var params = {};\\n\\n  switch (_typeof(args[0])) {\\n    case 'object':\\n      _extends(params, args[0]);\\n\\n      break;\\n\\n    default:\\n      ['title', 'html', 'type'].forEach(function (name, index) {\\n        switch (_typeof(args[index])) {\\n          case 'string':\\n            params[name] = args[index];\\n            break;\\n\\n          case 'undefined':\\n            break;\\n\\n          default:\\n            error(\\\"Unexpected type of \\\".concat(name, \\\"! Expected \\\\\\\"string\\\\\\\", got \\\").concat(_typeof(args[index])));\\n        }\\n      });\\n  }\\n\\n  return params;\\n};\\n\\nvar swalPrefix = 'swal2-';\\nvar prefix = function prefix(items) {\\n  var result = {};\\n\\n  for (var i in items) {\\n    result[items[i]] = swalPrefix + items[i];\\n  }\\n\\n  return result;\\n};\\nvar swalClasses = prefix(['container', 'shown', 'height-auto', 'iosfix', 'popup', 'modal', 'no-backdrop', 'toast', 'toast-shown', 'toast-column', 'fade', 'show', 'hide', 'noanimation', 'close', 'title', 'header', 'content', 'actions', 'confirm', 'cancel', 'footer', 'icon', 'icon-text', 'image', 'input', 'file', 'range', 'select', 'radio', 'checkbox', 'label', 'textarea', 'inputerror', 'validation-message', 'progresssteps', 'activeprogressstep', 'progresscircle', 'progressline', 'loading', 'styled', 'top', 'top-start', 'top-end', 'top-left', 'top-right', 'center', 'center-start', 'center-end', 'center-left', 'center-right', 'bottom', 'bottom-start', 'bottom-end', 'bottom-left', 'bottom-right', 'grow-row', 'grow-column', 'grow-fullscreen', 'rtl']);\\nvar iconTypes = prefix(['success', 'warning', 'info', 'question', 'error']);\\n\\nvar states = {\\n  previousBodyPadding: null\\n};\\nvar hasClass = function hasClass(elem, className) {\\n  return elem.classList.contains(className);\\n};\\nvar focusInput = function focusInput(input) {\\n  input.focus(); // place cursor at end of text in text input\\n\\n  if (input.type !== 'file') {\\n    // http://stackoverflow.com/a/2345915\\n    var val = input.value;\\n    input.value = '';\\n    input.value = val;\\n  }\\n};\\n\\nvar addOrRemoveClass = function addOrRemoveClass(target, classList, add) {\\n  if (!target || !classList) {\\n    return;\\n  }\\n\\n  if (typeof classList === 'string') {\\n    classList = classList.split(/\\\\s+/).filter(Boolean);\\n  }\\n\\n  classList.forEach(function (className) {\\n    if (target.forEach) {\\n      target.forEach(function (elem) {\\n        add ? elem.classList.add(className) : elem.classList.remove(className);\\n      });\\n    } else {\\n      add ? target.classList.add(className) : target.classList.remove(className);\\n    }\\n  });\\n};\\n\\nvar addClass = function addClass(target, classList) {\\n  addOrRemoveClass(target, classList, true);\\n};\\nvar removeClass = function removeClass(target, classList) {\\n  addOrRemoveClass(target, classList, false);\\n};\\nvar getChildByClass = function getChildByClass(elem, className) {\\n  for (var i = 0; i < elem.childNodes.length; i++) {\\n    if (hasClass(elem.childNodes[i], className)) {\\n      return elem.childNodes[i];\\n    }\\n  }\\n};\\nvar show = function show(elem) {\\n  elem.style.opacity = '';\\n  elem.style.display = elem.id === swalClasses.content ? 'block' : 'flex';\\n};\\nvar hide = function hide(elem) {\\n  elem.style.opacity = '';\\n  elem.style.display = 'none';\\n}; // borrowed from jquery $(elem).is(':visible') implementation\\n\\nvar isVisible = function isVisible(elem) {\\n  return elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);\\n};\\nvar contains = function contains(haystack, needle) {\\n  if (typeof haystack.contains === 'function') {\\n    return haystack.contains(needle);\\n  }\\n};\\n\\nvar getContainer = function getContainer() {\\n  return document.body.querySelector('.' + swalClasses.container);\\n};\\n\\nvar elementByClass = function elementByClass(className) {\\n  var container = getContainer();\\n  return container ? container.querySelector('.' + className) : null;\\n};\\n\\nvar getPopup = function getPopup() {\\n  return elementByClass(swalClasses.popup);\\n};\\nvar getIcons = function getIcons() {\\n  var popup = getPopup();\\n  return toArray(popup.querySelectorAll('.' + swalClasses.icon));\\n};\\nvar getTitle = function getTitle() {\\n  return elementByClass(swalClasses.title);\\n};\\nvar getContent = function getContent() {\\n  return elementByClass(swalClasses.content);\\n};\\nvar getImage = function getImage() {\\n  return elementByClass(swalClasses.image);\\n};\\nvar getProgressSteps = function getProgressSteps() {\\n  return elementByClass(swalClasses.progresssteps);\\n};\\nvar getValidationMessage = function getValidationMessage() {\\n  return elementByClass(swalClasses['validation-message']);\\n};\\nvar getConfirmButton = function getConfirmButton() {\\n  return elementByClass(swalClasses.confirm);\\n};\\nvar getCancelButton = function getCancelButton() {\\n  return elementByClass(swalClasses.cancel);\\n};\\nvar getActions = function getActions() {\\n  return elementByClass(swalClasses.actions);\\n};\\nvar getFooter = function getFooter() {\\n  return elementByClass(swalClasses.footer);\\n};\\nvar getCloseButton = function getCloseButton() {\\n  return elementByClass(swalClasses.close);\\n};\\nvar getFocusableElements = function getFocusableElements() {\\n  var focusableElementsWithTabindex = toArray(getPopup().querySelectorAll('[tabindex]:not([tabindex=\\\"-1\\\"]):not([tabindex=\\\"0\\\"])')) // sort according to tabindex\\n  .sort(function (a, b) {\\n    a = parseInt(a.getAttribute('tabindex'));\\n    b = parseInt(b.getAttribute('tabindex'));\\n\\n    if (a > b) {\\n      return 1;\\n    } else if (a < b) {\\n      return -1;\\n    }\\n\\n    return 0;\\n  }); // https://github.com/jkup/focusable/blob/master/index.js\\n\\n  var otherFocusableElements = toArray(getPopup().querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex=\\\"0\\\"], [contenteditable], audio[controls], video[controls]')).filter(function (el) {\\n    return el.getAttribute('tabindex') !== '-1';\\n  });\\n  return uniqueArray(focusableElementsWithTabindex.concat(otherFocusableElements)).filter(function (el) {\\n    return isVisible(el);\\n  });\\n};\\nvar isModal = function isModal() {\\n  return !isToast() && !document.body.classList.contains(swalClasses['no-backdrop']);\\n};\\nvar isToast = function isToast() {\\n  return document.body.classList.contains(swalClasses['toast-shown']);\\n};\\nvar isLoading = function isLoading() {\\n  return getPopup().hasAttribute('data-loading');\\n};\\n\\n// Detect Node env\\nvar isNodeEnv = function isNodeEnv() {\\n  return typeof window === 'undefined' || typeof document === 'undefined';\\n};\\n\\nvar sweetHTML = \\\"\\\\n <div aria-labelledby=\\\\\\\"\\\".concat(swalClasses.title, \\\"\\\\\\\" aria-describedby=\\\\\\\"\\\").concat(swalClasses.content, \\\"\\\\\\\" class=\\\\\\\"\\\").concat(swalClasses.popup, \\\"\\\\\\\" tabindex=\\\\\\\"-1\\\\\\\">\\\\n   <div class=\\\\\\\"\\\").concat(swalClasses.header, \\\"\\\\\\\">\\\\n     <ul class=\\\\\\\"\\\").concat(swalClasses.progresssteps, \\\"\\\\\\\"></ul>\\\\n     <div class=\\\\\\\"\\\").concat(swalClasses.icon, \\\" \\\").concat(iconTypes.error, \\\"\\\\\\\">\\\\n       <span class=\\\\\\\"swal2-x-mark\\\\\\\"><span class=\\\\\\\"swal2-x-mark-line-left\\\\\\\"></span><span class=\\\\\\\"swal2-x-mark-line-right\\\\\\\"></span></span>\\\\n     </div>\\\\n     <div class=\\\\\\\"\\\").concat(swalClasses.icon, \\\" \\\").concat(iconTypes.question, \\\"\\\\\\\">\\\\n       <span class=\\\\\\\"\\\").concat(swalClasses['icon-text'], \\\"\\\\\\\">?</span>\\\\n      </div>\\\\n     <div class=\\\\\\\"\\\").concat(swalClasses.icon, \\\" \\\").concat(iconTypes.warning, \\\"\\\\\\\">\\\\n       <span class=\\\\\\\"\\\").concat(swalClasses['icon-text'], \\\"\\\\\\\">!</span>\\\\n      </div>\\\\n     <div class=\\\\\\\"\\\").concat(swalClasses.icon, \\\" \\\").concat(iconTypes.info, \\\"\\\\\\\">\\\\n       <span class=\\\\\\\"\\\").concat(swalClasses['icon-text'], \\\"\\\\\\\">i</span>\\\\n      </div>\\\\n     <div class=\\\\\\\"\\\").concat(swalClasses.icon, \\\" \\\").concat(iconTypes.success, \\\"\\\\\\\">\\\\n       <div class=\\\\\\\"swal2-success-circular-line-left\\\\\\\"></div>\\\\n       <span class=\\\\\\\"swal2-success-line-tip\\\\\\\"></span> <span class=\\\\\\\"swal2-success-line-long\\\\\\\"></span>\\\\n       <div class=\\\\\\\"swal2-success-ring\\\\\\\"></div> <div class=\\\\\\\"swal2-success-fix\\\\\\\"></div>\\\\n       <div class=\\\\\\\"swal2-success-circular-line-right\\\\\\\"></div>\\\\n     </div>\\\\n     <img class=\\\\\\\"\\\").concat(swalClasses.image, \\\"\\\\\\\" />\\\\n     <h2 class=\\\\\\\"\\\").concat(swalClasses.title, \\\"\\\\\\\" id=\\\\\\\"\\\").concat(swalClasses.title, \\\"\\\\\\\"></h2>\\\\n     <button type=\\\\\\\"button\\\\\\\" class=\\\\\\\"\\\").concat(swalClasses.close, \\\"\\\\\\\">\\\\xD7</button>\\\\n   </div>\\\\n   <div class=\\\\\\\"\\\").concat(swalClasses.content, \\\"\\\\\\\">\\\\n     <div id=\\\\\\\"\\\").concat(swalClasses.content, \\\"\\\\\\\"></div>\\\\n     <input class=\\\\\\\"\\\").concat(swalClasses.input, \\\"\\\\\\\" />\\\\n     <input type=\\\\\\\"file\\\\\\\" class=\\\\\\\"\\\").concat(swalClasses.file, \\\"\\\\\\\" />\\\\n     <div class=\\\\\\\"\\\").concat(swalClasses.range, \\\"\\\\\\\">\\\\n       <input type=\\\\\\\"range\\\\\\\" />\\\\n       <output></output>\\\\n     </div>\\\\n     <select class=\\\\\\\"\\\").concat(swalClasses.select, \\\"\\\\\\\"></select>\\\\n     <div class=\\\\\\\"\\\").concat(swalClasses.radio, \\\"\\\\\\\"></div>\\\\n     <label for=\\\\\\\"\\\").concat(swalClasses.checkbox, \\\"\\\\\\\" class=\\\\\\\"\\\").concat(swalClasses.checkbox, \\\"\\\\\\\">\\\\n       <input type=\\\\\\\"checkbox\\\\\\\" />\\\\n       <span class=\\\\\\\"\\\").concat(swalClasses.label, \\\"\\\\\\\"></span>\\\\n     </label>\\\\n     <textarea class=\\\\\\\"\\\").concat(swalClasses.textarea, \\\"\\\\\\\"></textarea>\\\\n     <div class=\\\\\\\"\\\").concat(swalClasses['validation-message'], \\\"\\\\\\\" id=\\\\\\\"\\\").concat(swalClasses['validation-message'], \\\"\\\\\\\"></div>\\\\n   </div>\\\\n   <div class=\\\\\\\"\\\").concat(swalClasses.actions, \\\"\\\\\\\">\\\\n     <button type=\\\\\\\"button\\\\\\\" class=\\\\\\\"\\\").concat(swalClasses.confirm, \\\"\\\\\\\">OK</button>\\\\n     <button type=\\\\\\\"button\\\\\\\" class=\\\\\\\"\\\").concat(swalClasses.cancel, \\\"\\\\\\\">Cancel</button>\\\\n   </div>\\\\n   <div class=\\\\\\\"\\\").concat(swalClasses.footer, \\\"\\\\\\\">\\\\n   </div>\\\\n </div>\\\\n\\\").replace(/(^|\\\\n)\\\\s*/g, '');\\n/*\\n * Add modal + backdrop to DOM\\n */\\n\\nvar init = function init(params) {\\n  // Clean up the old popup if it exists\\n  var c = getContainer();\\n\\n  if (c) {\\n    c.parentNode.removeChild(c);\\n    removeClass([document.documentElement, document.body], [swalClasses['no-backdrop'], swalClasses['toast-shown'], swalClasses['has-column']]);\\n  }\\n  /* istanbul ignore if */\\n\\n\\n  if (isNodeEnv()) {\\n    error('SweetAlert2 requires document to initialize');\\n    return;\\n  }\\n\\n  var container = document.createElement('div');\\n  container.className = swalClasses.container;\\n  container.innerHTML = sweetHTML;\\n  var targetElement = typeof params.target === 'string' ? document.querySelector(params.target) : params.target;\\n  targetElement.appendChild(container);\\n  var popup = getPopup();\\n  var content = getContent();\\n  var input = getChildByClass(content, swalClasses.input);\\n  var file = getChildByClass(content, swalClasses.file);\\n  var range = content.querySelector(\\\".\\\".concat(swalClasses.range, \\\" input\\\"));\\n  var rangeOutput = content.querySelector(\\\".\\\".concat(swalClasses.range, \\\" output\\\"));\\n  var select = getChildByClass(content, swalClasses.select);\\n  var checkbox = content.querySelector(\\\".\\\".concat(swalClasses.checkbox, \\\" input\\\"));\\n  var textarea = getChildByClass(content, swalClasses.textarea); // a11y\\n\\n  popup.setAttribute('role', params.toast ? 'alert' : 'dialog');\\n  popup.setAttribute('aria-live', params.toast ? 'polite' : 'assertive');\\n\\n  if (!params.toast) {\\n    popup.setAttribute('aria-modal', 'true');\\n  } // RTL\\n\\n\\n  if (window.getComputedStyle(targetElement).direction === 'rtl') {\\n    addClass(getContainer(), swalClasses.rtl);\\n  }\\n\\n  var oldInputVal; // IE11 workaround, see #1109 for details\\n\\n  var resetValidationMessage = function resetValidationMessage(e) {\\n    if (Swal.isVisible() && oldInputVal !== e.target.value) {\\n      Swal.resetValidationMessage();\\n    }\\n\\n    oldInputVal = e.target.value;\\n  };\\n\\n  input.oninput = resetValidationMessage;\\n  file.onchange = resetValidationMessage;\\n  select.onchange = resetValidationMessage;\\n  checkbox.onchange = resetValidationMessage;\\n  textarea.oninput = resetValidationMessage;\\n\\n  range.oninput = function (e) {\\n    resetValidationMessage(e);\\n    rangeOutput.value = range.value;\\n  };\\n\\n  range.onchange = function (e) {\\n    resetValidationMessage(e);\\n    range.nextSibling.value = range.value;\\n  };\\n\\n  return popup;\\n};\\n\\nvar parseHtmlToContainer = function parseHtmlToContainer(param, target) {\\n  if (!param) {\\n    return hide(target);\\n  } // DOM element\\n\\n\\n  if (param instanceof HTMLElement) {\\n    target.appendChild(param); // JQuery element(s)\\n  } else if (_typeof(param) === 'object') {\\n    target.innerHTML = '';\\n\\n    if (0 in param) {\\n      for (var i = 0; i in param; i++) {\\n        target.appendChild(param[i].cloneNode(true));\\n      }\\n    } else {\\n      target.appendChild(param.cloneNode(true));\\n    }\\n  } else if (param) {\\n    target.innerHTML = param;\\n  }\\n\\n  show(target);\\n};\\n\\nvar animationEndEvent = function () {\\n  // Prevent run in Node env\\n\\n  /* istanbul ignore if */\\n  if (isNodeEnv()) {\\n    return false;\\n  }\\n\\n  var testEl = document.createElement('div');\\n  var transEndEventNames = {\\n    'WebkitAnimation': 'webkitAnimationEnd',\\n    'OAnimation': 'oAnimationEnd oanimationend',\\n    'animation': 'animationend'\\n  };\\n\\n  for (var i in transEndEventNames) {\\n    if (transEndEventNames.hasOwnProperty(i) && typeof testEl.style[i] !== 'undefined') {\\n      return transEndEventNames[i];\\n    }\\n  }\\n\\n  return false;\\n}();\\n\\n// Measure width of scrollbar\\n// https://github.com/twbs/bootstrap/blob/master/js/modal.js#L279-L286\\nvar measureScrollbar = function measureScrollbar() {\\n  var supportsTouch = 'ontouchstart' in window || navigator.msMaxTouchPoints;\\n\\n  if (supportsTouch) {\\n    return 0;\\n  }\\n\\n  var scrollDiv = document.createElement('div');\\n  scrollDiv.style.width = '50px';\\n  scrollDiv.style.height = '50px';\\n  scrollDiv.style.overflow = 'scroll';\\n  document.body.appendChild(scrollDiv);\\n  var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\\n  document.body.removeChild(scrollDiv);\\n  return scrollbarWidth;\\n};\\n\\nvar renderActions = function renderActions(params) {\\n  var actions = getActions();\\n  var confirmButton = getConfirmButton();\\n  var cancelButton = getCancelButton(); // Actions (buttons) wrapper\\n\\n  if (!params.showConfirmButton && !params.showCancelButton) {\\n    hide(actions);\\n  } else {\\n    show(actions);\\n  } // Cancel button\\n\\n\\n  if (params.showCancelButton) {\\n    cancelButton.style.display = 'inline-block';\\n  } else {\\n    hide(cancelButton);\\n  } // Confirm button\\n\\n\\n  if (params.showConfirmButton) {\\n    confirmButton.style.removeProperty('display');\\n  } else {\\n    hide(confirmButton);\\n  } // Edit text on confirm and cancel buttons\\n\\n\\n  confirmButton.innerHTML = params.confirmButtonText;\\n  cancelButton.innerHTML = params.cancelButtonText; // ARIA labels for confirm and cancel buttons\\n\\n  confirmButton.setAttribute('aria-label', params.confirmButtonAriaLabel);\\n  cancelButton.setAttribute('aria-label', params.cancelButtonAriaLabel); // Add buttons custom classes\\n\\n  confirmButton.className = swalClasses.confirm;\\n  addClass(confirmButton, params.confirmButtonClass);\\n  cancelButton.className = swalClasses.cancel;\\n  addClass(cancelButton, params.cancelButtonClass); // Buttons styling\\n\\n  if (params.buttonsStyling) {\\n    addClass([confirmButton, cancelButton], swalClasses.styled); // Buttons background colors\\n\\n    if (params.confirmButtonColor) {\\n      confirmButton.style.backgroundColor = params.confirmButtonColor;\\n    }\\n\\n    if (params.cancelButtonColor) {\\n      cancelButton.style.backgroundColor = params.cancelButtonColor;\\n    } // Loading state\\n\\n\\n    var confirmButtonBackgroundColor = window.getComputedStyle(confirmButton).getPropertyValue('background-color');\\n    confirmButton.style.borderLeftColor = confirmButtonBackgroundColor;\\n    confirmButton.style.borderRightColor = confirmButtonBackgroundColor;\\n  } else {\\n    removeClass([confirmButton, cancelButton], swalClasses.styled);\\n    confirmButton.style.backgroundColor = confirmButton.style.borderLeftColor = confirmButton.style.borderRightColor = '';\\n    cancelButton.style.backgroundColor = cancelButton.style.borderLeftColor = cancelButton.style.borderRightColor = '';\\n  }\\n};\\n\\nvar renderContent = function renderContent(params) {\\n  var content = getContent().querySelector('#' + swalClasses.content); // Content as HTML\\n\\n  if (params.html) {\\n    parseHtmlToContainer(params.html, content); // Content as plain text\\n  } else if (params.text) {\\n    content.textContent = params.text;\\n    show(content);\\n  } else {\\n    hide(content);\\n  }\\n};\\n\\nvar renderIcon = function renderIcon(params) {\\n  var icons = getIcons();\\n\\n  for (var i = 0; i < icons.length; i++) {\\n    hide(icons[i]);\\n  }\\n\\n  if (params.type) {\\n    if (Object.keys(iconTypes).indexOf(params.type) !== -1) {\\n      var icon = Swal.getPopup().querySelector(\\\".\\\".concat(swalClasses.icon, \\\".\\\").concat(iconTypes[params.type]));\\n      show(icon); // Animate icon\\n\\n      if (params.animation) {\\n        addClass(icon, \\\"swal2-animate-\\\".concat(params.type, \\\"-icon\\\"));\\n      }\\n    } else {\\n      error(\\\"Unknown type! Expected \\\\\\\"success\\\\\\\", \\\\\\\"error\\\\\\\", \\\\\\\"warning\\\\\\\", \\\\\\\"info\\\\\\\" or \\\\\\\"question\\\\\\\", got \\\\\\\"\\\".concat(params.type, \\\"\\\\\\\"\\\"));\\n    }\\n  }\\n};\\n\\nvar renderImage = function renderImage(params) {\\n  var image = getImage();\\n\\n  if (params.imageUrl) {\\n    image.setAttribute('src', params.imageUrl);\\n    image.setAttribute('alt', params.imageAlt);\\n    show(image);\\n\\n    if (params.imageWidth) {\\n      image.setAttribute('width', params.imageWidth);\\n    } else {\\n      image.removeAttribute('width');\\n    }\\n\\n    if (params.imageHeight) {\\n      image.setAttribute('height', params.imageHeight);\\n    } else {\\n      image.removeAttribute('height');\\n    }\\n\\n    image.className = swalClasses.image;\\n\\n    if (params.imageClass) {\\n      addClass(image, params.imageClass);\\n    }\\n  } else {\\n    hide(image);\\n  }\\n};\\n\\nvar renderProgressSteps = function renderProgressSteps(params) {\\n  var progressStepsContainer = getProgressSteps();\\n  var currentProgressStep = parseInt(params.currentProgressStep === null ? Swal.getQueueStep() : params.currentProgressStep, 10);\\n\\n  if (params.progressSteps && params.progressSteps.length) {\\n    show(progressStepsContainer);\\n    progressStepsContainer.innerHTML = '';\\n\\n    if (currentProgressStep >= params.progressSteps.length) {\\n      warn('Invalid currentProgressStep parameter, it should be less than progressSteps.length ' + '(currentProgressStep like JS arrays starts from 0)');\\n    }\\n\\n    params.progressSteps.forEach(function (step, index) {\\n      var circle = document.createElement('li');\\n      addClass(circle, swalClasses.progresscircle);\\n      circle.innerHTML = step;\\n\\n      if (index === currentProgressStep) {\\n        addClass(circle, swalClasses.activeprogressstep);\\n      }\\n\\n      progressStepsContainer.appendChild(circle);\\n\\n      if (index !== params.progressSteps.length - 1) {\\n        var line = document.createElement('li');\\n        addClass(line, swalClasses.progressline);\\n\\n        if (params.progressStepsDistance) {\\n          line.style.width = params.progressStepsDistance;\\n        }\\n\\n        progressStepsContainer.appendChild(line);\\n      }\\n    });\\n  } else {\\n    hide(progressStepsContainer);\\n  }\\n};\\n\\nvar renderTitle = function renderTitle(params) {\\n  var title = getTitle();\\n\\n  if (params.titleText) {\\n    title.innerText = params.titleText;\\n  } else if (params.title) {\\n    if (typeof params.title === 'string') {\\n      params.title = params.title.split('\\\\n').join('<br />');\\n    }\\n\\n    parseHtmlToContainer(params.title, title);\\n  }\\n};\\n\\n/*\\n * Global function to determine if SweetAlert2 popup is shown\\n */\\n\\nvar isVisible$1 = function isVisible() {\\n  return !!getPopup();\\n};\\n/*\\n * Global function to click 'Confirm' button\\n */\\n\\nvar clickConfirm = function clickConfirm() {\\n  return getConfirmButton().click();\\n};\\n/*\\n * Global function to click 'Cancel' button\\n */\\n\\nvar clickCancel = function clickCancel() {\\n  return getCancelButton().click();\\n};\\n\\nfunction fire() {\\n  var Swal = this;\\n\\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\\n    args[_key] = arguments[_key];\\n  }\\n\\n  return _construct(Swal, args);\\n}\\n\\n/**\\n * Returns an extended version of `Swal` containing `params` as defaults.\\n * Useful for reusing Swal configuration.\\n *\\n * For example:\\n *\\n * Before:\\n * const textPromptOptions = { input: 'text', showCancelButton: true }\\n * const {value: firstName} = await Swal.fire({ ...textPromptOptions, title: 'What is your first name?' })\\n * const {value: lastName} = await Swal.fire({ ...textPromptOptions, title: 'What is your last name?' })\\n *\\n * After:\\n * const TextPrompt = Swal.mixin({ input: 'text', showCancelButton: true })\\n * const {value: firstName} = await TextPrompt('What is your first name?')\\n * const {value: lastName} = await TextPrompt('What is your last name?')\\n *\\n * @param mixinParams\\n */\\nfunction mixin(mixinParams) {\\n  var MixinSwal =\\n  /*#__PURE__*/\\n  function (_this) {\\n    _inherits(MixinSwal, _this);\\n\\n    function MixinSwal() {\\n      _classCallCheck(this, MixinSwal);\\n\\n      return _possibleConstructorReturn(this, _getPrototypeOf(MixinSwal).apply(this, arguments));\\n    }\\n\\n    _createClass(MixinSwal, [{\\n      key: \\\"_main\\\",\\n      value: function _main(params) {\\n        return _get(_getPrototypeOf(MixinSwal.prototype), \\\"_main\\\", this).call(this, _extends({}, mixinParams, params));\\n      }\\n    }]);\\n\\n    return MixinSwal;\\n  }(this);\\n\\n  return MixinSwal;\\n}\\n\\n// private global state for the queue feature\\nvar currentSteps = [];\\n/*\\n * Global function for chaining sweetAlert popups\\n */\\n\\nvar queue = function queue(steps) {\\n  var Swal = this;\\n  currentSteps = steps;\\n\\n  var resetQueue = function resetQueue() {\\n    currentSteps = [];\\n    document.body.removeAttribute('data-swal2-queue-step');\\n  };\\n\\n  var queueResult = [];\\n  return new Promise(function (resolve) {\\n    (function step(i, callback) {\\n      if (i < currentSteps.length) {\\n        document.body.setAttribute('data-swal2-queue-step', i);\\n        Swal.fire(currentSteps[i]).then(function (result) {\\n          if (typeof result.value !== 'undefined') {\\n            queueResult.push(result.value);\\n            step(i + 1, callback);\\n          } else {\\n            resetQueue();\\n            resolve({\\n              dismiss: result.dismiss\\n            });\\n          }\\n        });\\n      } else {\\n        resetQueue();\\n        resolve({\\n          value: queueResult\\n        });\\n      }\\n    })(0);\\n  });\\n};\\n/*\\n * Global function for getting the index of current popup in queue\\n */\\n\\nvar getQueueStep = function getQueueStep() {\\n  return document.body.getAttribute('data-swal2-queue-step');\\n};\\n/*\\n * Global function for inserting a popup to the queue\\n */\\n\\nvar insertQueueStep = function insertQueueStep(step, index) {\\n  if (index && index < currentSteps.length) {\\n    return currentSteps.splice(index, 0, step);\\n  }\\n\\n  return currentSteps.push(step);\\n};\\n/*\\n * Global function for deleting a popup from the queue\\n */\\n\\nvar deleteQueueStep = function deleteQueueStep(index) {\\n  if (typeof currentSteps[index] !== 'undefined') {\\n    currentSteps.splice(index, 1);\\n  }\\n};\\n\\n/**\\n * Show spinner instead of Confirm button and disable Cancel button\\n */\\n\\nvar showLoading = function showLoading() {\\n  var popup = getPopup();\\n\\n  if (!popup) {\\n    Swal('');\\n  }\\n\\n  popup = getPopup();\\n  var actions = getActions();\\n  var confirmButton = getConfirmButton();\\n  var cancelButton = getCancelButton();\\n  show(actions);\\n  show(confirmButton);\\n  addClass([popup, actions], swalClasses.loading);\\n  confirmButton.disabled = true;\\n  cancelButton.disabled = true;\\n  popup.setAttribute('data-loading', true);\\n  popup.setAttribute('aria-busy', true);\\n  popup.focus();\\n};\\n\\nvar RESTORE_FOCUS_TIMEOUT = 100;\\n\\nvar globalState = {};\\nvar restoreActiveElement = function restoreActiveElement() {\\n  return new Promise(function (resolve) {\\n    var x = window.scrollX;\\n    var y = window.scrollY;\\n    globalState.restoreFocusTimeout = setTimeout(function () {\\n      if (globalState.previousActiveElement && globalState.previousActiveElement.focus) {\\n        globalState.previousActiveElement.focus();\\n        globalState.previousActiveElement = null;\\n      } else if (document.body) {\\n        document.body.focus();\\n      }\\n\\n      resolve();\\n    }, RESTORE_FOCUS_TIMEOUT); // issues/900\\n\\n    if (typeof x !== 'undefined' && typeof y !== 'undefined') {\\n      // IE doesn't have scrollX/scrollY support\\n      window.scrollTo(x, y);\\n    }\\n  });\\n};\\n\\n/**\\n * If `timer` parameter is set, returns number of milliseconds of timer remained.\\n * Otherwise, returns undefined.\\n */\\n\\nvar getTimerLeft = function getTimerLeft() {\\n  return globalState.timeout && globalState.timeout.getTimerLeft();\\n};\\n/**\\n * Stop timer. Returns number of milliseconds of timer remained.\\n * If `timer` parameter isn't set, returns undefined.\\n */\\n\\nvar stopTimer = function stopTimer() {\\n  return globalState.timeout && globalState.timeout.stop();\\n};\\n/**\\n * Resume timer. Returns number of milliseconds of timer remained.\\n * If `timer` parameter isn't set, returns undefined.\\n */\\n\\nvar resumeTimer = function resumeTimer() {\\n  return globalState.timeout && globalState.timeout.start();\\n};\\n/**\\n * Resume timer. Returns number of milliseconds of timer remained.\\n * If `timer` parameter isn't set, returns undefined.\\n */\\n\\nvar toggleTimer = function toggleTimer() {\\n  var timer = globalState.timeout;\\n  return timer && (timer.running ? timer.stop() : timer.start());\\n};\\n/**\\n * Increase timer. Returns number of milliseconds of an updated timer.\\n * If `timer` parameter isn't set, returns undefined.\\n */\\n\\nvar increaseTimer = function increaseTimer(n) {\\n  return globalState.timeout && globalState.timeout.increase(n);\\n};\\n/**\\n * Check if timer is running. Returns true if timer is running\\n * or false if timer is paused or stopped.\\n * If `timer` parameter isn't set, returns undefined\\n */\\n\\nvar isTimerRunning = function isTimerRunning() {\\n  return globalState.timeout && globalState.timeout.isRunning();\\n};\\n\\nvar defaultParams = {\\n  title: '',\\n  titleText: '',\\n  text: '',\\n  html: '',\\n  footer: '',\\n  type: null,\\n  toast: false,\\n  customClass: '',\\n  customContainerClass: '',\\n  target: 'body',\\n  backdrop: true,\\n  animation: true,\\n  heightAuto: true,\\n  allowOutsideClick: true,\\n  allowEscapeKey: true,\\n  allowEnterKey: true,\\n  stopKeydownPropagation: true,\\n  keydownListenerCapture: false,\\n  showConfirmButton: true,\\n  showCancelButton: false,\\n  preConfirm: null,\\n  confirmButtonText: 'OK',\\n  confirmButtonAriaLabel: '',\\n  confirmButtonColor: null,\\n  confirmButtonClass: '',\\n  cancelButtonText: 'Cancel',\\n  cancelButtonAriaLabel: '',\\n  cancelButtonColor: null,\\n  cancelButtonClass: '',\\n  buttonsStyling: true,\\n  reverseButtons: false,\\n  focusConfirm: true,\\n  focusCancel: false,\\n  showCloseButton: false,\\n  closeButtonAriaLabel: 'Close this dialog',\\n  showLoaderOnConfirm: false,\\n  imageUrl: null,\\n  imageWidth: null,\\n  imageHeight: null,\\n  imageAlt: '',\\n  imageClass: '',\\n  timer: null,\\n  width: null,\\n  padding: null,\\n  background: null,\\n  input: null,\\n  inputPlaceholder: '',\\n  inputValue: '',\\n  inputOptions: {},\\n  inputAutoTrim: true,\\n  inputClass: '',\\n  inputAttributes: {},\\n  inputValidator: null,\\n  validationMessage: null,\\n  grow: false,\\n  position: 'center',\\n  progressSteps: [],\\n  currentProgressStep: null,\\n  progressStepsDistance: null,\\n  onBeforeOpen: null,\\n  onAfterClose: null,\\n  onOpen: null,\\n  onClose: null\\n};\\nvar deprecatedParams = [];\\nvar toastIncompatibleParams = ['allowOutsideClick', 'allowEnterKey', 'backdrop', 'focusConfirm', 'focusCancel', 'heightAuto', 'keydownListenerCapture'];\\n/**\\n * Is valid parameter\\n * @param {String} paramName\\n */\\n\\nvar isValidParameter = function isValidParameter(paramName) {\\n  return defaultParams.hasOwnProperty(paramName);\\n};\\n/**\\n * Is valid parameter for Swal.update() method\\n * @param {String} paramName\\n */\\n\\nvar isUpdatableParameter = function isUpdatableParameter(paramName) {\\n  return ['title', 'titleText', 'text', 'html', 'type', 'showConfirmButton', 'showCancelButton', 'confirmButtonText', 'confirmButtonAriaLabel', 'confirmButtonColor', 'confirmButtonClass', 'cancelButtonText', 'cancelButtonAriaLabel', 'cancelButtonColor', 'cancelButtonClass', 'buttonsStyling', 'reverseButtons', 'imageUrl', 'imageWidth', 'imageHeigth', 'imageAlt', 'imageClass', 'progressSteps', 'currentProgressStep'].indexOf(paramName) !== -1;\\n};\\n/**\\n * Is deprecated parameter\\n * @param {String} paramName\\n */\\n\\nvar isDeprecatedParameter = function isDeprecatedParameter(paramName) {\\n  return deprecatedParams.indexOf(paramName) !== -1;\\n};\\n/**\\n * Show relevant warnings for given params\\n *\\n * @param params\\n */\\n\\nvar showWarningsForParams = function showWarningsForParams(params) {\\n  for (var param in params) {\\n    if (!isValidParameter(param)) {\\n      warn(\\\"Unknown parameter \\\\\\\"\\\".concat(param, \\\"\\\\\\\"\\\"));\\n    }\\n\\n    if (params.toast && toastIncompatibleParams.indexOf(param) !== -1) {\\n      warn(\\\"The parameter \\\\\\\"\\\".concat(param, \\\"\\\\\\\" is incompatible with toasts\\\"));\\n    }\\n\\n    if (isDeprecatedParameter(param)) {\\n      warnOnce(\\\"The parameter \\\\\\\"\\\".concat(param, \\\"\\\\\\\" is deprecated and will be removed in the next major release.\\\"));\\n    }\\n  }\\n};\\n\\n\\n\\nvar staticMethods = Object.freeze({\\n\\tisValidParameter: isValidParameter,\\n\\tisUpdatableParameter: isUpdatableParameter,\\n\\tisDeprecatedParameter: isDeprecatedParameter,\\n\\targsToParams: argsToParams,\\n\\tisVisible: isVisible$1,\\n\\tclickConfirm: clickConfirm,\\n\\tclickCancel: clickCancel,\\n\\tgetContainer: getContainer,\\n\\tgetPopup: getPopup,\\n\\tgetTitle: getTitle,\\n\\tgetContent: getContent,\\n\\tgetImage: getImage,\\n\\tgetIcons: getIcons,\\n\\tgetCloseButton: getCloseButton,\\n\\tgetActions: getActions,\\n\\tgetConfirmButton: getConfirmButton,\\n\\tgetCancelButton: getCancelButton,\\n\\tgetFooter: getFooter,\\n\\tgetFocusableElements: getFocusableElements,\\n\\tgetValidationMessage: getValidationMessage,\\n\\tisLoading: isLoading,\\n\\tfire: fire,\\n\\tmixin: mixin,\\n\\tqueue: queue,\\n\\tgetQueueStep: getQueueStep,\\n\\tinsertQueueStep: insertQueueStep,\\n\\tdeleteQueueStep: deleteQueueStep,\\n\\tshowLoading: showLoading,\\n\\tenableLoading: showLoading,\\n\\tgetTimerLeft: getTimerLeft,\\n\\tstopTimer: stopTimer,\\n\\tresumeTimer: resumeTimer,\\n\\ttoggleTimer: toggleTimer,\\n\\tincreaseTimer: increaseTimer,\\n\\tisTimerRunning: isTimerRunning\\n});\\n\\n/**\\n * This module containts `WeakMap`s for each effectively-\\\"private  property\\\" that a `Swal` has.\\n * For example, to set the private property \\\"foo\\\" of `this` to \\\"bar\\\", you can `privateProps.foo.set(this, 'bar')`\\n * This is the approach that Babel will probably take to implement private methods/fields\\n *   https://github.com/tc39/proposal-private-methods\\n *   https://github.com/babel/babel/pull/7555\\n * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*\\n *   then we can use that language feature.\\n */\\nvar privateProps = {\\n  promise: new WeakMap(),\\n  innerParams: new WeakMap(),\\n  domCache: new WeakMap()\\n};\\n\\n/**\\n * Enables buttons and hide loader.\\n */\\n\\nfunction hideLoading() {\\n  var innerParams = privateProps.innerParams.get(this);\\n  var domCache = privateProps.domCache.get(this);\\n\\n  if (!innerParams.showConfirmButton) {\\n    hide(domCache.confirmButton);\\n\\n    if (!innerParams.showCancelButton) {\\n      hide(domCache.actions);\\n    }\\n  }\\n\\n  removeClass([domCache.popup, domCache.actions], swalClasses.loading);\\n  domCache.popup.removeAttribute('aria-busy');\\n  domCache.popup.removeAttribute('data-loading');\\n  domCache.confirmButton.disabled = false;\\n  domCache.cancelButton.disabled = false;\\n}\\n\\nfunction getInput(inputType) {\\n  var innerParams = privateProps.innerParams.get(this);\\n  var domCache = privateProps.domCache.get(this);\\n  inputType = inputType || innerParams.input;\\n\\n  if (!inputType) {\\n    return null;\\n  }\\n\\n  switch (inputType) {\\n    case 'select':\\n    case 'textarea':\\n    case 'file':\\n      return getChildByClass(domCache.content, swalClasses[inputType]);\\n\\n    case 'checkbox':\\n      return domCache.popup.querySelector(\\\".\\\".concat(swalClasses.checkbox, \\\" input\\\"));\\n\\n    case 'radio':\\n      return domCache.popup.querySelector(\\\".\\\".concat(swalClasses.radio, \\\" input:checked\\\")) || domCache.popup.querySelector(\\\".\\\".concat(swalClasses.radio, \\\" input:first-child\\\"));\\n\\n    case 'range':\\n      return domCache.popup.querySelector(\\\".\\\".concat(swalClasses.range, \\\" input\\\"));\\n\\n    default:\\n      return getChildByClass(domCache.content, swalClasses.input);\\n  }\\n}\\n\\nvar fixScrollbar = function fixScrollbar() {\\n  // for queues, do not do this more than once\\n  if (states.previousBodyPadding !== null) {\\n    return;\\n  } // if the body has overflow\\n\\n\\n  if (document.body.scrollHeight > window.innerHeight) {\\n    // add padding so the content doesn't shift after removal of scrollbar\\n    states.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue('padding-right'));\\n    document.body.style.paddingRight = states.previousBodyPadding + measureScrollbar() + 'px';\\n  }\\n};\\nvar undoScrollbar = function undoScrollbar() {\\n  if (states.previousBodyPadding !== null) {\\n    document.body.style.paddingRight = states.previousBodyPadding;\\n    states.previousBodyPadding = null;\\n  }\\n};\\n\\n/* istanbul ignore next */\\n\\nvar iOSfix = function iOSfix() {\\n  var iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\\n\\n  if (iOS && !hasClass(document.body, swalClasses.iosfix)) {\\n    var offset = document.body.scrollTop;\\n    document.body.style.top = offset * -1 + 'px';\\n    addClass(document.body, swalClasses.iosfix);\\n  }\\n};\\n/* istanbul ignore next */\\n\\nvar undoIOSfix = function undoIOSfix() {\\n  if (hasClass(document.body, swalClasses.iosfix)) {\\n    var offset = parseInt(document.body.style.top, 10);\\n    removeClass(document.body, swalClasses.iosfix);\\n    document.body.style.top = '';\\n    document.body.scrollTop = offset * -1;\\n  }\\n};\\n\\nvar isIE11 = function isIE11() {\\n  return !!window.MSInputMethodContext && !!document.documentMode;\\n}; // Fix IE11 centering sweetalert2/issues/933\\n\\n/* istanbul ignore next */\\n\\n\\nvar fixVerticalPositionIE = function fixVerticalPositionIE() {\\n  var container = getContainer();\\n  var popup = getPopup();\\n  container.style.removeProperty('align-items');\\n\\n  if (popup.offsetTop < 0) {\\n    container.style.alignItems = 'flex-start';\\n  }\\n};\\n/* istanbul ignore next */\\n\\n\\nvar IEfix = function IEfix() {\\n  if (typeof window !== 'undefined' && isIE11()) {\\n    fixVerticalPositionIE();\\n    window.addEventListener('resize', fixVerticalPositionIE);\\n  }\\n};\\n/* istanbul ignore next */\\n\\nvar undoIEfix = function undoIEfix() {\\n  if (typeof window !== 'undefined' && isIE11()) {\\n    window.removeEventListener('resize', fixVerticalPositionIE);\\n  }\\n};\\n\\n// Adding aria-hidden=\\\"true\\\" to elements outside of the active modal dialog ensures that\\n// elements not within the active modal dialog will not be surfaced if a user opens a screen\\n// readers list of elements (headings, form controls, landmarks, etc.) in the document.\\n\\nvar setAriaHidden = function setAriaHidden() {\\n  var bodyChildren = toArray(document.body.children);\\n  bodyChildren.forEach(function (el) {\\n    if (el === getContainer() || contains(el, getContainer())) {\\n      return;\\n    }\\n\\n    if (el.hasAttribute('aria-hidden')) {\\n      el.setAttribute('data-previous-aria-hidden', el.getAttribute('aria-hidden'));\\n    }\\n\\n    el.setAttribute('aria-hidden', 'true');\\n  });\\n};\\nvar unsetAriaHidden = function unsetAriaHidden() {\\n  var bodyChildren = toArray(document.body.children);\\n  bodyChildren.forEach(function (el) {\\n    if (el.hasAttribute('data-previous-aria-hidden')) {\\n      el.setAttribute('aria-hidden', el.getAttribute('data-previous-aria-hidden'));\\n      el.removeAttribute('data-previous-aria-hidden');\\n    } else {\\n      el.removeAttribute('aria-hidden');\\n    }\\n  });\\n};\\n\\n/**\\n * This module containts `WeakMap`s for each effectively-\\\"private  property\\\" that a `Swal` has.\\n * For example, to set the private property \\\"foo\\\" of `this` to \\\"bar\\\", you can `privateProps.foo.set(this, 'bar')`\\n * This is the approach that Babel will probably take to implement private methods/fields\\n *   https://github.com/tc39/proposal-private-methods\\n *   https://github.com/babel/babel/pull/7555\\n * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*\\n *   then we can use that language feature.\\n */\\nvar privateMethods = {\\n  swalPromiseResolve: new WeakMap()\\n};\\n\\n/*\\n * Instance method to close sweetAlert\\n */\\n\\nfunction close(resolveValue) {\\n  var container = getContainer();\\n  var popup = getPopup();\\n  var innerParams = privateProps.innerParams.get(this);\\n  var swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);\\n  var onClose = innerParams.onClose;\\n  var onAfterClose = innerParams.onAfterClose;\\n\\n  if (!popup) {\\n    return;\\n  }\\n\\n  if (onClose !== null && typeof onClose === 'function') {\\n    onClose(popup);\\n  }\\n\\n  removeClass(popup, swalClasses.show);\\n  addClass(popup, swalClasses.hide);\\n\\n  var removePopupAndResetState = function removePopupAndResetState() {\\n    if (!isToast()) {\\n      restoreActiveElement().then(function () {\\n        return triggerOnAfterClose(onAfterClose);\\n      });\\n      globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {\\n        capture: globalState.keydownListenerCapture\\n      });\\n      globalState.keydownHandlerAdded = false;\\n    } else {\\n      triggerOnAfterClose(onAfterClose);\\n    }\\n\\n    if (container.parentNode) {\\n      container.parentNode.removeChild(container);\\n    }\\n\\n    removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses['height-auto'], swalClasses['no-backdrop'], swalClasses['toast-shown'], swalClasses['toast-column']]);\\n\\n    if (isModal()) {\\n      undoScrollbar();\\n      undoIOSfix();\\n      undoIEfix();\\n      unsetAriaHidden();\\n    }\\n  }; // If animation is supported, animate\\n\\n\\n  if (animationEndEvent && !hasClass(popup, swalClasses.noanimation)) {\\n    popup.addEventListener(animationEndEvent, function swalCloseEventFinished() {\\n      popup.removeEventListener(animationEndEvent, swalCloseEventFinished);\\n\\n      if (hasClass(popup, swalClasses.hide)) {\\n        removePopupAndResetState();\\n      }\\n    });\\n  } else {\\n    // Otherwise, remove immediately\\n    removePopupAndResetState();\\n  } // Resolve Swal promise\\n\\n\\n  swalPromiseResolve(resolveValue || {});\\n}\\n\\nvar triggerOnAfterClose = function triggerOnAfterClose(onAfterClose) {\\n  if (onAfterClose !== null && typeof onAfterClose === 'function') {\\n    setTimeout(function () {\\n      onAfterClose();\\n    });\\n  }\\n};\\n\\nfunction enableButtons() {\\n  var domCache = privateProps.domCache.get(this);\\n  domCache.confirmButton.disabled = false;\\n  domCache.cancelButton.disabled = false;\\n}\\nfunction disableButtons() {\\n  var domCache = privateProps.domCache.get(this);\\n  domCache.confirmButton.disabled = true;\\n  domCache.cancelButton.disabled = true;\\n}\\nfunction enableConfirmButton() {\\n  var domCache = privateProps.domCache.get(this);\\n  domCache.confirmButton.disabled = false;\\n}\\nfunction disableConfirmButton() {\\n  var domCache = privateProps.domCache.get(this);\\n  domCache.confirmButton.disabled = true;\\n}\\nfunction enableInput() {\\n  var input = this.getInput();\\n\\n  if (!input) {\\n    return false;\\n  }\\n\\n  if (input.type === 'radio') {\\n    var radiosContainer = input.parentNode.parentNode;\\n    var radios = radiosContainer.querySelectorAll('input');\\n\\n    for (var i = 0; i < radios.length; i++) {\\n      radios[i].disabled = false;\\n    }\\n  } else {\\n    input.disabled = false;\\n  }\\n}\\nfunction disableInput() {\\n  var input = this.getInput();\\n\\n  if (!input) {\\n    return false;\\n  }\\n\\n  if (input && input.type === 'radio') {\\n    var radiosContainer = input.parentNode.parentNode;\\n    var radios = radiosContainer.querySelectorAll('input');\\n\\n    for (var i = 0; i < radios.length; i++) {\\n      radios[i].disabled = true;\\n    }\\n  } else {\\n    input.disabled = true;\\n  }\\n}\\n\\nfunction showValidationMessage(error) {\\n  var domCache = privateProps.domCache.get(this);\\n  domCache.validationMessage.innerHTML = error;\\n  var popupComputedStyle = window.getComputedStyle(domCache.popup);\\n  domCache.validationMessage.style.marginLeft = \\\"-\\\".concat(popupComputedStyle.getPropertyValue('padding-left'));\\n  domCache.validationMessage.style.marginRight = \\\"-\\\".concat(popupComputedStyle.getPropertyValue('padding-right'));\\n  show(domCache.validationMessage);\\n  var input = this.getInput();\\n\\n  if (input) {\\n    input.setAttribute('aria-invalid', true);\\n    input.setAttribute('aria-describedBy', swalClasses['validation-message']);\\n    focusInput(input);\\n    addClass(input, swalClasses.inputerror);\\n  }\\n} // Hide block with validation message\\n\\nfunction resetValidationMessage() {\\n  var domCache = privateProps.domCache.get(this);\\n\\n  if (domCache.validationMessage) {\\n    hide(domCache.validationMessage);\\n  }\\n\\n  var input = this.getInput();\\n\\n  if (input) {\\n    input.removeAttribute('aria-invalid');\\n    input.removeAttribute('aria-describedBy');\\n    removeClass(input, swalClasses.inputerror);\\n  }\\n}\\n\\nfunction getProgressSteps$1() {\\n  var innerParams = privateProps.innerParams.get(this);\\n  return innerParams.progressSteps;\\n}\\nfunction setProgressSteps(progressSteps) {\\n  var innerParams = privateProps.innerParams.get(this);\\n\\n  var updatedParams = _extends({}, innerParams, {\\n    progressSteps: progressSteps\\n  });\\n\\n  privateProps.innerParams.set(this, updatedParams);\\n  renderProgressSteps(updatedParams);\\n}\\nfunction showProgressSteps() {\\n  var domCache = privateProps.domCache.get(this);\\n  show(domCache.progressSteps);\\n}\\nfunction hideProgressSteps() {\\n  var domCache = privateProps.domCache.get(this);\\n  hide(domCache.progressSteps);\\n}\\n\\nvar Timer = function Timer(callback, delay) {\\n  _classCallCheck(this, Timer);\\n\\n  var id,\\n      started,\\n      remaining = delay;\\n  this.running = false;\\n\\n  this.start = function () {\\n    if (!this.running) {\\n      this.running = true;\\n      started = new Date();\\n      id = setTimeout(callback, remaining);\\n    }\\n\\n    return remaining;\\n  };\\n\\n  this.stop = function () {\\n    if (this.running) {\\n      this.running = false;\\n      clearTimeout(id);\\n      remaining -= new Date() - started;\\n    }\\n\\n    return remaining;\\n  };\\n\\n  this.increase = function (n) {\\n    var running = this.running;\\n\\n    if (running) {\\n      this.stop();\\n    }\\n\\n    remaining += n;\\n\\n    if (running) {\\n      this.start();\\n    }\\n\\n    return remaining;\\n  };\\n\\n  this.getTimerLeft = function () {\\n    if (this.running) {\\n      this.stop();\\n      this.start();\\n    }\\n\\n    return remaining;\\n  };\\n\\n  this.isRunning = function () {\\n    return this.running;\\n  };\\n\\n  this.start();\\n};\\n\\nvar defaultInputValidators = {\\n  email: function email(string, validationMessage) {\\n    return /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z0-9-]{2,24}$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage ? validationMessage : 'Invalid email address');\\n  },\\n  url: function url(string, validationMessage) {\\n    // taken from https://stackoverflow.com/a/3809435 with a small change from #1306\\n    return /^https?:\\\\/\\\\/(www\\\\.)?[-a-zA-Z0-9@:%._+~#=]{2,256}\\\\.[a-z]{2,63}\\\\b([-a-zA-Z0-9@:%_+.~#?&//=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage ? validationMessage : 'Invalid URL');\\n  }\\n};\\n\\n/**\\n * Set type, text and actions on popup\\n *\\n * @param params\\n * @returns {boolean}\\n */\\n\\nfunction setParameters(params) {\\n  // Use default `inputValidator` for supported input types if not provided\\n  if (!params.inputValidator) {\\n    Object.keys(defaultInputValidators).forEach(function (key) {\\n      if (params.input === key) {\\n        params.inputValidator = defaultInputValidators[key];\\n      }\\n    });\\n  } // Determine if the custom target element is valid\\n\\n\\n  if (!params.target || typeof params.target === 'string' && !document.querySelector(params.target) || typeof params.target !== 'string' && !params.target.appendChild) {\\n    warn('Target parameter is not valid, defaulting to \\\"body\\\"');\\n    params.target = 'body';\\n  } // Animation\\n\\n\\n  if (typeof params.animation === 'function') {\\n    params.animation = params.animation.call();\\n  }\\n\\n  var popup;\\n  var oldPopup = getPopup();\\n  var targetElement = typeof params.target === 'string' ? document.querySelector(params.target) : params.target; // If the model target has changed, refresh the popup\\n\\n  if (oldPopup && targetElement && oldPopup.parentNode !== targetElement.parentNode) {\\n    popup = init(params);\\n  } else {\\n    popup = oldPopup || init(params);\\n  } // Set popup width\\n\\n\\n  if (params.width) {\\n    popup.style.width = typeof params.width === 'number' ? params.width + 'px' : params.width;\\n  } // Set popup padding\\n\\n\\n  if (params.padding) {\\n    popup.style.padding = typeof params.padding === 'number' ? params.padding + 'px' : params.padding;\\n  } // Set popup background\\n\\n\\n  if (params.background) {\\n    popup.style.background = params.background;\\n  }\\n\\n  var popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue('background-color');\\n  var successIconParts = popup.querySelectorAll('[class^=swal2-success-circular-line], .swal2-success-fix');\\n\\n  for (var i = 0; i < successIconParts.length; i++) {\\n    successIconParts[i].style.backgroundColor = popupBackgroundColor;\\n  }\\n\\n  var container = getContainer();\\n  var closeButton = getCloseButton();\\n  var footer = getFooter(); // Title\\n\\n  renderTitle(params); // Content\\n\\n  renderContent(params); // Backdrop\\n\\n  if (typeof params.backdrop === 'string') {\\n    getContainer().style.background = params.backdrop;\\n  } else if (!params.backdrop) {\\n    addClass([document.documentElement, document.body], swalClasses['no-backdrop']);\\n  }\\n\\n  if (!params.backdrop && params.allowOutsideClick) {\\n    warn('\\\"allowOutsideClick\\\" parameter requires `backdrop` parameter to be set to `true`');\\n  } // Position\\n\\n\\n  if (params.position in swalClasses) {\\n    addClass(container, swalClasses[params.position]);\\n  } else {\\n    warn('The \\\"position\\\" parameter is not valid, defaulting to \\\"center\\\"');\\n    addClass(container, swalClasses.center);\\n  } // Grow\\n\\n\\n  if (params.grow && typeof params.grow === 'string') {\\n    var growClass = 'grow-' + params.grow;\\n\\n    if (growClass in swalClasses) {\\n      addClass(container, swalClasses[growClass]);\\n    }\\n  } // Close button\\n\\n\\n  if (params.showCloseButton) {\\n    closeButton.setAttribute('aria-label', params.closeButtonAriaLabel);\\n    show(closeButton);\\n  } else {\\n    hide(closeButton);\\n  } // Default Class\\n\\n\\n  popup.className = swalClasses.popup;\\n\\n  if (params.toast) {\\n    addClass([document.documentElement, document.body], swalClasses['toast-shown']);\\n    addClass(popup, swalClasses.toast);\\n  } else {\\n    addClass(popup, swalClasses.modal);\\n  } // Custom Class\\n\\n\\n  if (params.customClass) {\\n    addClass(popup, params.customClass);\\n  }\\n\\n  if (params.customContainerClass) {\\n    addClass(container, params.customContainerClass);\\n  } // Progress steps\\n\\n\\n  renderProgressSteps(params); // Icon\\n\\n  renderIcon(params); // Image\\n\\n  renderImage(params); // Actions (buttons)\\n\\n  renderActions(params); // Footer\\n\\n  parseHtmlToContainer(params.footer, footer); // CSS animation\\n\\n  if (params.animation === true) {\\n    removeClass(popup, swalClasses.noanimation);\\n  } else {\\n    addClass(popup, swalClasses.noanimation);\\n  } // showLoaderOnConfirm && preConfirm\\n\\n\\n  if (params.showLoaderOnConfirm && !params.preConfirm) {\\n    warn('showLoaderOnConfirm is set to true, but preConfirm is not defined.\\\\n' + 'showLoaderOnConfirm should be used together with preConfirm, see usage example:\\\\n' + 'https://sweetalert2.github.io/#ajax-request');\\n  }\\n}\\n\\n/**\\n * Open popup, add necessary classes and styles, fix scrollbar\\n *\\n * @param {Array} params\\n */\\n\\nvar openPopup = function openPopup(params) {\\n  var container = getContainer();\\n  var popup = getPopup();\\n\\n  if (params.onBeforeOpen !== null && typeof params.onBeforeOpen === 'function') {\\n    params.onBeforeOpen(popup);\\n  }\\n\\n  if (params.animation) {\\n    addClass(popup, swalClasses.show);\\n    addClass(container, swalClasses.fade);\\n    removeClass(popup, swalClasses.hide);\\n  } else {\\n    removeClass(popup, swalClasses.fade);\\n  }\\n\\n  show(popup); // scrolling is 'hidden' until animation is done, after that 'auto'\\n\\n  container.style.overflowY = 'hidden';\\n\\n  if (animationEndEvent && !hasClass(popup, swalClasses.noanimation)) {\\n    popup.addEventListener(animationEndEvent, function swalCloseEventFinished() {\\n      popup.removeEventListener(animationEndEvent, swalCloseEventFinished);\\n      container.style.overflowY = 'auto';\\n    });\\n  } else {\\n    container.style.overflowY = 'auto';\\n  }\\n\\n  addClass([document.documentElement, document.body, container], swalClasses.shown);\\n\\n  if (params.heightAuto && params.backdrop && !params.toast) {\\n    addClass([document.documentElement, document.body], swalClasses['height-auto']);\\n  }\\n\\n  if (isModal()) {\\n    fixScrollbar();\\n    iOSfix();\\n    IEfix();\\n    setAriaHidden(); // sweetalert2/issues/1247\\n\\n    setTimeout(function () {\\n      container.scrollTop = 0;\\n    });\\n  }\\n\\n  if (!isToast() && !globalState.previousActiveElement) {\\n    globalState.previousActiveElement = document.activeElement;\\n  }\\n\\n  if (params.onOpen !== null && typeof params.onOpen === 'function') {\\n    setTimeout(function () {\\n      params.onOpen(popup);\\n    });\\n  }\\n};\\n\\nfunction _main(userParams) {\\n  var _this = this;\\n\\n  showWarningsForParams(userParams);\\n\\n  var innerParams = _extends({}, defaultParams, userParams);\\n\\n  setParameters(innerParams);\\n  Object.freeze(innerParams);\\n  privateProps.innerParams.set(this, innerParams); // clear the previous timer\\n\\n  if (globalState.timeout) {\\n    globalState.timeout.stop();\\n    delete globalState.timeout;\\n  } // clear the restore focus timeout\\n\\n\\n  clearTimeout(globalState.restoreFocusTimeout);\\n  var domCache = {\\n    popup: getPopup(),\\n    container: getContainer(),\\n    content: getContent(),\\n    actions: getActions(),\\n    confirmButton: getConfirmButton(),\\n    cancelButton: getCancelButton(),\\n    closeButton: getCloseButton(),\\n    validationMessage: getValidationMessage(),\\n    progressSteps: getProgressSteps()\\n  };\\n  privateProps.domCache.set(this, domCache);\\n  var constructor = this.constructor;\\n  return new Promise(function (resolve) {\\n    // functions to handle all closings/dismissals\\n    var succeedWith = function succeedWith(value) {\\n      _this.closePopup({\\n        value: value\\n      });\\n    };\\n\\n    var dismissWith = function dismissWith(dismiss) {\\n      _this.closePopup({\\n        dismiss: dismiss\\n      });\\n    };\\n\\n    privateMethods.swalPromiseResolve.set(_this, resolve); // Close on timer\\n\\n    if (innerParams.timer) {\\n      globalState.timeout = new Timer(function () {\\n        dismissWith('timer');\\n        delete globalState.timeout;\\n      }, innerParams.timer);\\n    } // Get the value of the popup input\\n\\n\\n    var getInputValue = function getInputValue() {\\n      var input = _this.getInput();\\n\\n      if (!input) {\\n        return null;\\n      }\\n\\n      switch (innerParams.input) {\\n        case 'checkbox':\\n          return input.checked ? 1 : 0;\\n\\n        case 'radio':\\n          return input.checked ? input.value : null;\\n\\n        case 'file':\\n          return input.files.length ? input.files[0] : null;\\n\\n        default:\\n          return innerParams.inputAutoTrim ? input.value.trim() : input.value;\\n      }\\n    }; // input autofocus\\n\\n\\n    if (innerParams.input) {\\n      setTimeout(function () {\\n        var input = _this.getInput();\\n\\n        if (input) {\\n          focusInput(input);\\n        }\\n      }, 0);\\n    }\\n\\n    var confirm = function confirm(value) {\\n      if (innerParams.showLoaderOnConfirm) {\\n        constructor.showLoading(); // TODO: make showLoading an *instance* method\\n      }\\n\\n      if (innerParams.preConfirm) {\\n        _this.resetValidationMessage();\\n\\n        var preConfirmPromise = Promise.resolve().then(function () {\\n          return innerParams.preConfirm(value, innerParams.validationMessage);\\n        });\\n        preConfirmPromise.then(function (preConfirmValue) {\\n          if (isVisible(domCache.validationMessage) || preConfirmValue === false) {\\n            _this.hideLoading();\\n          } else {\\n            succeedWith(preConfirmValue || value);\\n          }\\n        });\\n      } else {\\n        succeedWith(value);\\n      }\\n    }; // Mouse interactions\\n\\n\\n    var onButtonEvent = function onButtonEvent(e) {\\n      var target = e.target;\\n      var confirmButton = domCache.confirmButton,\\n          cancelButton = domCache.cancelButton;\\n      var targetedConfirm = confirmButton && (confirmButton === target || confirmButton.contains(target));\\n      var targetedCancel = cancelButton && (cancelButton === target || cancelButton.contains(target));\\n\\n      switch (e.type) {\\n        case 'click':\\n          // Clicked 'confirm'\\n          if (targetedConfirm && constructor.isVisible()) {\\n            _this.disableButtons();\\n\\n            if (innerParams.input) {\\n              var inputValue = getInputValue();\\n\\n              if (innerParams.inputValidator) {\\n                _this.disableInput();\\n\\n                var validationPromise = Promise.resolve().then(function () {\\n                  return innerParams.inputValidator(inputValue, innerParams.validationMessage);\\n                });\\n                validationPromise.then(function (validationMessage) {\\n                  _this.enableButtons();\\n\\n                  _this.enableInput();\\n\\n                  if (validationMessage) {\\n                    _this.showValidationMessage(validationMessage);\\n                  } else {\\n                    confirm(inputValue);\\n                  }\\n                });\\n              } else if (!_this.getInput().checkValidity()) {\\n                _this.enableButtons();\\n\\n                _this.showValidationMessage(innerParams.validationMessage);\\n              } else {\\n                confirm(inputValue);\\n              }\\n            } else {\\n              confirm(true);\\n            } // Clicked 'cancel'\\n\\n          } else if (targetedCancel && constructor.isVisible()) {\\n            _this.disableButtons();\\n\\n            dismissWith(constructor.DismissReason.cancel);\\n          }\\n\\n          break;\\n\\n        default:\\n      }\\n    };\\n\\n    var buttons = domCache.popup.querySelectorAll('button');\\n\\n    for (var i = 0; i < buttons.length; i++) {\\n      buttons[i].onclick = onButtonEvent;\\n      buttons[i].onmouseover = onButtonEvent;\\n      buttons[i].onmouseout = onButtonEvent;\\n      buttons[i].onmousedown = onButtonEvent;\\n    } // Closing popup by close button\\n\\n\\n    domCache.closeButton.onclick = function () {\\n      dismissWith(constructor.DismissReason.close);\\n    };\\n\\n    if (innerParams.toast) {\\n      // Closing popup by internal click\\n      domCache.popup.onclick = function () {\\n        if (innerParams.showConfirmButton || innerParams.showCancelButton || innerParams.showCloseButton || innerParams.input) {\\n          return;\\n        }\\n\\n        dismissWith(constructor.DismissReason.close);\\n      };\\n    } else {\\n      var ignoreOutsideClick = false; // Ignore click events that had mousedown on the popup but mouseup on the container\\n      // This can happen when the user drags a slider\\n\\n      domCache.popup.onmousedown = function () {\\n        domCache.container.onmouseup = function (e) {\\n          domCache.container.onmouseup = undefined; // We only check if the mouseup target is the container because usually it doesn't\\n          // have any other direct children aside of the popup\\n\\n          if (e.target === domCache.container) {\\n            ignoreOutsideClick = true;\\n          }\\n        };\\n      }; // Ignore click events that had mousedown on the container but mouseup on the popup\\n\\n\\n      domCache.container.onmousedown = function () {\\n        domCache.popup.onmouseup = function (e) {\\n          domCache.popup.onmouseup = undefined; // We also need to check if the mouseup target is a child of the popup\\n\\n          if (e.target === domCache.popup || domCache.popup.contains(e.target)) {\\n            ignoreOutsideClick = true;\\n          }\\n        };\\n      };\\n\\n      domCache.container.onclick = function (e) {\\n        if (ignoreOutsideClick) {\\n          ignoreOutsideClick = false;\\n          return;\\n        }\\n\\n        if (e.target !== domCache.container) {\\n          return;\\n        }\\n\\n        if (callIfFunction(innerParams.allowOutsideClick)) {\\n          dismissWith(constructor.DismissReason.backdrop);\\n        }\\n      };\\n    } // Reverse buttons (Confirm on the right side)\\n\\n\\n    if (innerParams.reverseButtons) {\\n      domCache.confirmButton.parentNode.insertBefore(domCache.cancelButton, domCache.confirmButton);\\n    } else {\\n      domCache.confirmButton.parentNode.insertBefore(domCache.confirmButton, domCache.cancelButton);\\n    } // Focus handling\\n\\n\\n    var setFocus = function setFocus(index, increment) {\\n      var focusableElements = getFocusableElements(innerParams.focusCancel); // search for visible elements and select the next possible match\\n\\n      for (var _i = 0; _i < focusableElements.length; _i++) {\\n        index = index + increment; // rollover to first item\\n\\n        if (index === focusableElements.length) {\\n          index = 0; // go to last item\\n        } else if (index === -1) {\\n          index = focusableElements.length - 1;\\n        }\\n\\n        return focusableElements[index].focus();\\n      } // no visible focusable elements, focus the popup\\n\\n\\n      domCache.popup.focus();\\n    };\\n\\n    var keydownHandler = function keydownHandler(e, innerParams) {\\n      if (innerParams.stopKeydownPropagation) {\\n        e.stopPropagation();\\n      }\\n\\n      var arrowKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Left', 'Right', 'Up', 'Down' // IE11\\n      ];\\n\\n      if (e.key === 'Enter' && !e.isComposing) {\\n        if (e.target && _this.getInput() && e.target.outerHTML === _this.getInput().outerHTML) {\\n          if (['textarea', 'file'].indexOf(innerParams.input) !== -1) {\\n            return; // do not submit\\n          }\\n\\n          constructor.clickConfirm();\\n          e.preventDefault();\\n        } // TAB\\n\\n      } else if (e.key === 'Tab') {\\n        var targetElement = e.target;\\n        var focusableElements = getFocusableElements(innerParams.focusCancel);\\n        var btnIndex = -1;\\n\\n        for (var _i2 = 0; _i2 < focusableElements.length; _i2++) {\\n          if (targetElement === focusableElements[_i2]) {\\n            btnIndex = _i2;\\n            break;\\n          }\\n        }\\n\\n        if (!e.shiftKey) {\\n          // Cycle to the next button\\n          setFocus(btnIndex, 1);\\n        } else {\\n          // Cycle to the prev button\\n          setFocus(btnIndex, -1);\\n        }\\n\\n        e.stopPropagation();\\n        e.preventDefault(); // ARROWS - switch focus between buttons\\n      } else if (arrowKeys.indexOf(e.key) !== -1) {\\n        // focus Cancel button if Confirm button is currently focused\\n        if (document.activeElement === domCache.confirmButton && isVisible(domCache.cancelButton)) {\\n          domCache.cancelButton.focus(); // and vice versa\\n        } else if (document.activeElement === domCache.cancelButton && isVisible(domCache.confirmButton)) {\\n          domCache.confirmButton.focus();\\n        } // ESC\\n\\n      } else if ((e.key === 'Escape' || e.key === 'Esc') && callIfFunction(innerParams.allowEscapeKey) === true) {\\n        e.preventDefault();\\n        dismissWith(constructor.DismissReason.esc);\\n      }\\n    };\\n\\n    if (globalState.keydownHandlerAdded) {\\n      globalState.keydownTarget.removeEventListener('keydown', globalState.keydownHandler, {\\n        capture: globalState.keydownListenerCapture\\n      });\\n      globalState.keydownHandlerAdded = false;\\n    }\\n\\n    if (!innerParams.toast) {\\n      globalState.keydownHandler = function (e) {\\n        return keydownHandler(e, innerParams);\\n      };\\n\\n      globalState.keydownTarget = innerParams.keydownListenerCapture ? window : domCache.popup;\\n      globalState.keydownListenerCapture = innerParams.keydownListenerCapture;\\n      globalState.keydownTarget.addEventListener('keydown', globalState.keydownHandler, {\\n        capture: globalState.keydownListenerCapture\\n      });\\n      globalState.keydownHandlerAdded = true;\\n    }\\n\\n    _this.enableButtons();\\n\\n    _this.hideLoading();\\n\\n    _this.resetValidationMessage();\\n\\n    if (innerParams.toast && (innerParams.input || innerParams.footer || innerParams.showCloseButton)) {\\n      addClass(document.body, swalClasses['toast-column']);\\n    } else {\\n      removeClass(document.body, swalClasses['toast-column']);\\n    } // inputs\\n\\n\\n    var inputTypes = ['input', 'file', 'range', 'select', 'radio', 'checkbox', 'textarea'];\\n\\n    var setInputPlaceholder = function setInputPlaceholder(input) {\\n      if (!input.placeholder || innerParams.inputPlaceholder) {\\n        input.placeholder = innerParams.inputPlaceholder;\\n      }\\n    };\\n\\n    var input;\\n\\n    for (var _i3 = 0; _i3 < inputTypes.length; _i3++) {\\n      var inputClass = swalClasses[inputTypes[_i3]];\\n      var inputContainer = getChildByClass(domCache.content, inputClass);\\n      input = _this.getInput(inputTypes[_i3]); // set attributes\\n\\n      if (input) {\\n        for (var j in input.attributes) {\\n          if (input.attributes.hasOwnProperty(j)) {\\n            var attrName = input.attributes[j].name;\\n\\n            if (attrName !== 'type' && attrName !== 'value') {\\n              input.removeAttribute(attrName);\\n            }\\n          }\\n        }\\n\\n        for (var attr in innerParams.inputAttributes) {\\n          // Do not set a placeholder for <input type=\\\"range\\\">\\n          // it'll crash Edge, #1298\\n          if (inputTypes[_i3] === 'range' && attr === 'placeholder') {\\n            continue;\\n          }\\n\\n          input.setAttribute(attr, innerParams.inputAttributes[attr]);\\n        }\\n      } // set class\\n\\n\\n      inputContainer.className = inputClass;\\n\\n      if (innerParams.inputClass) {\\n        addClass(inputContainer, innerParams.inputClass);\\n      }\\n\\n      hide(inputContainer);\\n    }\\n\\n    var populateInputOptions;\\n\\n    switch (innerParams.input) {\\n      case 'text':\\n      case 'email':\\n      case 'password':\\n      case 'number':\\n      case 'tel':\\n      case 'url':\\n        {\\n          input = getChildByClass(domCache.content, swalClasses.input);\\n\\n          if (typeof innerParams.inputValue === 'string' || typeof innerParams.inputValue === 'number') {\\n            input.value = innerParams.inputValue;\\n          } else if (!isPromise(innerParams.inputValue)) {\\n            warn(\\\"Unexpected type of inputValue! Expected \\\\\\\"string\\\\\\\", \\\\\\\"number\\\\\\\" or \\\\\\\"Promise\\\\\\\", got \\\\\\\"\\\".concat(_typeof(innerParams.inputValue), \\\"\\\\\\\"\\\"));\\n          }\\n\\n          setInputPlaceholder(input);\\n          input.type = innerParams.input;\\n          show(input);\\n          break;\\n        }\\n\\n      case 'file':\\n        {\\n          input = getChildByClass(domCache.content, swalClasses.file);\\n          setInputPlaceholder(input);\\n          input.type = innerParams.input;\\n          show(input);\\n          break;\\n        }\\n\\n      case 'range':\\n        {\\n          var range = getChildByClass(domCache.content, swalClasses.range);\\n          var rangeInput = range.querySelector('input');\\n          var rangeOutput = range.querySelector('output');\\n          rangeInput.value = innerParams.inputValue;\\n          rangeInput.type = innerParams.input;\\n          rangeOutput.value = innerParams.inputValue;\\n          show(range);\\n          break;\\n        }\\n\\n      case 'select':\\n        {\\n          var select = getChildByClass(domCache.content, swalClasses.select);\\n          select.innerHTML = '';\\n\\n          if (innerParams.inputPlaceholder) {\\n            var placeholder = document.createElement('option');\\n            placeholder.innerHTML = innerParams.inputPlaceholder;\\n            placeholder.value = '';\\n            placeholder.disabled = true;\\n            placeholder.selected = true;\\n            select.appendChild(placeholder);\\n          }\\n\\n          populateInputOptions = function populateInputOptions(inputOptions) {\\n            inputOptions.forEach(function (inputOption) {\\n              var optionValue = inputOption[0];\\n              var optionLabel = inputOption[1];\\n              var option = document.createElement('option');\\n              option.value = optionValue;\\n              option.innerHTML = optionLabel;\\n\\n              if (innerParams.inputValue.toString() === optionValue.toString()) {\\n                option.selected = true;\\n              }\\n\\n              select.appendChild(option);\\n            });\\n            show(select);\\n            select.focus();\\n          };\\n\\n          break;\\n        }\\n\\n      case 'radio':\\n        {\\n          var radio = getChildByClass(domCache.content, swalClasses.radio);\\n          radio.innerHTML = '';\\n\\n          populateInputOptions = function populateInputOptions(inputOptions) {\\n            inputOptions.forEach(function (inputOption) {\\n              var radioValue = inputOption[0];\\n              var radioLabel = inputOption[1];\\n              var radioInput = document.createElement('input');\\n              var radioLabelElement = document.createElement('label');\\n              radioInput.type = 'radio';\\n              radioInput.name = swalClasses.radio;\\n              radioInput.value = radioValue;\\n\\n              if (innerParams.inputValue.toString() === radioValue.toString()) {\\n                radioInput.checked = true;\\n              }\\n\\n              var label = document.createElement('span');\\n              label.innerHTML = radioLabel;\\n              label.className = swalClasses.label;\\n              radioLabelElement.appendChild(radioInput);\\n              radioLabelElement.appendChild(label);\\n              radio.appendChild(radioLabelElement);\\n            });\\n            show(radio);\\n            var radios = radio.querySelectorAll('input');\\n\\n            if (radios.length) {\\n              radios[0].focus();\\n            }\\n          };\\n\\n          break;\\n        }\\n\\n      case 'checkbox':\\n        {\\n          var checkbox = getChildByClass(domCache.content, swalClasses.checkbox);\\n\\n          var checkboxInput = _this.getInput('checkbox');\\n\\n          checkboxInput.type = 'checkbox';\\n          checkboxInput.value = 1;\\n          checkboxInput.id = swalClasses.checkbox;\\n          checkboxInput.checked = Boolean(innerParams.inputValue);\\n          var label = checkbox.querySelector('span');\\n          label.innerHTML = innerParams.inputPlaceholder;\\n          show(checkbox);\\n          break;\\n        }\\n\\n      case 'textarea':\\n        {\\n          var textarea = getChildByClass(domCache.content, swalClasses.textarea);\\n          textarea.value = innerParams.inputValue;\\n          setInputPlaceholder(textarea);\\n          show(textarea);\\n          break;\\n        }\\n\\n      case null:\\n        {\\n          break;\\n        }\\n\\n      default:\\n        error(\\\"Unexpected type of input! Expected \\\\\\\"text\\\\\\\", \\\\\\\"email\\\\\\\", \\\\\\\"password\\\\\\\", \\\\\\\"number\\\\\\\", \\\\\\\"tel\\\\\\\", \\\\\\\"select\\\\\\\", \\\\\\\"radio\\\\\\\", \\\\\\\"checkbox\\\\\\\", \\\\\\\"textarea\\\\\\\", \\\\\\\"file\\\\\\\" or \\\\\\\"url\\\\\\\", got \\\\\\\"\\\".concat(innerParams.input, \\\"\\\\\\\"\\\"));\\n        break;\\n    }\\n\\n    if (innerParams.input === 'select' || innerParams.input === 'radio') {\\n      var processInputOptions = function processInputOptions(inputOptions) {\\n        return populateInputOptions(formatInputOptions(inputOptions));\\n      };\\n\\n      if (isPromise(innerParams.inputOptions)) {\\n        constructor.showLoading();\\n        innerParams.inputOptions.then(function (inputOptions) {\\n          _this.hideLoading();\\n\\n          processInputOptions(inputOptions);\\n        });\\n      } else if (_typeof(innerParams.inputOptions) === 'object') {\\n        processInputOptions(innerParams.inputOptions);\\n      } else {\\n        error(\\\"Unexpected type of inputOptions! Expected object, Map or Promise, got \\\".concat(_typeof(innerParams.inputOptions)));\\n      }\\n    } else if (['text', 'email', 'number', 'tel', 'textarea'].indexOf(innerParams.input) !== -1 && isPromise(innerParams.inputValue)) {\\n      constructor.showLoading();\\n      hide(input);\\n      innerParams.inputValue.then(function (inputValue) {\\n        input.value = innerParams.input === 'number' ? parseFloat(inputValue) || 0 : inputValue + '';\\n        show(input);\\n        input.focus();\\n\\n        _this.hideLoading();\\n      }).catch(function (err) {\\n        error('Error in inputValue promise: ' + err);\\n        input.value = '';\\n        show(input);\\n        input.focus();\\n\\n        _this.hideLoading();\\n      });\\n    }\\n\\n    openPopup(innerParams);\\n\\n    if (!innerParams.toast) {\\n      if (!callIfFunction(innerParams.allowEnterKey)) {\\n        if (document.activeElement && typeof document.activeElement.blur === 'function') {\\n          document.activeElement.blur();\\n        }\\n      } else if (innerParams.focusCancel && isVisible(domCache.cancelButton)) {\\n        domCache.cancelButton.focus();\\n      } else if (innerParams.focusConfirm && isVisible(domCache.confirmButton)) {\\n        domCache.confirmButton.focus();\\n      } else {\\n        setFocus(-1, 1);\\n      }\\n    } // fix scroll\\n\\n\\n    domCache.container.scrollTop = 0;\\n  });\\n}\\n\\n/**\\n * Updates popup options.\\n */\\n\\nfunction update(params) {\\n  var validUpdatableParams = {}; // assign valid params from `params` to `defaults`\\n\\n  Object.keys(params).forEach(function (param) {\\n    if (Swal.isUpdatableParameter(param)) {\\n      validUpdatableParams[param] = params[param];\\n    } else {\\n      warn(\\\"Invalid parameter to update: \\\\\\\"\\\".concat(param, \\\"\\\\\\\". Updatable params are listed here: TODO (@limonte) add link\\\"));\\n    }\\n  });\\n  var innerParams = privateProps.innerParams.get(this);\\n\\n  var updatedParams = _extends({}, innerParams, validUpdatableParams); // Actions\\n\\n\\n  renderActions(updatedParams); // Content\\n\\n  renderContent(updatedParams); // Icon\\n\\n  renderIcon(updatedParams); // Image\\n\\n  renderImage(updatedParams); // Progress steps\\n\\n  renderProgressSteps(updatedParams); // Title\\n\\n  renderTitle(updatedParams);\\n  privateProps.innerParams.set(this, updatedParams);\\n}\\n\\n\\n\\nvar instanceMethods = Object.freeze({\\n\\thideLoading: hideLoading,\\n\\tdisableLoading: hideLoading,\\n\\tgetInput: getInput,\\n\\tclose: close,\\n\\tclosePopup: close,\\n\\tcloseModal: close,\\n\\tcloseToast: close,\\n\\tenableButtons: enableButtons,\\n\\tdisableButtons: disableButtons,\\n\\tenableConfirmButton: enableConfirmButton,\\n\\tdisableConfirmButton: disableConfirmButton,\\n\\tenableInput: enableInput,\\n\\tdisableInput: disableInput,\\n\\tshowValidationMessage: showValidationMessage,\\n\\tresetValidationMessage: resetValidationMessage,\\n\\tgetProgressSteps: getProgressSteps$1,\\n\\tsetProgressSteps: setProgressSteps,\\n\\tshowProgressSteps: showProgressSteps,\\n\\thideProgressSteps: hideProgressSteps,\\n\\t_main: _main,\\n\\tupdate: update\\n});\\n\\nvar currentInstance; // SweetAlert constructor\\n\\nfunction SweetAlert() {\\n  // Prevent run in Node env\\n\\n  /* istanbul ignore if */\\n  if (typeof window === 'undefined') {\\n    return;\\n  } // Check for the existence of Promise\\n\\n  /* istanbul ignore if */\\n\\n\\n  if (typeof Promise === 'undefined') {\\n    error('This package requires a Promise library, please include a shim to enable it in this browser (See: https://github.com/sweetalert2/sweetalert2/wiki/Migration-from-SweetAlert-to-SweetAlert2#1-ie-support)');\\n  }\\n\\n  currentInstance = this;\\n\\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\\n    args[_key] = arguments[_key];\\n  }\\n\\n  var outerParams = Object.freeze(this.constructor.argsToParams(args));\\n  Object.defineProperties(this, {\\n    params: {\\n      value: outerParams,\\n      writable: false,\\n      enumerable: true\\n    }\\n  });\\n\\n  var promise = this._main(this.params);\\n\\n  privateProps.promise.set(this, promise);\\n} // `catch` cannot be the name of a module export, so we define our thenable methods here instead\\n\\n\\nSweetAlert.prototype.then = function (onFulfilled) {\\n  var promise = privateProps.promise.get(this);\\n  return promise.then(onFulfilled);\\n};\\n\\nSweetAlert.prototype.finally = function (onFinally) {\\n  var promise = privateProps.promise.get(this);\\n  return promise.finally(onFinally);\\n}; // Assign instance methods from src/instanceMethods/*.js to prototype\\n\\n\\n_extends(SweetAlert.prototype, instanceMethods); // Assign static methods from src/staticMethods/*.js to constructor\\n\\n\\n_extends(SweetAlert, staticMethods); // Proxy to instance methods to constructor, for now, for backwards compatibility\\n\\n\\nObject.keys(instanceMethods).forEach(function (key) {\\n  SweetAlert[key] = function () {\\n    if (currentInstance) {\\n      var _currentInstance;\\n\\n      return (_currentInstance = currentInstance)[key].apply(_currentInstance, arguments);\\n    }\\n  };\\n});\\nSweetAlert.DismissReason = DismissReason;\\n\\nvar Swal = SweetAlert;\\nSwal.default = Swal;\\n\\nreturn Swal;\\n\\n})));\\nif (typeof window !== 'undefined' && window.Sweetalert2){  window.Sweetalert2.version = '8.0.1';  window.swal = window.sweetAlert = window.Swal = window.SweetAlert = window.Sweetalert2}\\n\\n\\n//# sourceURL=webpack:///./node_modules/sweetalert2/dist/sweetalert2.js?\")},\"./node_modules/swiper/dist/js/swiper.js\":function(module,exports,__webpack_require__){eval(\"/**\\n * Swiper 4.4.6\\n * Most modern mobile touch slider and framework with hardware accelerated transitions\\n * http://www.idangero.us/swiper/\\n *\\n * Copyright 2014-2018 Vladimir Kharlampidi\\n *\\n * Released under the MIT License\\n *\\n * Released on: December 19, 2018\\n */\\n\\n(function (global, factory) {\\n   true ? module.exports = factory() :\\n  undefined;\\n}(this, (function () { 'use strict';\\n\\n  /**\\n   * SSR Window 1.0.1\\n   * Better handling for window object in SSR environment\\n   * https://github.com/nolimits4web/ssr-window\\n   *\\n   * Copyright 2018, Vladimir Kharlampidi\\n   *\\n   * Licensed under MIT\\n   *\\n   * Released on: July 18, 2018\\n   */\\n  var doc = (typeof document === 'undefined') ? {\\n    body: {},\\n    addEventListener: function addEventListener() {},\\n    removeEventListener: function removeEventListener() {},\\n    activeElement: {\\n      blur: function blur() {},\\n      nodeName: '',\\n    },\\n    querySelector: function querySelector() {\\n      return null;\\n    },\\n    querySelectorAll: function querySelectorAll() {\\n      return [];\\n    },\\n    getElementById: function getElementById() {\\n      return null;\\n    },\\n    createEvent: function createEvent() {\\n      return {\\n        initEvent: function initEvent() {},\\n      };\\n    },\\n    createElement: function createElement() {\\n      return {\\n        children: [],\\n        childNodes: [],\\n        style: {},\\n        setAttribute: function setAttribute() {},\\n        getElementsByTagName: function getElementsByTagName() {\\n          return [];\\n        },\\n      };\\n    },\\n    location: { hash: '' },\\n  } : document; // eslint-disable-line\\n\\n  var win = (typeof window === 'undefined') ? {\\n    document: doc,\\n    navigator: {\\n      userAgent: '',\\n    },\\n    location: {},\\n    history: {},\\n    CustomEvent: function CustomEvent() {\\n      return this;\\n    },\\n    addEventListener: function addEventListener() {},\\n    removeEventListener: function removeEventListener() {},\\n    getComputedStyle: function getComputedStyle() {\\n      return {\\n        getPropertyValue: function getPropertyValue() {\\n          return '';\\n        },\\n      };\\n    },\\n    Image: function Image() {},\\n    Date: function Date() {},\\n    screen: {},\\n    setTimeout: function setTimeout() {},\\n    clearTimeout: function clearTimeout() {},\\n  } : window; // eslint-disable-line\\n\\n  /**\\n   * Dom7 2.1.2\\n   * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API\\n   * http://framework7.io/docs/dom.html\\n   *\\n   * Copyright 2018, Vladimir Kharlampidi\\n   * The iDangero.us\\n   * http://www.idangero.us/\\n   *\\n   * Licensed under MIT\\n   *\\n   * Released on: September 13, 2018\\n   */\\n\\n  var Dom7 = function Dom7(arr) {\\n    var self = this;\\n    // Create array-like object\\n    for (var i = 0; i < arr.length; i += 1) {\\n      self[i] = arr[i];\\n    }\\n    self.length = arr.length;\\n    // Return collection with methods\\n    return this;\\n  };\\n\\n  function $(selector, context) {\\n    var arr = [];\\n    var i = 0;\\n    if (selector && !context) {\\n      if (selector instanceof Dom7) {\\n        return selector;\\n      }\\n    }\\n    if (selector) {\\n        // String\\n      if (typeof selector === 'string') {\\n        var els;\\n        var tempParent;\\n        var html = selector.trim();\\n        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {\\n          var toCreate = 'div';\\n          if (html.indexOf('<li') === 0) { toCreate = 'ul'; }\\n          if (html.indexOf('<tr') === 0) { toCreate = 'tbody'; }\\n          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) { toCreate = 'tr'; }\\n          if (html.indexOf('<tbody') === 0) { toCreate = 'table'; }\\n          if (html.indexOf('<option') === 0) { toCreate = 'select'; }\\n          tempParent = doc.createElement(toCreate);\\n          tempParent.innerHTML = html;\\n          for (i = 0; i < tempParent.childNodes.length; i += 1) {\\n            arr.push(tempParent.childNodes[i]);\\n          }\\n        } else {\\n          if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {\\n            // Pure ID selector\\n            els = [doc.getElementById(selector.trim().split('#')[1])];\\n          } else {\\n            // Other selectors\\n            els = (context || doc).querySelectorAll(selector.trim());\\n          }\\n          for (i = 0; i < els.length; i += 1) {\\n            if (els[i]) { arr.push(els[i]); }\\n          }\\n        }\\n      } else if (selector.nodeType || selector === win || selector === doc) {\\n        // Node/element\\n        arr.push(selector);\\n      } else if (selector.length > 0 && selector[0].nodeType) {\\n        // Array of elements or instance of Dom\\n        for (i = 0; i < selector.length; i += 1) {\\n          arr.push(selector[i]);\\n        }\\n      }\\n    }\\n    return new Dom7(arr);\\n  }\\n\\n  $.fn = Dom7.prototype;\\n  $.Class = Dom7;\\n  $.Dom7 = Dom7;\\n\\n  function unique(arr) {\\n    var uniqueArray = [];\\n    for (var i = 0; i < arr.length; i += 1) {\\n      if (uniqueArray.indexOf(arr[i]) === -1) { uniqueArray.push(arr[i]); }\\n    }\\n    return uniqueArray;\\n  }\\n\\n  // Classes and attributes\\n  function addClass(className) {\\n    if (typeof className === 'undefined') {\\n      return this;\\n    }\\n    var classes = className.split(' ');\\n    for (var i = 0; i < classes.length; i += 1) {\\n      for (var j = 0; j < this.length; j += 1) {\\n        if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') { this[j].classList.add(classes[i]); }\\n      }\\n    }\\n    return this;\\n  }\\n  function removeClass(className) {\\n    var classes = className.split(' ');\\n    for (var i = 0; i < classes.length; i += 1) {\\n      for (var j = 0; j < this.length; j += 1) {\\n        if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') { this[j].classList.remove(classes[i]); }\\n      }\\n    }\\n    return this;\\n  }\\n  function hasClass(className) {\\n    if (!this[0]) { return false; }\\n    return this[0].classList.contains(className);\\n  }\\n  function toggleClass(className) {\\n    var classes = className.split(' ');\\n    for (var i = 0; i < classes.length; i += 1) {\\n      for (var j = 0; j < this.length; j += 1) {\\n        if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') { this[j].classList.toggle(classes[i]); }\\n      }\\n    }\\n    return this;\\n  }\\n  function attr(attrs, value) {\\n    var arguments$1 = arguments;\\n\\n    if (arguments.length === 1 && typeof attrs === 'string') {\\n      // Get attr\\n      if (this[0]) { return this[0].getAttribute(attrs); }\\n      return undefined;\\n    }\\n\\n    // Set attrs\\n    for (var i = 0; i < this.length; i += 1) {\\n      if (arguments$1.length === 2) {\\n        // String\\n        this[i].setAttribute(attrs, value);\\n      } else {\\n        // Object\\n        // eslint-disable-next-line\\n        for (var attrName in attrs) {\\n          this[i][attrName] = attrs[attrName];\\n          this[i].setAttribute(attrName, attrs[attrName]);\\n        }\\n      }\\n    }\\n    return this;\\n  }\\n  // eslint-disable-next-line\\n  function removeAttr(attr) {\\n    for (var i = 0; i < this.length; i += 1) {\\n      this[i].removeAttribute(attr);\\n    }\\n    return this;\\n  }\\n  function data(key, value) {\\n    var el;\\n    if (typeof value === 'undefined') {\\n      el = this[0];\\n      // Get value\\n      if (el) {\\n        if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {\\n          return el.dom7ElementDataStorage[key];\\n        }\\n\\n        var dataKey = el.getAttribute((\\\"data-\\\" + key));\\n        if (dataKey) {\\n          return dataKey;\\n        }\\n        return undefined;\\n      }\\n      return undefined;\\n    }\\n\\n    // Set value\\n    for (var i = 0; i < this.length; i += 1) {\\n      el = this[i];\\n      if (!el.dom7ElementDataStorage) { el.dom7ElementDataStorage = {}; }\\n      el.dom7ElementDataStorage[key] = value;\\n    }\\n    return this;\\n  }\\n  // Transforms\\n  // eslint-disable-next-line\\n  function transform(transform) {\\n    for (var i = 0; i < this.length; i += 1) {\\n      var elStyle = this[i].style;\\n      elStyle.webkitTransform = transform;\\n      elStyle.transform = transform;\\n    }\\n    return this;\\n  }\\n  function transition(duration) {\\n    if (typeof duration !== 'string') {\\n      duration = duration + \\\"ms\\\"; // eslint-disable-line\\n    }\\n    for (var i = 0; i < this.length; i += 1) {\\n      var elStyle = this[i].style;\\n      elStyle.webkitTransitionDuration = duration;\\n      elStyle.transitionDuration = duration;\\n    }\\n    return this;\\n  }\\n  // Events\\n  function on() {\\n    var assign;\\n\\n    var args = [], len = arguments.length;\\n    while ( len-- ) args[ len ] = arguments[ len ];\\n    var eventType = args[0];\\n    var targetSelector = args[1];\\n    var listener = args[2];\\n    var capture = args[3];\\n    if (typeof args[1] === 'function') {\\n      (assign = args, eventType = assign[0], listener = assign[1], capture = assign[2]);\\n      targetSelector = undefined;\\n    }\\n    if (!capture) { capture = false; }\\n\\n    function handleLiveEvent(e) {\\n      var target = e.target;\\n      if (!target) { return; }\\n      var eventData = e.target.dom7EventData || [];\\n      if (eventData.indexOf(e) < 0) {\\n        eventData.unshift(e);\\n      }\\n      if ($(target).is(targetSelector)) { listener.apply(target, eventData); }\\n      else {\\n        var parents = $(target).parents(); // eslint-disable-line\\n        for (var k = 0; k < parents.length; k += 1) {\\n          if ($(parents[k]).is(targetSelector)) { listener.apply(parents[k], eventData); }\\n        }\\n      }\\n    }\\n    function handleEvent(e) {\\n      var eventData = e && e.target ? e.target.dom7EventData || [] : [];\\n      if (eventData.indexOf(e) < 0) {\\n        eventData.unshift(e);\\n      }\\n      listener.apply(this, eventData);\\n    }\\n    var events = eventType.split(' ');\\n    var j;\\n    for (var i = 0; i < this.length; i += 1) {\\n      var el = this[i];\\n      if (!targetSelector) {\\n        for (j = 0; j < events.length; j += 1) {\\n          var event = events[j];\\n          if (!el.dom7Listeners) { el.dom7Listeners = {}; }\\n          if (!el.dom7Listeners[event]) { el.dom7Listeners[event] = []; }\\n          el.dom7Listeners[event].push({\\n            listener: listener,\\n            proxyListener: handleEvent,\\n          });\\n          el.addEventListener(event, handleEvent, capture);\\n        }\\n      } else {\\n        // Live events\\n        for (j = 0; j < events.length; j += 1) {\\n          var event$1 = events[j];\\n          if (!el.dom7LiveListeners) { el.dom7LiveListeners = {}; }\\n          if (!el.dom7LiveListeners[event$1]) { el.dom7LiveListeners[event$1] = []; }\\n          el.dom7LiveListeners[event$1].push({\\n            listener: listener,\\n            proxyListener: handleLiveEvent,\\n          });\\n          el.addEventListener(event$1, handleLiveEvent, capture);\\n        }\\n      }\\n    }\\n    return this;\\n  }\\n  function off() {\\n    var assign;\\n\\n    var args = [], len = arguments.length;\\n    while ( len-- ) args[ len ] = arguments[ len ];\\n    var eventType = args[0];\\n    var targetSelector = args[1];\\n    var listener = args[2];\\n    var capture = args[3];\\n    if (typeof args[1] === 'function') {\\n      (assign = args, eventType = assign[0], listener = assign[1], capture = assign[2]);\\n      targetSelector = undefined;\\n    }\\n    if (!capture) { capture = false; }\\n\\n    var events = eventType.split(' ');\\n    for (var i = 0; i < events.length; i += 1) {\\n      var event = events[i];\\n      for (var j = 0; j < this.length; j += 1) {\\n        var el = this[j];\\n        var handlers = (void 0);\\n        if (!targetSelector && el.dom7Listeners) {\\n          handlers = el.dom7Listeners[event];\\n        } else if (targetSelector && el.dom7LiveListeners) {\\n          handlers = el.dom7LiveListeners[event];\\n        }\\n        if (handlers && handlers.length) {\\n          for (var k = handlers.length - 1; k >= 0; k -= 1) {\\n            var handler = handlers[k];\\n            if (listener && handler.listener === listener) {\\n              el.removeEventListener(event, handler.proxyListener, capture);\\n              handlers.splice(k, 1);\\n            } else if (!listener) {\\n              el.removeEventListener(event, handler.proxyListener, capture);\\n              handlers.splice(k, 1);\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return this;\\n  }\\n  function trigger() {\\n    var args = [], len = arguments.length;\\n    while ( len-- ) args[ len ] = arguments[ len ];\\n\\n    var events = args[0].split(' ');\\n    var eventData = args[1];\\n    for (var i = 0; i < events.length; i += 1) {\\n      var event = events[i];\\n      for (var j = 0; j < this.length; j += 1) {\\n        var el = this[j];\\n        var evt = (void 0);\\n        try {\\n          evt = new win.CustomEvent(event, {\\n            detail: eventData,\\n            bubbles: true,\\n            cancelable: true,\\n          });\\n        } catch (e) {\\n          evt = doc.createEvent('Event');\\n          evt.initEvent(event, true, true);\\n          evt.detail = eventData;\\n        }\\n        // eslint-disable-next-line\\n        el.dom7EventData = args.filter(function (data, dataIndex) { return dataIndex > 0; });\\n        el.dispatchEvent(evt);\\n        el.dom7EventData = [];\\n        delete el.dom7EventData;\\n      }\\n    }\\n    return this;\\n  }\\n  function transitionEnd(callback) {\\n    var events = ['webkitTransitionEnd', 'transitionend'];\\n    var dom = this;\\n    var i;\\n    function fireCallBack(e) {\\n      /* jshint validthis:true */\\n      if (e.target !== this) { return; }\\n      callback.call(this, e);\\n      for (i = 0; i < events.length; i += 1) {\\n        dom.off(events[i], fireCallBack);\\n      }\\n    }\\n    if (callback) {\\n      for (i = 0; i < events.length; i += 1) {\\n        dom.on(events[i], fireCallBack);\\n      }\\n    }\\n    return this;\\n  }\\n  function outerWidth(includeMargins) {\\n    if (this.length > 0) {\\n      if (includeMargins) {\\n        // eslint-disable-next-line\\n        var styles = this.styles();\\n        return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));\\n      }\\n      return this[0].offsetWidth;\\n    }\\n    return null;\\n  }\\n  function outerHeight(includeMargins) {\\n    if (this.length > 0) {\\n      if (includeMargins) {\\n        // eslint-disable-next-line\\n        var styles = this.styles();\\n        return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));\\n      }\\n      return this[0].offsetHeight;\\n    }\\n    return null;\\n  }\\n  function offset() {\\n    if (this.length > 0) {\\n      var el = this[0];\\n      var box = el.getBoundingClientRect();\\n      var body = doc.body;\\n      var clientTop = el.clientTop || body.clientTop || 0;\\n      var clientLeft = el.clientLeft || body.clientLeft || 0;\\n      var scrollTop = el === win ? win.scrollY : el.scrollTop;\\n      var scrollLeft = el === win ? win.scrollX : el.scrollLeft;\\n      return {\\n        top: (box.top + scrollTop) - clientTop,\\n        left: (box.left + scrollLeft) - clientLeft,\\n      };\\n    }\\n\\n    return null;\\n  }\\n  function styles() {\\n    if (this[0]) { return win.getComputedStyle(this[0], null); }\\n    return {};\\n  }\\n  function css(props, value) {\\n    var i;\\n    if (arguments.length === 1) {\\n      if (typeof props === 'string') {\\n        if (this[0]) { return win.getComputedStyle(this[0], null).getPropertyValue(props); }\\n      } else {\\n        for (i = 0; i < this.length; i += 1) {\\n          // eslint-disable-next-line\\n          for (var prop in props) {\\n            this[i].style[prop] = props[prop];\\n          }\\n        }\\n        return this;\\n      }\\n    }\\n    if (arguments.length === 2 && typeof props === 'string') {\\n      for (i = 0; i < this.length; i += 1) {\\n        this[i].style[props] = value;\\n      }\\n      return this;\\n    }\\n    return this;\\n  }\\n  // Iterate over the collection passing elements to `callback`\\n  function each(callback) {\\n    // Don't bother continuing without a callback\\n    if (!callback) { return this; }\\n    // Iterate over the current collection\\n    for (var i = 0; i < this.length; i += 1) {\\n      // If the callback returns false\\n      if (callback.call(this[i], i, this[i]) === false) {\\n        // End the loop early\\n        return this;\\n      }\\n    }\\n    // Return `this` to allow chained DOM operations\\n    return this;\\n  }\\n  // eslint-disable-next-line\\n  function html(html) {\\n    if (typeof html === 'undefined') {\\n      return this[0] ? this[0].innerHTML : undefined;\\n    }\\n\\n    for (var i = 0; i < this.length; i += 1) {\\n      this[i].innerHTML = html;\\n    }\\n    return this;\\n  }\\n  // eslint-disable-next-line\\n  function text(text) {\\n    if (typeof text === 'undefined') {\\n      if (this[0]) {\\n        return this[0].textContent.trim();\\n      }\\n      return null;\\n    }\\n\\n    for (var i = 0; i < this.length; i += 1) {\\n      this[i].textContent = text;\\n    }\\n    return this;\\n  }\\n  function is(selector) {\\n    var el = this[0];\\n    var compareWith;\\n    var i;\\n    if (!el || typeof selector === 'undefined') { return false; }\\n    if (typeof selector === 'string') {\\n      if (el.matches) { return el.matches(selector); }\\n      else if (el.webkitMatchesSelector) { return el.webkitMatchesSelector(selector); }\\n      else if (el.msMatchesSelector) { return el.msMatchesSelector(selector); }\\n\\n      compareWith = $(selector);\\n      for (i = 0; i < compareWith.length; i += 1) {\\n        if (compareWith[i] === el) { return true; }\\n      }\\n      return false;\\n    } else if (selector === doc) { return el === doc; }\\n    else if (selector === win) { return el === win; }\\n\\n    if (selector.nodeType || selector instanceof Dom7) {\\n      compareWith = selector.nodeType ? [selector] : selector;\\n      for (i = 0; i < compareWith.length; i += 1) {\\n        if (compareWith[i] === el) { return true; }\\n      }\\n      return false;\\n    }\\n    return false;\\n  }\\n  function index() {\\n    var child = this[0];\\n    var i;\\n    if (child) {\\n      i = 0;\\n      // eslint-disable-next-line\\n      while ((child = child.previousSibling) !== null) {\\n        if (child.nodeType === 1) { i += 1; }\\n      }\\n      return i;\\n    }\\n    return undefined;\\n  }\\n  // eslint-disable-next-line\\n  function eq(index) {\\n    if (typeof index === 'undefined') { return this; }\\n    var length = this.length;\\n    var returnIndex;\\n    if (index > length - 1) {\\n      return new Dom7([]);\\n    }\\n    if (index < 0) {\\n      returnIndex = length + index;\\n      if (returnIndex < 0) { return new Dom7([]); }\\n      return new Dom7([this[returnIndex]]);\\n    }\\n    return new Dom7([this[index]]);\\n  }\\n  function append() {\\n    var args = [], len = arguments.length;\\n    while ( len-- ) args[ len ] = arguments[ len ];\\n\\n    var newChild;\\n\\n    for (var k = 0; k < args.length; k += 1) {\\n      newChild = args[k];\\n      for (var i = 0; i < this.length; i += 1) {\\n        if (typeof newChild === 'string') {\\n          var tempDiv = doc.createElement('div');\\n          tempDiv.innerHTML = newChild;\\n          while (tempDiv.firstChild) {\\n            this[i].appendChild(tempDiv.firstChild);\\n          }\\n        } else if (newChild instanceof Dom7) {\\n          for (var j = 0; j < newChild.length; j += 1) {\\n            this[i].appendChild(newChild[j]);\\n          }\\n        } else {\\n          this[i].appendChild(newChild);\\n        }\\n      }\\n    }\\n\\n    return this;\\n  }\\n  function prepend(newChild) {\\n    var i;\\n    var j;\\n    for (i = 0; i < this.length; i += 1) {\\n      if (typeof newChild === 'string') {\\n        var tempDiv = doc.createElement('div');\\n        tempDiv.innerHTML = newChild;\\n        for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {\\n          this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);\\n        }\\n      } else if (newChild instanceof Dom7) {\\n        for (j = 0; j < newChild.length; j += 1) {\\n          this[i].insertBefore(newChild[j], this[i].childNodes[0]);\\n        }\\n      } else {\\n        this[i].insertBefore(newChild, this[i].childNodes[0]);\\n      }\\n    }\\n    return this;\\n  }\\n  function next(selector) {\\n    if (this.length > 0) {\\n      if (selector) {\\n        if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {\\n          return new Dom7([this[0].nextElementSibling]);\\n        }\\n        return new Dom7([]);\\n      }\\n\\n      if (this[0].nextElementSibling) { return new Dom7([this[0].nextElementSibling]); }\\n      return new Dom7([]);\\n    }\\n    return new Dom7([]);\\n  }\\n  function nextAll(selector) {\\n    var nextEls = [];\\n    var el = this[0];\\n    if (!el) { return new Dom7([]); }\\n    while (el.nextElementSibling) {\\n      var next = el.nextElementSibling; // eslint-disable-line\\n      if (selector) {\\n        if ($(next).is(selector)) { nextEls.push(next); }\\n      } else { nextEls.push(next); }\\n      el = next;\\n    }\\n    return new Dom7(nextEls);\\n  }\\n  function prev(selector) {\\n    if (this.length > 0) {\\n      var el = this[0];\\n      if (selector) {\\n        if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {\\n          return new Dom7([el.previousElementSibling]);\\n        }\\n        return new Dom7([]);\\n      }\\n\\n      if (el.previousElementSibling) { return new Dom7([el.previousElementSibling]); }\\n      return new Dom7([]);\\n    }\\n    return new Dom7([]);\\n  }\\n  function prevAll(selector) {\\n    var prevEls = [];\\n    var el = this[0];\\n    if (!el) { return new Dom7([]); }\\n    while (el.previousElementSibling) {\\n      var prev = el.previousElementSibling; // eslint-disable-line\\n      if (selector) {\\n        if ($(prev).is(selector)) { prevEls.push(prev); }\\n      } else { prevEls.push(prev); }\\n      el = prev;\\n    }\\n    return new Dom7(prevEls);\\n  }\\n  function parent(selector) {\\n    var parents = []; // eslint-disable-line\\n    for (var i = 0; i < this.length; i += 1) {\\n      if (this[i].parentNode !== null) {\\n        if (selector) {\\n          if ($(this[i].parentNode).is(selector)) { parents.push(this[i].parentNode); }\\n        } else {\\n          parents.push(this[i].parentNode);\\n        }\\n      }\\n    }\\n    return $(unique(parents));\\n  }\\n  function parents(selector) {\\n    var parents = []; // eslint-disable-line\\n    for (var i = 0; i < this.length; i += 1) {\\n      var parent = this[i].parentNode; // eslint-disable-line\\n      while (parent) {\\n        if (selector) {\\n          if ($(parent).is(selector)) { parents.push(parent); }\\n        } else {\\n          parents.push(parent);\\n        }\\n        parent = parent.parentNode;\\n      }\\n    }\\n    return $(unique(parents));\\n  }\\n  function closest(selector) {\\n    var closest = this; // eslint-disable-line\\n    if (typeof selector === 'undefined') {\\n      return new Dom7([]);\\n    }\\n    if (!closest.is(selector)) {\\n      closest = closest.parents(selector).eq(0);\\n    }\\n    return closest;\\n  }\\n  function find(selector) {\\n    var foundElements = [];\\n    for (var i = 0; i < this.length; i += 1) {\\n      var found = this[i].querySelectorAll(selector);\\n      for (var j = 0; j < found.length; j += 1) {\\n        foundElements.push(found[j]);\\n      }\\n    }\\n    return new Dom7(foundElements);\\n  }\\n  function children(selector) {\\n    var children = []; // eslint-disable-line\\n    for (var i = 0; i < this.length; i += 1) {\\n      var childNodes = this[i].childNodes;\\n\\n      for (var j = 0; j < childNodes.length; j += 1) {\\n        if (!selector) {\\n          if (childNodes[j].nodeType === 1) { children.push(childNodes[j]); }\\n        } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {\\n          children.push(childNodes[j]);\\n        }\\n      }\\n    }\\n    return new Dom7(unique(children));\\n  }\\n  function remove() {\\n    for (var i = 0; i < this.length; i += 1) {\\n      if (this[i].parentNode) { this[i].parentNode.removeChild(this[i]); }\\n    }\\n    return this;\\n  }\\n  function add() {\\n    var args = [], len = arguments.length;\\n    while ( len-- ) args[ len ] = arguments[ len ];\\n\\n    var dom = this;\\n    var i;\\n    var j;\\n    for (i = 0; i < args.length; i += 1) {\\n      var toAdd = $(args[i]);\\n      for (j = 0; j < toAdd.length; j += 1) {\\n        dom[dom.length] = toAdd[j];\\n        dom.length += 1;\\n      }\\n    }\\n    return dom;\\n  }\\n\\n  var Methods = {\\n    addClass: addClass,\\n    removeClass: removeClass,\\n    hasClass: hasClass,\\n    toggleClass: toggleClass,\\n    attr: attr,\\n    removeAttr: removeAttr,\\n    data: data,\\n    transform: transform,\\n    transition: transition,\\n    on: on,\\n    off: off,\\n    trigger: trigger,\\n    transitionEnd: transitionEnd,\\n    outerWidth: outerWidth,\\n    outerHeight: outerHeight,\\n    offset: offset,\\n    css: css,\\n    each: each,\\n    html: html,\\n    text: text,\\n    is: is,\\n    index: index,\\n    eq: eq,\\n    append: append,\\n    prepend: prepend,\\n    next: next,\\n    nextAll: nextAll,\\n    prev: prev,\\n    prevAll: prevAll,\\n    parent: parent,\\n    parents: parents,\\n    closest: closest,\\n    find: find,\\n    children: children,\\n    remove: remove,\\n    add: add,\\n    styles: styles,\\n  };\\n\\n  Object.keys(Methods).forEach(function (methodName) {\\n    $.fn[methodName] = Methods[methodName];\\n  });\\n\\n  var Utils = {\\n    deleteProps: function deleteProps(obj) {\\n      var object = obj;\\n      Object.keys(object).forEach(function (key) {\\n        try {\\n          object[key] = null;\\n        } catch (e) {\\n          // no getter for object\\n        }\\n        try {\\n          delete object[key];\\n        } catch (e) {\\n          // something got wrong\\n        }\\n      });\\n    },\\n    nextTick: function nextTick(callback, delay) {\\n      if ( delay === void 0 ) delay = 0;\\n\\n      return setTimeout(callback, delay);\\n    },\\n    now: function now() {\\n      return Date.now();\\n    },\\n    getTranslate: function getTranslate(el, axis) {\\n      if ( axis === void 0 ) axis = 'x';\\n\\n      var matrix;\\n      var curTransform;\\n      var transformMatrix;\\n\\n      var curStyle = win.getComputedStyle(el, null);\\n\\n      if (win.WebKitCSSMatrix) {\\n        curTransform = curStyle.transform || curStyle.webkitTransform;\\n        if (curTransform.split(',').length > 6) {\\n          curTransform = curTransform.split(', ').map(function (a) { return a.replace(',', '.'); }).join(', ');\\n        }\\n        // Some old versions of Webkit choke when 'none' is passed; pass\\n        // empty string instead in this case\\n        transformMatrix = new win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\\n      } else {\\n        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\\n        matrix = transformMatrix.toString().split(',');\\n      }\\n\\n      if (axis === 'x') {\\n        // Latest Chrome and webkits Fix\\n        if (win.WebKitCSSMatrix) { curTransform = transformMatrix.m41; }\\n        // Crazy IE10 Matrix\\n        else if (matrix.length === 16) { curTransform = parseFloat(matrix[12]); }\\n        // Normal Browsers\\n        else { curTransform = parseFloat(matrix[4]); }\\n      }\\n      if (axis === 'y') {\\n        // Latest Chrome and webkits Fix\\n        if (win.WebKitCSSMatrix) { curTransform = transformMatrix.m42; }\\n        // Crazy IE10 Matrix\\n        else if (matrix.length === 16) { curTransform = parseFloat(matrix[13]); }\\n        // Normal Browsers\\n        else { curTransform = parseFloat(matrix[5]); }\\n      }\\n      return curTransform || 0;\\n    },\\n    parseUrlQuery: function parseUrlQuery(url) {\\n      var query = {};\\n      var urlToParse = url || win.location.href;\\n      var i;\\n      var params;\\n      var param;\\n      var length;\\n      if (typeof urlToParse === 'string' && urlToParse.length) {\\n        urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\\\\S*\\\\?/, '') : '';\\n        params = urlToParse.split('&').filter(function (paramsPart) { return paramsPart !== ''; });\\n        length = params.length;\\n\\n        for (i = 0; i < length; i += 1) {\\n          param = params[i].replace(/#\\\\S+/g, '').split('=');\\n          query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';\\n        }\\n      }\\n      return query;\\n    },\\n    isObject: function isObject(o) {\\n      return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;\\n    },\\n    extend: function extend() {\\n      var args = [], len$1 = arguments.length;\\n      while ( len$1-- ) args[ len$1 ] = arguments[ len$1 ];\\n\\n      var to = Object(args[0]);\\n      for (var i = 1; i < args.length; i += 1) {\\n        var nextSource = args[i];\\n        if (nextSource !== undefined && nextSource !== null) {\\n          var keysArray = Object.keys(Object(nextSource));\\n          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\\n            var nextKey = keysArray[nextIndex];\\n            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\\n            if (desc !== undefined && desc.enumerable) {\\n              if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {\\n                Utils.extend(to[nextKey], nextSource[nextKey]);\\n              } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {\\n                to[nextKey] = {};\\n                Utils.extend(to[nextKey], nextSource[nextKey]);\\n              } else {\\n                to[nextKey] = nextSource[nextKey];\\n              }\\n            }\\n          }\\n        }\\n      }\\n      return to;\\n    },\\n  };\\n\\n  var Support = (function Support() {\\n    var testDiv = doc.createElement('div');\\n    return {\\n      touch: (win.Modernizr && win.Modernizr.touch === true) || (function checkTouch() {\\n        return !!((win.navigator.maxTouchPoints > 0) || ('ontouchstart' in win) || (win.DocumentTouch && doc instanceof win.DocumentTouch));\\n      }()),\\n\\n      pointerEvents: !!(win.navigator.pointerEnabled || win.PointerEvent || ('maxTouchPoints' in win.navigator)),\\n      prefixedPointerEvents: !!win.navigator.msPointerEnabled,\\n\\n      transition: (function checkTransition() {\\n        var style = testDiv.style;\\n        return ('transition' in style || 'webkitTransition' in style || 'MozTransition' in style);\\n      }()),\\n      transforms3d: (win.Modernizr && win.Modernizr.csstransforms3d === true) || (function checkTransforms3d() {\\n        var style = testDiv.style;\\n        return ('webkitPerspective' in style || 'MozPerspective' in style || 'OPerspective' in style || 'MsPerspective' in style || 'perspective' in style);\\n      }()),\\n\\n      flexbox: (function checkFlexbox() {\\n        var style = testDiv.style;\\n        var styles = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');\\n        for (var i = 0; i < styles.length; i += 1) {\\n          if (styles[i] in style) { return true; }\\n        }\\n        return false;\\n      }()),\\n\\n      observer: (function checkObserver() {\\n        return ('MutationObserver' in win || 'WebkitMutationObserver' in win);\\n      }()),\\n\\n      passiveListener: (function checkPassiveListener() {\\n        var supportsPassive = false;\\n        try {\\n          var opts = Object.defineProperty({}, 'passive', {\\n            // eslint-disable-next-line\\n            get: function get() {\\n              supportsPassive = true;\\n            },\\n          });\\n          win.addEventListener('testPassiveListener', null, opts);\\n        } catch (e) {\\n          // No support\\n        }\\n        return supportsPassive;\\n      }()),\\n\\n      gestures: (function checkGestures() {\\n        return 'ongesturestart' in win;\\n      }()),\\n    };\\n  }());\\n\\n  var SwiperClass = function SwiperClass(params) {\\n    if ( params === void 0 ) params = {};\\n\\n    var self = this;\\n    self.params = params;\\n\\n    // Events\\n    self.eventsListeners = {};\\n\\n    if (self.params && self.params.on) {\\n      Object.keys(self.params.on).forEach(function (eventName) {\\n        self.on(eventName, self.params.on[eventName]);\\n      });\\n    }\\n  };\\n\\n  var staticAccessors = { components: { configurable: true } };\\n\\n  SwiperClass.prototype.on = function on (events, handler, priority) {\\n    var self = this;\\n    if (typeof handler !== 'function') { return self; }\\n    var method = priority ? 'unshift' : 'push';\\n    events.split(' ').forEach(function (event) {\\n      if (!self.eventsListeners[event]) { self.eventsListeners[event] = []; }\\n      self.eventsListeners[event][method](handler);\\n    });\\n    return self;\\n  };\\n\\n  SwiperClass.prototype.once = function once (events, handler, priority) {\\n    var self = this;\\n    if (typeof handler !== 'function') { return self; }\\n    function onceHandler() {\\n        var args = [], len = arguments.length;\\n        while ( len-- ) args[ len ] = arguments[ len ];\\n\\n      handler.apply(self, args);\\n      self.off(events, onceHandler);\\n    }\\n    return self.on(events, onceHandler, priority);\\n  };\\n\\n  SwiperClass.prototype.off = function off (events, handler) {\\n    var self = this;\\n    if (!self.eventsListeners) { return self; }\\n    events.split(' ').forEach(function (event) {\\n      if (typeof handler === 'undefined') {\\n        self.eventsListeners[event] = [];\\n      } else if (self.eventsListeners[event] && self.eventsListeners[event].length) {\\n        self.eventsListeners[event].forEach(function (eventHandler, index) {\\n          if (eventHandler === handler) {\\n            self.eventsListeners[event].splice(index, 1);\\n          }\\n        });\\n      }\\n    });\\n    return self;\\n  };\\n\\n  SwiperClass.prototype.emit = function emit () {\\n      var args = [], len = arguments.length;\\n      while ( len-- ) args[ len ] = arguments[ len ];\\n\\n    var self = this;\\n    if (!self.eventsListeners) { return self; }\\n    var events;\\n    var data;\\n    var context;\\n    if (typeof args[0] === 'string' || Array.isArray(args[0])) {\\n      events = args[0];\\n      data = args.slice(1, args.length);\\n      context = self;\\n    } else {\\n      events = args[0].events;\\n      data = args[0].data;\\n      context = args[0].context || self;\\n    }\\n    var eventsArray = Array.isArray(events) ? events : events.split(' ');\\n    eventsArray.forEach(function (event) {\\n      if (self.eventsListeners && self.eventsListeners[event]) {\\n        var handlers = [];\\n        self.eventsListeners[event].forEach(function (eventHandler) {\\n          handlers.push(eventHandler);\\n        });\\n        handlers.forEach(function (eventHandler) {\\n          eventHandler.apply(context, data);\\n        });\\n      }\\n    });\\n    return self;\\n  };\\n\\n  SwiperClass.prototype.useModulesParams = function useModulesParams (instanceParams) {\\n    var instance = this;\\n    if (!instance.modules) { return; }\\n    Object.keys(instance.modules).forEach(function (moduleName) {\\n      var module = instance.modules[moduleName];\\n      // Extend params\\n      if (module.params) {\\n        Utils.extend(instanceParams, module.params);\\n      }\\n    });\\n  };\\n\\n  SwiperClass.prototype.useModules = function useModules (modulesParams) {\\n      if ( modulesParams === void 0 ) modulesParams = {};\\n\\n    var instance = this;\\n    if (!instance.modules) { return; }\\n    Object.keys(instance.modules).forEach(function (moduleName) {\\n      var module = instance.modules[moduleName];\\n      var moduleParams = modulesParams[moduleName] || {};\\n      // Extend instance methods and props\\n      if (module.instance) {\\n        Object.keys(module.instance).forEach(function (modulePropName) {\\n          var moduleProp = module.instance[modulePropName];\\n          if (typeof moduleProp === 'function') {\\n            instance[modulePropName] = moduleProp.bind(instance);\\n          } else {\\n            instance[modulePropName] = moduleProp;\\n          }\\n        });\\n      }\\n      // Add event listeners\\n      if (module.on && instance.on) {\\n        Object.keys(module.on).forEach(function (moduleEventName) {\\n          instance.on(moduleEventName, module.on[moduleEventName]);\\n        });\\n      }\\n\\n      // Module create callback\\n      if (module.create) {\\n        module.create.bind(instance)(moduleParams);\\n      }\\n    });\\n  };\\n\\n  staticAccessors.components.set = function (components) {\\n    var Class = this;\\n    if (!Class.use) { return; }\\n    Class.use(components);\\n  };\\n\\n  SwiperClass.installModule = function installModule (module) {\\n      var params = [], len = arguments.length - 1;\\n      while ( len-- > 0 ) params[ len ] = arguments[ len + 1 ];\\n\\n    var Class = this;\\n    if (!Class.prototype.modules) { Class.prototype.modules = {}; }\\n    var name = module.name || (((Object.keys(Class.prototype.modules).length) + \\\"_\\\" + (Utils.now())));\\n    Class.prototype.modules[name] = module;\\n    // Prototype\\n    if (module.proto) {\\n      Object.keys(module.proto).forEach(function (key) {\\n        Class.prototype[key] = module.proto[key];\\n      });\\n    }\\n    // Class\\n    if (module.static) {\\n      Object.keys(module.static).forEach(function (key) {\\n        Class[key] = module.static[key];\\n      });\\n    }\\n    // Callback\\n    if (module.install) {\\n      module.install.apply(Class, params);\\n    }\\n    return Class;\\n  };\\n\\n  SwiperClass.use = function use (module) {\\n      var params = [], len = arguments.length - 1;\\n      while ( len-- > 0 ) params[ len ] = arguments[ len + 1 ];\\n\\n    var Class = this;\\n    if (Array.isArray(module)) {\\n      module.forEach(function (m) { return Class.installModule(m); });\\n      return Class;\\n    }\\n    return Class.installModule.apply(Class, [ module ].concat( params ));\\n  };\\n\\n  Object.defineProperties( SwiperClass, staticAccessors );\\n\\n  function updateSize () {\\n    var swiper = this;\\n    var width;\\n    var height;\\n    var $el = swiper.$el;\\n    if (typeof swiper.params.width !== 'undefined') {\\n      width = swiper.params.width;\\n    } else {\\n      width = $el[0].clientWidth;\\n    }\\n    if (typeof swiper.params.height !== 'undefined') {\\n      height = swiper.params.height;\\n    } else {\\n      height = $el[0].clientHeight;\\n    }\\n    if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {\\n      return;\\n    }\\n\\n    // Subtract paddings\\n    width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);\\n    height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);\\n\\n    Utils.extend(swiper, {\\n      width: width,\\n      height: height,\\n      size: swiper.isHorizontal() ? width : height,\\n    });\\n  }\\n\\n  function updateSlides () {\\n    var swiper = this;\\n    var params = swiper.params;\\n\\n    var $wrapperEl = swiper.$wrapperEl;\\n    var swiperSize = swiper.size;\\n    var rtl = swiper.rtlTranslate;\\n    var wrongRTL = swiper.wrongRTL;\\n    var isVirtual = swiper.virtual && params.virtual.enabled;\\n    var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\\n    var slides = $wrapperEl.children((\\\".\\\" + (swiper.params.slideClass)));\\n    var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\\n    var snapGrid = [];\\n    var slidesGrid = [];\\n    var slidesSizesGrid = [];\\n\\n    var offsetBefore = params.slidesOffsetBefore;\\n    if (typeof offsetBefore === 'function') {\\n      offsetBefore = params.slidesOffsetBefore.call(swiper);\\n    }\\n\\n    var offsetAfter = params.slidesOffsetAfter;\\n    if (typeof offsetAfter === 'function') {\\n      offsetAfter = params.slidesOffsetAfter.call(swiper);\\n    }\\n\\n    var previousSnapGridLength = swiper.snapGrid.length;\\n    var previousSlidesGridLength = swiper.snapGrid.length;\\n\\n    var spaceBetween = params.spaceBetween;\\n    var slidePosition = -offsetBefore;\\n    var prevSlideSize = 0;\\n    var index = 0;\\n    if (typeof swiperSize === 'undefined') {\\n      return;\\n    }\\n    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\\n      spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;\\n    }\\n\\n    swiper.virtualSize = -spaceBetween;\\n\\n    // reset margins\\n    if (rtl) { slides.css({ marginLeft: '', marginTop: '' }); }\\n    else { slides.css({ marginRight: '', marginBottom: '' }); }\\n\\n    var slidesNumberEvenToRows;\\n    if (params.slidesPerColumn > 1) {\\n      if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {\\n        slidesNumberEvenToRows = slidesLength;\\n      } else {\\n        slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;\\n      }\\n      if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {\\n        slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);\\n      }\\n    }\\n\\n    // Calc slides\\n    var slideSize;\\n    var slidesPerColumn = params.slidesPerColumn;\\n    var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;\\n    var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);\\n    for (var i = 0; i < slidesLength; i += 1) {\\n      slideSize = 0;\\n      var slide = slides.eq(i);\\n      if (params.slidesPerColumn > 1) {\\n        // Set slides order\\n        var newSlideOrderIndex = (void 0);\\n        var column = (void 0);\\n        var row = (void 0);\\n        if (params.slidesPerColumnFill === 'column') {\\n          column = Math.floor(i / slidesPerColumn);\\n          row = i - (column * slidesPerColumn);\\n          if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {\\n            row += 1;\\n            if (row >= slidesPerColumn) {\\n              row = 0;\\n              column += 1;\\n            }\\n          }\\n          newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);\\n          slide\\n            .css({\\n              '-webkit-box-ordinal-group': newSlideOrderIndex,\\n              '-moz-box-ordinal-group': newSlideOrderIndex,\\n              '-ms-flex-order': newSlideOrderIndex,\\n              '-webkit-order': newSlideOrderIndex,\\n              order: newSlideOrderIndex,\\n            });\\n        } else {\\n          row = Math.floor(i / slidesPerRow);\\n          column = i - (row * slidesPerRow);\\n        }\\n        slide\\n          .css(\\n            (\\\"margin-\\\" + (swiper.isHorizontal() ? 'top' : 'left')),\\n            (row !== 0 && params.spaceBetween) && (((params.spaceBetween) + \\\"px\\\"))\\n          )\\n          .attr('data-swiper-column', column)\\n          .attr('data-swiper-row', row);\\n      }\\n      if (slide.css('display') === 'none') { continue; } // eslint-disable-line\\n\\n      if (params.slidesPerView === 'auto') {\\n        var slideStyles = win.getComputedStyle(slide[0], null);\\n        var currentTransform = slide[0].style.transform;\\n        var currentWebKitTransform = slide[0].style.webkitTransform;\\n        if (currentTransform) {\\n          slide[0].style.transform = 'none';\\n        }\\n        if (currentWebKitTransform) {\\n          slide[0].style.webkitTransform = 'none';\\n        }\\n        if (params.roundLengths) {\\n          slideSize = swiper.isHorizontal()\\n            ? slide.outerWidth(true)\\n            : slide.outerHeight(true);\\n        } else {\\n          // eslint-disable-next-line\\n          if (swiper.isHorizontal()) {\\n            var width = parseFloat(slideStyles.getPropertyValue('width'));\\n            var paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left'));\\n            var paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right'));\\n            var marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left'));\\n            var marginRight = parseFloat(slideStyles.getPropertyValue('margin-right'));\\n            var boxSizing = slideStyles.getPropertyValue('box-sizing');\\n            if (boxSizing && boxSizing === 'border-box') {\\n              slideSize = width + marginLeft + marginRight;\\n            } else {\\n              slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;\\n            }\\n          } else {\\n            var height = parseFloat(slideStyles.getPropertyValue('height'));\\n            var paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top'));\\n            var paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom'));\\n            var marginTop = parseFloat(slideStyles.getPropertyValue('margin-top'));\\n            var marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom'));\\n            var boxSizing$1 = slideStyles.getPropertyValue('box-sizing');\\n            if (boxSizing$1 && boxSizing$1 === 'border-box') {\\n              slideSize = height + marginTop + marginBottom;\\n            } else {\\n              slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;\\n            }\\n          }\\n        }\\n        if (currentTransform) {\\n          slide[0].style.transform = currentTransform;\\n        }\\n        if (currentWebKitTransform) {\\n          slide[0].style.webkitTransform = currentWebKitTransform;\\n        }\\n        if (params.roundLengths) { slideSize = Math.floor(slideSize); }\\n      } else {\\n        slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;\\n        if (params.roundLengths) { slideSize = Math.floor(slideSize); }\\n\\n        if (slides[i]) {\\n          if (swiper.isHorizontal()) {\\n            slides[i].style.width = slideSize + \\\"px\\\";\\n          } else {\\n            slides[i].style.height = slideSize + \\\"px\\\";\\n          }\\n        }\\n      }\\n      if (slides[i]) {\\n        slides[i].swiperSlideSize = slideSize;\\n      }\\n      slidesSizesGrid.push(slideSize);\\n\\n\\n      if (params.centeredSlides) {\\n        slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;\\n        if (prevSlideSize === 0 && i !== 0) { slidePosition = slidePosition - (swiperSize / 2) - spaceBetween; }\\n        if (i === 0) { slidePosition = slidePosition - (swiperSize / 2) - spaceBetween; }\\n        if (Math.abs(slidePosition) < 1 / 1000) { slidePosition = 0; }\\n        if (params.roundLengths) { slidePosition = Math.floor(slidePosition); }\\n        if ((index) % params.slidesPerGroup === 0) { snapGrid.push(slidePosition); }\\n        slidesGrid.push(slidePosition);\\n      } else {\\n        if (params.roundLengths) { slidePosition = Math.floor(slidePosition); }\\n        if ((index) % params.slidesPerGroup === 0) { snapGrid.push(slidePosition); }\\n        slidesGrid.push(slidePosition);\\n        slidePosition = slidePosition + slideSize + spaceBetween;\\n      }\\n\\n      swiper.virtualSize += slideSize + spaceBetween;\\n\\n      prevSlideSize = slideSize;\\n\\n      index += 1;\\n    }\\n    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\\n    var newSlidesGrid;\\n\\n    if (\\n      rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\\n      $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + \\\"px\\\") });\\n    }\\n    if (!Support.flexbox || params.setWrapperSize) {\\n      if (swiper.isHorizontal()) { $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + \\\"px\\\") }); }\\n      else { $wrapperEl.css({ height: ((swiper.virtualSize + params.spaceBetween) + \\\"px\\\") }); }\\n    }\\n\\n    if (params.slidesPerColumn > 1) {\\n      swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;\\n      swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;\\n      if (swiper.isHorizontal()) { $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + \\\"px\\\") }); }\\n      else { $wrapperEl.css({ height: ((swiper.virtualSize + params.spaceBetween) + \\\"px\\\") }); }\\n      if (params.centeredSlides) {\\n        newSlidesGrid = [];\\n        for (var i$1 = 0; i$1 < snapGrid.length; i$1 += 1) {\\n          var slidesGridItem = snapGrid[i$1];\\n          if (params.roundLengths) { slidesGridItem = Math.floor(slidesGridItem); }\\n          if (snapGrid[i$1] < swiper.virtualSize + snapGrid[0]) { newSlidesGrid.push(slidesGridItem); }\\n        }\\n        snapGrid = newSlidesGrid;\\n      }\\n    }\\n\\n    // Remove last grid elements depending on width\\n    if (!params.centeredSlides) {\\n      newSlidesGrid = [];\\n      for (var i$2 = 0; i$2 < snapGrid.length; i$2 += 1) {\\n        var slidesGridItem$1 = snapGrid[i$2];\\n        if (params.roundLengths) { slidesGridItem$1 = Math.floor(slidesGridItem$1); }\\n        if (snapGrid[i$2] <= swiper.virtualSize - swiperSize) {\\n          newSlidesGrid.push(slidesGridItem$1);\\n        }\\n      }\\n      snapGrid = newSlidesGrid;\\n      if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\\n        snapGrid.push(swiper.virtualSize - swiperSize);\\n      }\\n    }\\n    if (snapGrid.length === 0) { snapGrid = [0]; }\\n\\n    if (params.spaceBetween !== 0) {\\n      if (swiper.isHorizontal()) {\\n        if (rtl) { slides.css({ marginLeft: (spaceBetween + \\\"px\\\") }); }\\n        else { slides.css({ marginRight: (spaceBetween + \\\"px\\\") }); }\\n      } else { slides.css({ marginBottom: (spaceBetween + \\\"px\\\") }); }\\n    }\\n\\n    if (params.centerInsufficientSlides) {\\n      var allSlidesSize = 0;\\n      slidesSizesGrid.forEach(function (slideSizeValue) {\\n        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\\n      });\\n      allSlidesSize -= params.spaceBetween;\\n      if (allSlidesSize < swiperSize) {\\n        var allSlidesOffset = (swiperSize - allSlidesSize) / 2;\\n        snapGrid.forEach(function (snap, snapIndex) {\\n          snapGrid[snapIndex] = snap - allSlidesOffset;\\n        });\\n        slidesGrid.forEach(function (snap, snapIndex) {\\n          slidesGrid[snapIndex] = snap + allSlidesOffset;\\n        });\\n      }\\n    }\\n\\n    Utils.extend(swiper, {\\n      slides: slides,\\n      snapGrid: snapGrid,\\n      slidesGrid: slidesGrid,\\n      slidesSizesGrid: slidesSizesGrid,\\n    });\\n\\n    if (slidesLength !== previousSlidesLength) {\\n      swiper.emit('slidesLengthChange');\\n    }\\n    if (snapGrid.length !== previousSnapGridLength) {\\n      if (swiper.params.watchOverflow) { swiper.checkOverflow(); }\\n      swiper.emit('snapGridLengthChange');\\n    }\\n    if (slidesGrid.length !== previousSlidesGridLength) {\\n      swiper.emit('slidesGridLengthChange');\\n    }\\n\\n    if (params.watchSlidesProgress || params.watchSlidesVisibility) {\\n      swiper.updateSlidesOffset();\\n    }\\n  }\\n\\n  function updateAutoHeight (speed) {\\n    var swiper = this;\\n    var activeSlides = [];\\n    var newHeight = 0;\\n    var i;\\n    if (typeof speed === 'number') {\\n      swiper.setTransition(speed);\\n    } else if (speed === true) {\\n      swiper.setTransition(swiper.params.speed);\\n    }\\n    // Find slides currently in view\\n    if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\\n      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\\n        var index = swiper.activeIndex + i;\\n        if (index > swiper.slides.length) { break; }\\n        activeSlides.push(swiper.slides.eq(index)[0]);\\n      }\\n    } else {\\n      activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);\\n    }\\n\\n    // Find new height from highest slide in view\\n    for (i = 0; i < activeSlides.length; i += 1) {\\n      if (typeof activeSlides[i] !== 'undefined') {\\n        var height = activeSlides[i].offsetHeight;\\n        newHeight = height > newHeight ? height : newHeight;\\n      }\\n    }\\n\\n    // Update Height\\n    if (newHeight) { swiper.$wrapperEl.css('height', (newHeight + \\\"px\\\")); }\\n  }\\n\\n  function updateSlidesOffset () {\\n    var swiper = this;\\n    var slides = swiper.slides;\\n    for (var i = 0; i < slides.length; i += 1) {\\n      slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;\\n    }\\n  }\\n\\n  function updateSlidesProgress (translate) {\\n    if ( translate === void 0 ) translate = (this && this.translate) || 0;\\n\\n    var swiper = this;\\n    var params = swiper.params;\\n\\n    var slides = swiper.slides;\\n    var rtl = swiper.rtlTranslate;\\n\\n    if (slides.length === 0) { return; }\\n    if (typeof slides[0].swiperSlideOffset === 'undefined') { swiper.updateSlidesOffset(); }\\n\\n    var offsetCenter = -translate;\\n    if (rtl) { offsetCenter = translate; }\\n\\n    // Visible Slides\\n    slides.removeClass(params.slideVisibleClass);\\n\\n    swiper.visibleSlidesIndexes = [];\\n    swiper.visibleSlides = [];\\n\\n    for (var i = 0; i < slides.length; i += 1) {\\n      var slide = slides[i];\\n      var slideProgress = (\\n        (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset\\n      ) / (slide.swiperSlideSize + params.spaceBetween);\\n      if (params.watchSlidesVisibility) {\\n        var slideBefore = -(offsetCenter - slide.swiperSlideOffset);\\n        var slideAfter = slideBefore + swiper.slidesSizesGrid[i];\\n        var isVisible = (slideBefore >= 0 && slideBefore < swiper.size)\\n                  || (slideAfter > 0 && slideAfter <= swiper.size)\\n                  || (slideBefore <= 0 && slideAfter >= swiper.size);\\n        if (isVisible) {\\n          swiper.visibleSlides.push(slide);\\n          swiper.visibleSlidesIndexes.push(i);\\n          slides.eq(i).addClass(params.slideVisibleClass);\\n        }\\n      }\\n      slide.progress = rtl ? -slideProgress : slideProgress;\\n    }\\n    swiper.visibleSlides = $(swiper.visibleSlides);\\n  }\\n\\n  function updateProgress (translate) {\\n    if ( translate === void 0 ) translate = (this && this.translate) || 0;\\n\\n    var swiper = this;\\n    var params = swiper.params;\\n\\n    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\\n    var progress = swiper.progress;\\n    var isBeginning = swiper.isBeginning;\\n    var isEnd = swiper.isEnd;\\n    var wasBeginning = isBeginning;\\n    var wasEnd = isEnd;\\n    if (translatesDiff === 0) {\\n      progress = 0;\\n      isBeginning = true;\\n      isEnd = true;\\n    } else {\\n      progress = (translate - swiper.minTranslate()) / (translatesDiff);\\n      isBeginning = progress <= 0;\\n      isEnd = progress >= 1;\\n    }\\n    Utils.extend(swiper, {\\n      progress: progress,\\n      isBeginning: isBeginning,\\n      isEnd: isEnd,\\n    });\\n\\n    if (params.watchSlidesProgress || params.watchSlidesVisibility) { swiper.updateSlidesProgress(translate); }\\n\\n    if (isBeginning && !wasBeginning) {\\n      swiper.emit('reachBeginning toEdge');\\n    }\\n    if (isEnd && !wasEnd) {\\n      swiper.emit('reachEnd toEdge');\\n    }\\n    if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {\\n      swiper.emit('fromEdge');\\n    }\\n\\n    swiper.emit('progress', progress);\\n  }\\n\\n  function updateSlidesClasses () {\\n    var swiper = this;\\n\\n    var slides = swiper.slides;\\n    var params = swiper.params;\\n    var $wrapperEl = swiper.$wrapperEl;\\n    var activeIndex = swiper.activeIndex;\\n    var realIndex = swiper.realIndex;\\n    var isVirtual = swiper.virtual && params.virtual.enabled;\\n\\n    slides.removeClass(((params.slideActiveClass) + \\\" \\\" + (params.slideNextClass) + \\\" \\\" + (params.slidePrevClass) + \\\" \\\" + (params.slideDuplicateActiveClass) + \\\" \\\" + (params.slideDuplicateNextClass) + \\\" \\\" + (params.slideDuplicatePrevClass)));\\n\\n    var activeSlide;\\n    if (isVirtual) {\\n      activeSlide = swiper.$wrapperEl.find((\\\".\\\" + (params.slideClass) + \\\"[data-swiper-slide-index=\\\\\\\"\\\" + activeIndex + \\\"\\\\\\\"]\\\"));\\n    } else {\\n      activeSlide = slides.eq(activeIndex);\\n    }\\n\\n    // Active classes\\n    activeSlide.addClass(params.slideActiveClass);\\n\\n    if (params.loop) {\\n      // Duplicate to all looped slides\\n      if (activeSlide.hasClass(params.slideDuplicateClass)) {\\n        $wrapperEl\\n          .children((\\\".\\\" + (params.slideClass) + \\\":not(.\\\" + (params.slideDuplicateClass) + \\\")[data-swiper-slide-index=\\\\\\\"\\\" + realIndex + \\\"\\\\\\\"]\\\"))\\n          .addClass(params.slideDuplicateActiveClass);\\n      } else {\\n        $wrapperEl\\n          .children((\\\".\\\" + (params.slideClass) + \\\".\\\" + (params.slideDuplicateClass) + \\\"[data-swiper-slide-index=\\\\\\\"\\\" + realIndex + \\\"\\\\\\\"]\\\"))\\n          .addClass(params.slideDuplicateActiveClass);\\n      }\\n    }\\n    // Next Slide\\n    var nextSlide = activeSlide.nextAll((\\\".\\\" + (params.slideClass))).eq(0).addClass(params.slideNextClass);\\n    if (params.loop && nextSlide.length === 0) {\\n      nextSlide = slides.eq(0);\\n      nextSlide.addClass(params.slideNextClass);\\n    }\\n    // Prev Slide\\n    var prevSlide = activeSlide.prevAll((\\\".\\\" + (params.slideClass))).eq(0).addClass(params.slidePrevClass);\\n    if (params.loop && prevSlide.length === 0) {\\n      prevSlide = slides.eq(-1);\\n      prevSlide.addClass(params.slidePrevClass);\\n    }\\n    if (params.loop) {\\n      // Duplicate to all looped slides\\n      if (nextSlide.hasClass(params.slideDuplicateClass)) {\\n        $wrapperEl\\n          .children((\\\".\\\" + (params.slideClass) + \\\":not(.\\\" + (params.slideDuplicateClass) + \\\")[data-swiper-slide-index=\\\\\\\"\\\" + (nextSlide.attr('data-swiper-slide-index')) + \\\"\\\\\\\"]\\\"))\\n          .addClass(params.slideDuplicateNextClass);\\n      } else {\\n        $wrapperEl\\n          .children((\\\".\\\" + (params.slideClass) + \\\".\\\" + (params.slideDuplicateClass) + \\\"[data-swiper-slide-index=\\\\\\\"\\\" + (nextSlide.attr('data-swiper-slide-index')) + \\\"\\\\\\\"]\\\"))\\n          .addClass(params.slideDuplicateNextClass);\\n      }\\n      if (prevSlide.hasClass(params.slideDuplicateClass)) {\\n        $wrapperEl\\n          .children((\\\".\\\" + (params.slideClass) + \\\":not(.\\\" + (params.slideDuplicateClass) + \\\")[data-swiper-slide-index=\\\\\\\"\\\" + (prevSlide.attr('data-swiper-slide-index')) + \\\"\\\\\\\"]\\\"))\\n          .addClass(params.slideDuplicatePrevClass);\\n      } else {\\n        $wrapperEl\\n          .children((\\\".\\\" + (params.slideClass) + \\\".\\\" + (params.slideDuplicateClass) + \\\"[data-swiper-slide-index=\\\\\\\"\\\" + (prevSlide.attr('data-swiper-slide-index')) + \\\"\\\\\\\"]\\\"))\\n          .addClass(params.slideDuplicatePrevClass);\\n      }\\n    }\\n  }\\n\\n  function updateActiveIndex (newActiveIndex) {\\n    var swiper = this;\\n    var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\\n    var slidesGrid = swiper.slidesGrid;\\n    var snapGrid = swiper.snapGrid;\\n    var params = swiper.params;\\n    var previousIndex = swiper.activeIndex;\\n    var previousRealIndex = swiper.realIndex;\\n    var previousSnapIndex = swiper.snapIndex;\\n    var activeIndex = newActiveIndex;\\n    var snapIndex;\\n    if (typeof activeIndex === 'undefined') {\\n      for (var i = 0; i < slidesGrid.length; i += 1) {\\n        if (typeof slidesGrid[i + 1] !== 'undefined') {\\n          if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {\\n            activeIndex = i;\\n          } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\\n            activeIndex = i + 1;\\n          }\\n        } else if (translate >= slidesGrid[i]) {\\n          activeIndex = i;\\n        }\\n      }\\n      // Normalize slideIndex\\n      if (params.normalizeSlideIndex) {\\n        if (activeIndex < 0 || typeof activeIndex === 'undefined') { activeIndex = 0; }\\n      }\\n    }\\n    if (snapGrid.indexOf(translate) >= 0) {\\n      snapIndex = snapGrid.indexOf(translate);\\n    } else {\\n      snapIndex = Math.floor(activeIndex / params.slidesPerGroup);\\n    }\\n    if (snapIndex >= snapGrid.length) { snapIndex = snapGrid.length - 1; }\\n    if (activeIndex === previousIndex) {\\n      if (snapIndex !== previousSnapIndex) {\\n        swiper.snapIndex = snapIndex;\\n        swiper.emit('snapIndexChange');\\n      }\\n      return;\\n    }\\n\\n    // Get real index\\n    var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);\\n\\n    Utils.extend(swiper, {\\n      snapIndex: snapIndex,\\n      realIndex: realIndex,\\n      previousIndex: previousIndex,\\n      activeIndex: activeIndex,\\n    });\\n    swiper.emit('activeIndexChange');\\n    swiper.emit('snapIndexChange');\\n    if (previousRealIndex !== realIndex) {\\n      swiper.emit('realIndexChange');\\n    }\\n    swiper.emit('slideChange');\\n  }\\n\\n  function updateClickedSlide (e) {\\n    var swiper = this;\\n    var params = swiper.params;\\n    var slide = $(e.target).closest((\\\".\\\" + (params.slideClass)))[0];\\n    var slideFound = false;\\n    if (slide) {\\n      for (var i = 0; i < swiper.slides.length; i += 1) {\\n        if (swiper.slides[i] === slide) { slideFound = true; }\\n      }\\n    }\\n\\n    if (slide && slideFound) {\\n      swiper.clickedSlide = slide;\\n      if (swiper.virtual && swiper.params.virtual.enabled) {\\n        swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);\\n      } else {\\n        swiper.clickedIndex = $(slide).index();\\n      }\\n    } else {\\n      swiper.clickedSlide = undefined;\\n      swiper.clickedIndex = undefined;\\n      return;\\n    }\\n    if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\\n      swiper.slideToClickedSlide();\\n    }\\n  }\\n\\n  var update = {\\n    updateSize: updateSize,\\n    updateSlides: updateSlides,\\n    updateAutoHeight: updateAutoHeight,\\n    updateSlidesOffset: updateSlidesOffset,\\n    updateSlidesProgress: updateSlidesProgress,\\n    updateProgress: updateProgress,\\n    updateSlidesClasses: updateSlidesClasses,\\n    updateActiveIndex: updateActiveIndex,\\n    updateClickedSlide: updateClickedSlide,\\n  };\\n\\n  function getTranslate (axis) {\\n    if ( axis === void 0 ) axis = this.isHorizontal() ? 'x' : 'y';\\n\\n    var swiper = this;\\n\\n    var params = swiper.params;\\n    var rtl = swiper.rtlTranslate;\\n    var translate = swiper.translate;\\n    var $wrapperEl = swiper.$wrapperEl;\\n\\n    if (params.virtualTranslate) {\\n      return rtl ? -translate : translate;\\n    }\\n\\n    var currentTranslate = Utils.getTranslate($wrapperEl[0], axis);\\n    if (rtl) { currentTranslate = -currentTranslate; }\\n\\n    return currentTranslate || 0;\\n  }\\n\\n  function setTranslate (translate, byController) {\\n    var swiper = this;\\n    var rtl = swiper.rtlTranslate;\\n    var params = swiper.params;\\n    var $wrapperEl = swiper.$wrapperEl;\\n    var progress = swiper.progress;\\n    var x = 0;\\n    var y = 0;\\n    var z = 0;\\n\\n    if (swiper.isHorizontal()) {\\n      x = rtl ? -translate : translate;\\n    } else {\\n      y = translate;\\n    }\\n\\n    if (params.roundLengths) {\\n      x = Math.floor(x);\\n      y = Math.floor(y);\\n    }\\n\\n    if (!params.virtualTranslate) {\\n      if (Support.transforms3d) { $wrapperEl.transform((\\\"translate3d(\\\" + x + \\\"px, \\\" + y + \\\"px, \\\" + z + \\\"px)\\\")); }\\n      else { $wrapperEl.transform((\\\"translate(\\\" + x + \\\"px, \\\" + y + \\\"px)\\\")); }\\n    }\\n    swiper.previousTranslate = swiper.translate;\\n    swiper.translate = swiper.isHorizontal() ? x : y;\\n\\n    // Check if we need to update progress\\n    var newProgress;\\n    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\\n    if (translatesDiff === 0) {\\n      newProgress = 0;\\n    } else {\\n      newProgress = (translate - swiper.minTranslate()) / (translatesDiff);\\n    }\\n    if (newProgress !== progress) {\\n      swiper.updateProgress(translate);\\n    }\\n\\n    swiper.emit('setTranslate', swiper.translate, byController);\\n  }\\n\\n  function minTranslate () {\\n    return (-this.snapGrid[0]);\\n  }\\n\\n  function maxTranslate () {\\n    return (-this.snapGrid[this.snapGrid.length - 1]);\\n  }\\n\\n  var translate = {\\n    getTranslate: getTranslate,\\n    setTranslate: setTranslate,\\n    minTranslate: minTranslate,\\n    maxTranslate: maxTranslate,\\n  };\\n\\n  function setTransition (duration, byController) {\\n    var swiper = this;\\n\\n    swiper.$wrapperEl.transition(duration);\\n\\n    swiper.emit('setTransition', duration, byController);\\n  }\\n\\n  function transitionStart (runCallbacks, direction) {\\n    if ( runCallbacks === void 0 ) runCallbacks = true;\\n\\n    var swiper = this;\\n    var activeIndex = swiper.activeIndex;\\n    var params = swiper.params;\\n    var previousIndex = swiper.previousIndex;\\n    if (params.autoHeight) {\\n      swiper.updateAutoHeight();\\n    }\\n\\n    var dir = direction;\\n    if (!dir) {\\n      if (activeIndex > previousIndex) { dir = 'next'; }\\n      else if (activeIndex < previousIndex) { dir = 'prev'; }\\n      else { dir = 'reset'; }\\n    }\\n\\n    swiper.emit('transitionStart');\\n\\n    if (runCallbacks && activeIndex !== previousIndex) {\\n      if (dir === 'reset') {\\n        swiper.emit('slideResetTransitionStart');\\n        return;\\n      }\\n      swiper.emit('slideChangeTransitionStart');\\n      if (dir === 'next') {\\n        swiper.emit('slideNextTransitionStart');\\n      } else {\\n        swiper.emit('slidePrevTransitionStart');\\n      }\\n    }\\n  }\\n\\n  function transitionEnd$1 (runCallbacks, direction) {\\n    if ( runCallbacks === void 0 ) runCallbacks = true;\\n\\n    var swiper = this;\\n    var activeIndex = swiper.activeIndex;\\n    var previousIndex = swiper.previousIndex;\\n    swiper.animating = false;\\n    swiper.setTransition(0);\\n\\n    var dir = direction;\\n    if (!dir) {\\n      if (activeIndex > previousIndex) { dir = 'next'; }\\n      else if (activeIndex < previousIndex) { dir = 'prev'; }\\n      else { dir = 'reset'; }\\n    }\\n\\n    swiper.emit('transitionEnd');\\n\\n    if (runCallbacks && activeIndex !== previousIndex) {\\n      if (dir === 'reset') {\\n        swiper.emit('slideResetTransitionEnd');\\n        return;\\n      }\\n      swiper.emit('slideChangeTransitionEnd');\\n      if (dir === 'next') {\\n        swiper.emit('slideNextTransitionEnd');\\n      } else {\\n        swiper.emit('slidePrevTransitionEnd');\\n      }\\n    }\\n  }\\n\\n  var transition$1 = {\\n    setTransition: setTransition,\\n    transitionStart: transitionStart,\\n    transitionEnd: transitionEnd$1,\\n  };\\n\\n  function slideTo (index, speed, runCallbacks, internal) {\\n    if ( index === void 0 ) index = 0;\\n    if ( speed === void 0 ) speed = this.params.speed;\\n    if ( runCallbacks === void 0 ) runCallbacks = true;\\n\\n    var swiper = this;\\n    var slideIndex = index;\\n    if (slideIndex < 0) { slideIndex = 0; }\\n\\n    var params = swiper.params;\\n    var snapGrid = swiper.snapGrid;\\n    var slidesGrid = swiper.slidesGrid;\\n    var previousIndex = swiper.previousIndex;\\n    var activeIndex = swiper.activeIndex;\\n    var rtl = swiper.rtlTranslate;\\n    if (swiper.animating && params.preventInteractionOnTransition) {\\n      return false;\\n    }\\n\\n    var snapIndex = Math.floor(slideIndex / params.slidesPerGroup);\\n    if (snapIndex >= snapGrid.length) { snapIndex = snapGrid.length - 1; }\\n\\n    if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {\\n      swiper.emit('beforeSlideChangeStart');\\n    }\\n\\n    var translate = -snapGrid[snapIndex];\\n\\n    // Update progress\\n    swiper.updateProgress(translate);\\n\\n    // Normalize slideIndex\\n    if (params.normalizeSlideIndex) {\\n      for (var i = 0; i < slidesGrid.length; i += 1) {\\n        if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {\\n          slideIndex = i;\\n        }\\n      }\\n    }\\n    // Directions locks\\n    if (swiper.initialized && slideIndex !== activeIndex) {\\n      if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {\\n        return false;\\n      }\\n      if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\\n        if ((activeIndex || 0) !== slideIndex) { return false; }\\n      }\\n    }\\n\\n    var direction;\\n    if (slideIndex > activeIndex) { direction = 'next'; }\\n    else if (slideIndex < activeIndex) { direction = 'prev'; }\\n    else { direction = 'reset'; }\\n\\n\\n    // Update Index\\n    if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {\\n      swiper.updateActiveIndex(slideIndex);\\n      // Update Height\\n      if (params.autoHeight) {\\n        swiper.updateAutoHeight();\\n      }\\n      swiper.updateSlidesClasses();\\n      if (params.effect !== 'slide') {\\n        swiper.setTranslate(translate);\\n      }\\n      if (direction !== 'reset') {\\n        swiper.transitionStart(runCallbacks, direction);\\n        swiper.transitionEnd(runCallbacks, direction);\\n      }\\n      return false;\\n    }\\n\\n    if (speed === 0 || !Support.transition) {\\n      swiper.setTransition(0);\\n      swiper.setTranslate(translate);\\n      swiper.updateActiveIndex(slideIndex);\\n      swiper.updateSlidesClasses();\\n      swiper.emit('beforeTransitionStart', speed, internal);\\n      swiper.transitionStart(runCallbacks, direction);\\n      swiper.transitionEnd(runCallbacks, direction);\\n    } else {\\n      swiper.setTransition(speed);\\n      swiper.setTranslate(translate);\\n      swiper.updateActiveIndex(slideIndex);\\n      swiper.updateSlidesClasses();\\n      swiper.emit('beforeTransitionStart', speed, internal);\\n      swiper.transitionStart(runCallbacks, direction);\\n      if (!swiper.animating) {\\n        swiper.animating = true;\\n        if (!swiper.onSlideToWrapperTransitionEnd) {\\n          swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\\n            if (!swiper || swiper.destroyed) { return; }\\n            if (e.target !== this) { return; }\\n            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\\n            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\\n            swiper.onSlideToWrapperTransitionEnd = null;\\n            delete swiper.onSlideToWrapperTransitionEnd;\\n            swiper.transitionEnd(runCallbacks, direction);\\n          };\\n        }\\n        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\\n        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  function slideToLoop (index, speed, runCallbacks, internal) {\\n    if ( index === void 0 ) index = 0;\\n    if ( speed === void 0 ) speed = this.params.speed;\\n    if ( runCallbacks === void 0 ) runCallbacks = true;\\n\\n    var swiper = this;\\n    var newIndex = index;\\n    if (swiper.params.loop) {\\n      newIndex += swiper.loopedSlides;\\n    }\\n\\n    return swiper.slideTo(newIndex, speed, runCallbacks, internal);\\n  }\\n\\n  /* eslint no-unused-vars: \\\"off\\\" */\\n  function slideNext (speed, runCallbacks, internal) {\\n    if ( speed === void 0 ) speed = this.params.speed;\\n    if ( runCallbacks === void 0 ) runCallbacks = true;\\n\\n    var swiper = this;\\n    var params = swiper.params;\\n    var animating = swiper.animating;\\n    if (params.loop) {\\n      if (animating) { return false; }\\n      swiper.loopFix();\\n      // eslint-disable-next-line\\n      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\\n      return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);\\n    }\\n    return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);\\n  }\\n\\n  /* eslint no-unused-vars: \\\"off\\\" */\\n  function slidePrev (speed, runCallbacks, internal) {\\n    if ( speed === void 0 ) speed = this.params.speed;\\n    if ( runCallbacks === void 0 ) runCallbacks = true;\\n\\n    var swiper = this;\\n    var params = swiper.params;\\n    var animating = swiper.animating;\\n    var snapGrid = swiper.snapGrid;\\n    var slidesGrid = swiper.slidesGrid;\\n    var rtlTranslate = swiper.rtlTranslate;\\n\\n    if (params.loop) {\\n      if (animating) { return false; }\\n      swiper.loopFix();\\n      // eslint-disable-next-line\\n      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\\n    }\\n    var translate = rtlTranslate ? swiper.translate : -swiper.translate;\\n    function normalize(val) {\\n      if (val < 0) { return -Math.floor(Math.abs(val)); }\\n      return Math.floor(val);\\n    }\\n    var normalizedTranslate = normalize(translate);\\n    var normalizedSnapGrid = snapGrid.map(function (val) { return normalize(val); });\\n    var normalizedSlidesGrid = slidesGrid.map(function (val) { return normalize(val); });\\n\\n    var currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];\\n    var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\\n    var prevIndex;\\n    if (typeof prevSnap !== 'undefined') {\\n      prevIndex = slidesGrid.indexOf(prevSnap);\\n      if (prevIndex < 0) { prevIndex = swiper.activeIndex - 1; }\\n    }\\n    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\\n  }\\n\\n  /* eslint no-unused-vars: \\\"off\\\" */\\n  function slideReset (speed, runCallbacks, internal) {\\n    if ( speed === void 0 ) speed = this.params.speed;\\n    if ( runCallbacks === void 0 ) runCallbacks = true;\\n\\n    var swiper = this;\\n    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\\n  }\\n\\n  /* eslint no-unused-vars: \\\"off\\\" */\\n  function slideToClosest (speed, runCallbacks, internal) {\\n    if ( speed === void 0 ) speed = this.params.speed;\\n    if ( runCallbacks === void 0 ) runCallbacks = true;\\n\\n    var swiper = this;\\n    var index = swiper.activeIndex;\\n    var snapIndex = Math.floor(index / swiper.params.slidesPerGroup);\\n\\n    if (snapIndex < swiper.snapGrid.length - 1) {\\n      var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\\n\\n      var currentSnap = swiper.snapGrid[snapIndex];\\n      var nextSnap = swiper.snapGrid[snapIndex + 1];\\n\\n      if ((translate - currentSnap) > (nextSnap - currentSnap) / 2) {\\n        index = swiper.params.slidesPerGroup;\\n      }\\n    }\\n\\n    return swiper.slideTo(index, speed, runCallbacks, internal);\\n  }\\n\\n  function slideToClickedSlide () {\\n    var swiper = this;\\n    var params = swiper.params;\\n    var $wrapperEl = swiper.$wrapperEl;\\n\\n    var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\\n    var slideToIndex = swiper.clickedIndex;\\n    var realIndex;\\n    if (params.loop) {\\n      if (swiper.animating) { return; }\\n      realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);\\n      if (params.centeredSlides) {\\n        if (\\n          (slideToIndex < swiper.loopedSlides - (slidesPerView / 2))\\n          || (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))\\n        ) {\\n          swiper.loopFix();\\n          slideToIndex = $wrapperEl\\n            .children((\\\".\\\" + (params.slideClass) + \\\"[data-swiper-slide-index=\\\\\\\"\\\" + realIndex + \\\"\\\\\\\"]:not(.\\\" + (params.slideDuplicateClass) + \\\")\\\"))\\n            .eq(0)\\n            .index();\\n\\n          Utils.nextTick(function () {\\n            swiper.slideTo(slideToIndex);\\n          });\\n        } else {\\n          swiper.slideTo(slideToIndex);\\n        }\\n      } else if (slideToIndex > swiper.slides.length - slidesPerView) {\\n        swiper.loopFix();\\n        slideToIndex = $wrapperEl\\n          .children((\\\".\\\" + (params.slideClass) + \\\"[data-swiper-slide-index=\\\\\\\"\\\" + realIndex + \\\"\\\\\\\"]:not(.\\\" + (params.slideDuplicateClass) + \\\")\\\"))\\n          .eq(0)\\n          .index();\\n\\n        Utils.nextTick(function () {\\n          swiper.slideTo(slideToIndex);\\n        });\\n      } else {\\n        swiper.slideTo(slideToIndex);\\n      }\\n    } else {\\n      swiper.slideTo(slideToIndex);\\n    }\\n  }\\n\\n  var slide = {\\n    slideTo: slideTo,\\n    slideToLoop: slideToLoop,\\n    slideNext: slideNext,\\n    slidePrev: slidePrev,\\n    slideReset: slideReset,\\n    slideToClosest: slideToClosest,\\n    slideToClickedSlide: slideToClickedSlide,\\n  };\\n\\n  function loopCreate () {\\n    var swiper = this;\\n    var params = swiper.params;\\n    var $wrapperEl = swiper.$wrapperEl;\\n    // Remove duplicated slides\\n    $wrapperEl.children((\\\".\\\" + (params.slideClass) + \\\".\\\" + (params.slideDuplicateClass))).remove();\\n\\n    var slides = $wrapperEl.children((\\\".\\\" + (params.slideClass)));\\n\\n    if (params.loopFillGroupWithBlank) {\\n      var blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);\\n      if (blankSlidesNum !== params.slidesPerGroup) {\\n        for (var i = 0; i < blankSlidesNum; i += 1) {\\n          var blankNode = $(doc.createElement('div')).addClass(((params.slideClass) + \\\" \\\" + (params.slideBlankClass)));\\n          $wrapperEl.append(blankNode);\\n        }\\n        slides = $wrapperEl.children((\\\".\\\" + (params.slideClass)));\\n      }\\n    }\\n\\n    if (params.slidesPerView === 'auto' && !params.loopedSlides) { params.loopedSlides = slides.length; }\\n\\n    swiper.loopedSlides = parseInt(params.loopedSlides || params.slidesPerView, 10);\\n    swiper.loopedSlides += params.loopAdditionalSlides;\\n    if (swiper.loopedSlides > slides.length) {\\n      swiper.loopedSlides = slides.length;\\n    }\\n\\n    var prependSlides = [];\\n    var appendSlides = [];\\n    slides.each(function (index, el) {\\n      var slide = $(el);\\n      if (index < swiper.loopedSlides) { appendSlides.push(el); }\\n      if (index < slides.length && index >= slides.length - swiper.loopedSlides) { prependSlides.push(el); }\\n      slide.attr('data-swiper-slide-index', index);\\n    });\\n    for (var i$1 = 0; i$1 < appendSlides.length; i$1 += 1) {\\n      $wrapperEl.append($(appendSlides[i$1].cloneNode(true)).addClass(params.slideDuplicateClass));\\n    }\\n    for (var i$2 = prependSlides.length - 1; i$2 >= 0; i$2 -= 1) {\\n      $wrapperEl.prepend($(prependSlides[i$2].cloneNode(true)).addClass(params.slideDuplicateClass));\\n    }\\n  }\\n\\n  function loopFix () {\\n    var swiper = this;\\n    var params = swiper.params;\\n    var activeIndex = swiper.activeIndex;\\n    var slides = swiper.slides;\\n    var loopedSlides = swiper.loopedSlides;\\n    var allowSlidePrev = swiper.allowSlidePrev;\\n    var allowSlideNext = swiper.allowSlideNext;\\n    var snapGrid = swiper.snapGrid;\\n    var rtl = swiper.rtlTranslate;\\n    var newIndex;\\n    swiper.allowSlidePrev = true;\\n    swiper.allowSlideNext = true;\\n\\n    var snapTranslate = -snapGrid[activeIndex];\\n    var diff = snapTranslate - swiper.getTranslate();\\n\\n\\n    // Fix For Negative Oversliding\\n    if (activeIndex < loopedSlides) {\\n      newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;\\n      newIndex += loopedSlides;\\n      var slideChanged = swiper.slideTo(newIndex, 0, false, true);\\n      if (slideChanged && diff !== 0) {\\n        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\\n      }\\n    } else if ((params.slidesPerView === 'auto' && activeIndex >= loopedSlides * 2) || (activeIndex >= slides.length - loopedSlides)) {\\n      // Fix For Positive Oversliding\\n      newIndex = -slides.length + activeIndex + loopedSlides;\\n      newIndex += loopedSlides;\\n      var slideChanged$1 = swiper.slideTo(newIndex, 0, false, true);\\n      if (slideChanged$1 && diff !== 0) {\\n        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\\n      }\\n    }\\n    swiper.allowSlidePrev = allowSlidePrev;\\n    swiper.allowSlideNext = allowSlideNext;\\n  }\\n\\n  function loopDestroy () {\\n    var swiper = this;\\n    var $wrapperEl = swiper.$wrapperEl;\\n    var params = swiper.params;\\n    var slides = swiper.slides;\\n    $wrapperEl.children((\\\".\\\" + (params.slideClass) + \\\".\\\" + (params.slideDuplicateClass) + \\\",.\\\" + (params.slideClass) + \\\".\\\" + (params.slideBlankClass))).remove();\\n    slides.removeAttr('data-swiper-slide-index');\\n  }\\n\\n  var loop = {\\n    loopCreate: loopCreate,\\n    loopFix: loopFix,\\n    loopDestroy: loopDestroy,\\n  };\\n\\n  function setGrabCursor (moving) {\\n    var swiper = this;\\n    if (Support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked)) { return; }\\n    var el = swiper.el;\\n    el.style.cursor = 'move';\\n    el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';\\n    el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';\\n    el.style.cursor = moving ? 'grabbing' : 'grab';\\n  }\\n\\n  function unsetGrabCursor () {\\n    var swiper = this;\\n    if (Support.touch || (swiper.params.watchOverflow && swiper.isLocked)) { return; }\\n    swiper.el.style.cursor = '';\\n  }\\n\\n  var grabCursor = {\\n    setGrabCursor: setGrabCursor,\\n    unsetGrabCursor: unsetGrabCursor,\\n  };\\n\\n  function appendSlide (slides) {\\n    var swiper = this;\\n    var $wrapperEl = swiper.$wrapperEl;\\n    var params = swiper.params;\\n    if (params.loop) {\\n      swiper.loopDestroy();\\n    }\\n    if (typeof slides === 'object' && 'length' in slides) {\\n      for (var i = 0; i < slides.length; i += 1) {\\n        if (slides[i]) { $wrapperEl.append(slides[i]); }\\n      }\\n    } else {\\n      $wrapperEl.append(slides);\\n    }\\n    if (params.loop) {\\n      swiper.loopCreate();\\n    }\\n    if (!(params.observer && Support.observer)) {\\n      swiper.update();\\n    }\\n  }\\n\\n  function prependSlide (slides) {\\n    var swiper = this;\\n    var params = swiper.params;\\n    var $wrapperEl = swiper.$wrapperEl;\\n    var activeIndex = swiper.activeIndex;\\n\\n    if (params.loop) {\\n      swiper.loopDestroy();\\n    }\\n    var newActiveIndex = activeIndex + 1;\\n    if (typeof slides === 'object' && 'length' in slides) {\\n      for (var i = 0; i < slides.length; i += 1) {\\n        if (slides[i]) { $wrapperEl.prepend(slides[i]); }\\n      }\\n      newActiveIndex = activeIndex + slides.length;\\n    } else {\\n      $wrapperEl.prepend(slides);\\n    }\\n    if (params.loop) {\\n      swiper.loopCreate();\\n    }\\n    if (!(params.observer && Support.observer)) {\\n      swiper.update();\\n    }\\n    swiper.slideTo(newActiveIndex, 0, false);\\n  }\\n\\n  function addSlide (index, slides) {\\n    var swiper = this;\\n    var $wrapperEl = swiper.$wrapperEl;\\n    var params = swiper.params;\\n    var activeIndex = swiper.activeIndex;\\n    var activeIndexBuffer = activeIndex;\\n    if (params.loop) {\\n      activeIndexBuffer -= swiper.loopedSlides;\\n      swiper.loopDestroy();\\n      swiper.slides = $wrapperEl.children((\\\".\\\" + (params.slideClass)));\\n    }\\n    var baseLength = swiper.slides.length;\\n    if (index <= 0) {\\n      swiper.prependSlide(slides);\\n      return;\\n    }\\n    if (index >= baseLength) {\\n      swiper.appendSlide(slides);\\n      return;\\n    }\\n    var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\\n\\n    var slidesBuffer = [];\\n    for (var i = baseLength - 1; i >= index; i -= 1) {\\n      var currentSlide = swiper.slides.eq(i);\\n      currentSlide.remove();\\n      slidesBuffer.unshift(currentSlide);\\n    }\\n\\n    if (typeof slides === 'object' && 'length' in slides) {\\n      for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {\\n        if (slides[i$1]) { $wrapperEl.append(slides[i$1]); }\\n      }\\n      newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\\n    } else {\\n      $wrapperEl.append(slides);\\n    }\\n\\n    for (var i$2 = 0; i$2 < slidesBuffer.length; i$2 += 1) {\\n      $wrapperEl.append(slidesBuffer[i$2]);\\n    }\\n\\n    if (params.loop) {\\n      swiper.loopCreate();\\n    }\\n    if (!(params.observer && Support.observer)) {\\n      swiper.update();\\n    }\\n    if (params.loop) {\\n      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\\n    } else {\\n      swiper.slideTo(newActiveIndex, 0, false);\\n    }\\n  }\\n\\n  function removeSlide (slidesIndexes) {\\n    var swiper = this;\\n    var params = swiper.params;\\n    var $wrapperEl = swiper.$wrapperEl;\\n    var activeIndex = swiper.activeIndex;\\n\\n    var activeIndexBuffer = activeIndex;\\n    if (params.loop) {\\n      activeIndexBuffer -= swiper.loopedSlides;\\n      swiper.loopDestroy();\\n      swiper.slides = $wrapperEl.children((\\\".\\\" + (params.slideClass)));\\n    }\\n    var newActiveIndex = activeIndexBuffer;\\n    var indexToRemove;\\n\\n    if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\\n      for (var i = 0; i < slidesIndexes.length; i += 1) {\\n        indexToRemove = slidesIndexes[i];\\n        if (swiper.slides[indexToRemove]) { swiper.slides.eq(indexToRemove).remove(); }\\n        if (indexToRemove < newActiveIndex) { newActiveIndex -= 1; }\\n      }\\n      newActiveIndex = Math.max(newActiveIndex, 0);\\n    } else {\\n      indexToRemove = slidesIndexes;\\n      if (swiper.slides[indexToRemove]) { swiper.slides.eq(indexToRemove).remove(); }\\n      if (indexToRemove < newActiveIndex) { newActiveIndex -= 1; }\\n      newActiveIndex = Math.max(newActiveIndex, 0);\\n    }\\n\\n    if (params.loop) {\\n      swiper.loopCreate();\\n    }\\n\\n    if (!(params.observer && Support.observer)) {\\n      swiper.update();\\n    }\\n    if (params.loop) {\\n      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\\n    } else {\\n      swiper.slideTo(newActiveIndex, 0, false);\\n    }\\n  }\\n\\n  function removeAllSlides () {\\n    var swiper = this;\\n\\n    var slidesIndexes = [];\\n    for (var i = 0; i < swiper.slides.length; i += 1) {\\n      slidesIndexes.push(i);\\n    }\\n    swiper.removeSlide(slidesIndexes);\\n  }\\n\\n  var manipulation = {\\n    appendSlide: appendSlide,\\n    prependSlide: prependSlide,\\n    addSlide: addSlide,\\n    removeSlide: removeSlide,\\n    removeAllSlides: removeAllSlides,\\n  };\\n\\n  var Device = (function Device() {\\n    var ua = win.navigator.userAgent;\\n\\n    var device = {\\n      ios: false,\\n      android: false,\\n      androidChrome: false,\\n      desktop: false,\\n      windows: false,\\n      iphone: false,\\n      ipod: false,\\n      ipad: false,\\n      cordova: win.cordova || win.phonegap,\\n      phonegap: win.cordova || win.phonegap,\\n    };\\n\\n    var windows = ua.match(/(Windows Phone);?[\\\\s\\\\/]+([\\\\d.]+)?/); // eslint-disable-line\\n    var android = ua.match(/(Android);?[\\\\s\\\\/]+([\\\\d.]+)?/); // eslint-disable-line\\n    var ipad = ua.match(/(iPad).*OS\\\\s([\\\\d_]+)/);\\n    var ipod = ua.match(/(iPod)(.*OS\\\\s([\\\\d_]+))?/);\\n    var iphone = !ipad && ua.match(/(iPhone\\\\sOS|iOS)\\\\s([\\\\d_]+)/);\\n\\n\\n    // Windows\\n    if (windows) {\\n      device.os = 'windows';\\n      device.osVersion = windows[2];\\n      device.windows = true;\\n    }\\n    // Android\\n    if (android && !windows) {\\n      device.os = 'android';\\n      device.osVersion = android[2];\\n      device.android = true;\\n      device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;\\n    }\\n    if (ipad || iphone || ipod) {\\n      device.os = 'ios';\\n      device.ios = true;\\n    }\\n    // iOS\\n    if (iphone && !ipod) {\\n      device.osVersion = iphone[2].replace(/_/g, '.');\\n      device.iphone = true;\\n    }\\n    if (ipad) {\\n      device.osVersion = ipad[2].replace(/_/g, '.');\\n      device.ipad = true;\\n    }\\n    if (ipod) {\\n      device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\\n      device.iphone = true;\\n    }\\n    // iOS 8+ changed UA\\n    if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {\\n      if (device.osVersion.split('.')[0] === '10') {\\n        device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];\\n      }\\n    }\\n\\n    // Desktop\\n    device.desktop = !(device.os || device.android || device.webView);\\n\\n    // Webview\\n    device.webView = (iphone || ipad || ipod) && ua.match(/.*AppleWebKit(?!.*Safari)/i);\\n\\n    // Minimal UI\\n    if (device.os && device.os === 'ios') {\\n      var osVersionArr = device.osVersion.split('.');\\n      var metaViewport = doc.querySelector('meta[name=\\\"viewport\\\"]');\\n      device.minimalUi = !device.webView\\n        && (ipod || iphone)\\n        && (osVersionArr[0] * 1 === 7 ? osVersionArr[1] * 1 >= 1 : osVersionArr[0] * 1 > 7)\\n        && metaViewport && metaViewport.getAttribute('content').indexOf('minimal-ui') >= 0;\\n    }\\n\\n    // Pixel Ratio\\n    device.pixelRatio = win.devicePixelRatio || 1;\\n\\n    // Export object\\n    return device;\\n  }());\\n\\n  function onTouchStart (event) {\\n    var swiper = this;\\n    var data = swiper.touchEventsData;\\n    var params = swiper.params;\\n    var touches = swiper.touches;\\n    if (swiper.animating && params.preventInteractionOnTransition) {\\n      return;\\n    }\\n    var e = event;\\n    if (e.originalEvent) { e = e.originalEvent; }\\n    data.isTouchEvent = e.type === 'touchstart';\\n    if (!data.isTouchEvent && 'which' in e && e.which === 3) { return; }\\n    if (!data.isTouchEvent && 'button' in e && e.button > 0) { return; }\\n    if (data.isTouched && data.isMoved) { return; }\\n    if (params.noSwiping && $(e.target).closest(params.noSwipingSelector ? params.noSwipingSelector : (\\\".\\\" + (params.noSwipingClass)))[0]) {\\n      swiper.allowClick = true;\\n      return;\\n    }\\n    if (params.swipeHandler) {\\n      if (!$(e).closest(params.swipeHandler)[0]) { return; }\\n    }\\n\\n    touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;\\n    touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;\\n    var startX = touches.currentX;\\n    var startY = touches.currentY;\\n\\n    // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore\\n\\n    var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\\n    var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\\n    if (\\n      edgeSwipeDetection\\n      && ((startX <= edgeSwipeThreshold)\\n      || (startX >= win.screen.width - edgeSwipeThreshold))\\n    ) {\\n      return;\\n    }\\n\\n    Utils.extend(data, {\\n      isTouched: true,\\n      isMoved: false,\\n      allowTouchCallbacks: true,\\n      isScrolling: undefined,\\n      startMoving: undefined,\\n    });\\n\\n    touches.startX = startX;\\n    touches.startY = startY;\\n    data.touchStartTime = Utils.now();\\n    swiper.allowClick = true;\\n    swiper.updateSize();\\n    swiper.swipeDirection = undefined;\\n    if (params.threshold > 0) { data.allowThresholdMove = false; }\\n    if (e.type !== 'touchstart') {\\n      var preventDefault = true;\\n      if ($(e.target).is(data.formElements)) { preventDefault = false; }\\n      if (\\n        doc.activeElement\\n        && $(doc.activeElement).is(data.formElements)\\n        && doc.activeElement !== e.target\\n      ) {\\n        doc.activeElement.blur();\\n      }\\n\\n      var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\\n      if (params.touchStartForcePreventDefault || shouldPreventDefault) {\\n        e.preventDefault();\\n      }\\n    }\\n    swiper.emit('touchStart', e);\\n  }\\n\\n  function onTouchMove (event) {\\n    var swiper = this;\\n    var data = swiper.touchEventsData;\\n    var params = swiper.params;\\n    var touches = swiper.touches;\\n    var rtl = swiper.rtlTranslate;\\n    var e = event;\\n    if (e.originalEvent) { e = e.originalEvent; }\\n    if (!data.isTouched) {\\n      if (data.startMoving && data.isScrolling) {\\n        swiper.emit('touchMoveOpposite', e);\\n      }\\n      return;\\n    }\\n    if (data.isTouchEvent && e.type === 'mousemove') { return; }\\n    var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;\\n    var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;\\n    if (e.preventedByNestedSwiper) {\\n      touches.startX = pageX;\\n      touches.startY = pageY;\\n      return;\\n    }\\n    if (!swiper.allowTouchMove) {\\n      // isMoved = true;\\n      swiper.allowClick = false;\\n      if (data.isTouched) {\\n        Utils.extend(touches, {\\n          startX: pageX,\\n          startY: pageY,\\n          currentX: pageX,\\n          currentY: pageY,\\n        });\\n        data.touchStartTime = Utils.now();\\n      }\\n      return;\\n    }\\n    if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {\\n      if (swiper.isVertical()) {\\n        // Vertical\\n        if (\\n          (pageY < touches.startY && swiper.translate <= swiper.maxTranslate())\\n          || (pageY > touches.startY && swiper.translate >= swiper.minTranslate())\\n        ) {\\n          data.isTouched = false;\\n          data.isMoved = false;\\n          return;\\n        }\\n      } else if (\\n        (pageX < touches.startX && swiper.translate <= swiper.maxTranslate())\\n        || (pageX > touches.startX && swiper.translate >= swiper.minTranslate())\\n      ) {\\n        return;\\n      }\\n    }\\n    if (data.isTouchEvent && doc.activeElement) {\\n      if (e.target === doc.activeElement && $(e.target).is(data.formElements)) {\\n        data.isMoved = true;\\n        swiper.allowClick = false;\\n        return;\\n      }\\n    }\\n    if (data.allowTouchCallbacks) {\\n      swiper.emit('touchMove', e);\\n    }\\n    if (e.targetTouches && e.targetTouches.length > 1) { return; }\\n\\n    touches.currentX = pageX;\\n    touches.currentY = pageY;\\n\\n    var diffX = touches.currentX - touches.startX;\\n    var diffY = touches.currentY - touches.startY;\\n    if (swiper.params.threshold && Math.sqrt((Math.pow( diffX, 2 )) + (Math.pow( diffY, 2 ))) < swiper.params.threshold) { return; }\\n\\n    if (typeof data.isScrolling === 'undefined') {\\n      var touchAngle;\\n      if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {\\n        data.isScrolling = false;\\n      } else {\\n        // eslint-disable-next-line\\n        if ((diffX * diffX) + (diffY * diffY) >= 25) {\\n          touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;\\n          data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);\\n        }\\n      }\\n    }\\n    if (data.isScrolling) {\\n      swiper.emit('touchMoveOpposite', e);\\n    }\\n    if (typeof data.startMoving === 'undefined') {\\n      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\\n        data.startMoving = true;\\n      }\\n    }\\n    if (data.isScrolling) {\\n      data.isTouched = false;\\n      return;\\n    }\\n    if (!data.startMoving) {\\n      return;\\n    }\\n    swiper.allowClick = false;\\n    e.preventDefault();\\n    if (params.touchMoveStopPropagation && !params.nested) {\\n      e.stopPropagation();\\n    }\\n\\n    if (!data.isMoved) {\\n      if (params.loop) {\\n        swiper.loopFix();\\n      }\\n      data.startTranslate = swiper.getTranslate();\\n      swiper.setTransition(0);\\n      if (swiper.animating) {\\n        swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');\\n      }\\n      data.allowMomentumBounce = false;\\n      // Grab Cursor\\n      if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\\n        swiper.setGrabCursor(true);\\n      }\\n      swiper.emit('sliderFirstMove', e);\\n    }\\n    swiper.emit('sliderMove', e);\\n    data.isMoved = true;\\n\\n    var diff = swiper.isHorizontal() ? diffX : diffY;\\n    touches.diff = diff;\\n\\n    diff *= params.touchRatio;\\n    if (rtl) { diff = -diff; }\\n\\n    swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\\n    data.currentTranslate = diff + data.startTranslate;\\n\\n    var disableParentSwiper = true;\\n    var resistanceRatio = params.resistanceRatio;\\n    if (params.touchReleaseOnEdges) {\\n      resistanceRatio = 0;\\n    }\\n    if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {\\n      disableParentSwiper = false;\\n      if (params.resistance) { data.currentTranslate = (swiper.minTranslate() - 1) + (Math.pow( (-swiper.minTranslate() + data.startTranslate + diff), resistanceRatio )); }\\n    } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {\\n      disableParentSwiper = false;\\n      if (params.resistance) { data.currentTranslate = (swiper.maxTranslate() + 1) - (Math.pow( (swiper.maxTranslate() - data.startTranslate - diff), resistanceRatio )); }\\n    }\\n\\n    if (disableParentSwiper) {\\n      e.preventedByNestedSwiper = true;\\n    }\\n\\n    // Directions locks\\n    if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {\\n      data.currentTranslate = data.startTranslate;\\n    }\\n    if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {\\n      data.currentTranslate = data.startTranslate;\\n    }\\n\\n\\n    // Threshold\\n    if (params.threshold > 0) {\\n      if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\\n        if (!data.allowThresholdMove) {\\n          data.allowThresholdMove = true;\\n          touches.startX = touches.currentX;\\n          touches.startY = touches.currentY;\\n          data.currentTranslate = data.startTranslate;\\n          touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\\n          return;\\n        }\\n      } else {\\n        data.currentTranslate = data.startTranslate;\\n        return;\\n      }\\n    }\\n\\n    if (!params.followFinger) { return; }\\n\\n    // Update active index in free mode\\n    if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {\\n      swiper.updateActiveIndex();\\n      swiper.updateSlidesClasses();\\n    }\\n    if (params.freeMode) {\\n      // Velocity\\n      if (data.velocities.length === 0) {\\n        data.velocities.push({\\n          position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\\n          time: data.touchStartTime,\\n        });\\n      }\\n      data.velocities.push({\\n        position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\\n        time: Utils.now(),\\n      });\\n    }\\n    // Update progress\\n    swiper.updateProgress(data.currentTranslate);\\n    // Update translate\\n    swiper.setTranslate(data.currentTranslate);\\n  }\\n\\n  function onTouchEnd (event) {\\n    var swiper = this;\\n    var data = swiper.touchEventsData;\\n\\n    var params = swiper.params;\\n    var touches = swiper.touches;\\n    var rtl = swiper.rtlTranslate;\\n    var $wrapperEl = swiper.$wrapperEl;\\n    var slidesGrid = swiper.slidesGrid;\\n    var snapGrid = swiper.snapGrid;\\n    var e = event;\\n    if (e.originalEvent) { e = e.originalEvent; }\\n    if (data.allowTouchCallbacks) {\\n      swiper.emit('touchEnd', e);\\n    }\\n    data.allowTouchCallbacks = false;\\n    if (!data.isTouched) {\\n      if (data.isMoved && params.grabCursor) {\\n        swiper.setGrabCursor(false);\\n      }\\n      data.isMoved = false;\\n      data.startMoving = false;\\n      return;\\n    }\\n    // Return Grab Cursor\\n    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\\n      swiper.setGrabCursor(false);\\n    }\\n\\n    // Time diff\\n    var touchEndTime = Utils.now();\\n    var timeDiff = touchEndTime - data.touchStartTime;\\n\\n    // Tap, doubleTap, Click\\n    if (swiper.allowClick) {\\n      swiper.updateClickedSlide(e);\\n      swiper.emit('tap', e);\\n      if (timeDiff < 300 && (touchEndTime - data.lastClickTime) > 300) {\\n        if (data.clickTimeout) { clearTimeout(data.clickTimeout); }\\n        data.clickTimeout = Utils.nextTick(function () {\\n          if (!swiper || swiper.destroyed) { return; }\\n          swiper.emit('click', e);\\n        }, 300);\\n      }\\n      if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {\\n        if (data.clickTimeout) { clearTimeout(data.clickTimeout); }\\n        swiper.emit('doubleTap', e);\\n      }\\n    }\\n\\n    data.lastClickTime = Utils.now();\\n    Utils.nextTick(function () {\\n      if (!swiper.destroyed) { swiper.allowClick = true; }\\n    });\\n\\n    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\\n      data.isTouched = false;\\n      data.isMoved = false;\\n      data.startMoving = false;\\n      return;\\n    }\\n    data.isTouched = false;\\n    data.isMoved = false;\\n    data.startMoving = false;\\n\\n    var currentPos;\\n    if (params.followFinger) {\\n      currentPos = rtl ? swiper.translate : -swiper.translate;\\n    } else {\\n      currentPos = -data.currentTranslate;\\n    }\\n\\n    if (params.freeMode) {\\n      if (currentPos < -swiper.minTranslate()) {\\n        swiper.slideTo(swiper.activeIndex);\\n        return;\\n      }\\n      if (currentPos > -swiper.maxTranslate()) {\\n        if (swiper.slides.length < snapGrid.length) {\\n          swiper.slideTo(snapGrid.length - 1);\\n        } else {\\n          swiper.slideTo(swiper.slides.length - 1);\\n        }\\n        return;\\n      }\\n\\n      if (params.freeModeMomentum) {\\n        if (data.velocities.length > 1) {\\n          var lastMoveEvent = data.velocities.pop();\\n          var velocityEvent = data.velocities.pop();\\n\\n          var distance = lastMoveEvent.position - velocityEvent.position;\\n          var time = lastMoveEvent.time - velocityEvent.time;\\n          swiper.velocity = distance / time;\\n          swiper.velocity /= 2;\\n          if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {\\n            swiper.velocity = 0;\\n          }\\n          // this implies that the user stopped moving a finger then released.\\n          // There would be no events with distance zero, so the last event is stale.\\n          if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {\\n            swiper.velocity = 0;\\n          }\\n        } else {\\n          swiper.velocity = 0;\\n        }\\n        swiper.velocity *= params.freeModeMomentumVelocityRatio;\\n\\n        data.velocities.length = 0;\\n        var momentumDuration = 1000 * params.freeModeMomentumRatio;\\n        var momentumDistance = swiper.velocity * momentumDuration;\\n\\n        var newPosition = swiper.translate + momentumDistance;\\n        if (rtl) { newPosition = -newPosition; }\\n\\n        var doBounce = false;\\n        var afterBouncePosition;\\n        var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;\\n        var needsLoopFix;\\n        if (newPosition < swiper.maxTranslate()) {\\n          if (params.freeModeMomentumBounce) {\\n            if (newPosition + swiper.maxTranslate() < -bounceAmount) {\\n              newPosition = swiper.maxTranslate() - bounceAmount;\\n            }\\n            afterBouncePosition = swiper.maxTranslate();\\n            doBounce = true;\\n            data.allowMomentumBounce = true;\\n          } else {\\n            newPosition = swiper.maxTranslate();\\n          }\\n          if (params.loop && params.centeredSlides) { needsLoopFix = true; }\\n        } else if (newPosition > swiper.minTranslate()) {\\n          if (params.freeModeMomentumBounce) {\\n            if (newPosition - swiper.minTranslate() > bounceAmount) {\\n              newPosition = swiper.minTranslate() + bounceAmount;\\n            }\\n            afterBouncePosition = swiper.minTranslate();\\n            doBounce = true;\\n            data.allowMomentumBounce = true;\\n          } else {\\n            newPosition = swiper.minTranslate();\\n          }\\n          if (params.loop && params.centeredSlides) { needsLoopFix = true; }\\n        } else if (params.freeModeSticky) {\\n          var nextSlide;\\n          for (var j = 0; j < snapGrid.length; j += 1) {\\n            if (snapGrid[j] > -newPosition) {\\n              nextSlide = j;\\n              break;\\n            }\\n          }\\n\\n          if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\\n            newPosition = snapGrid[nextSlide];\\n          } else {\\n            newPosition = snapGrid[nextSlide - 1];\\n          }\\n          newPosition = -newPosition;\\n        }\\n        if (needsLoopFix) {\\n          swiper.once('transitionEnd', function () {\\n            swiper.loopFix();\\n          });\\n        }\\n        // Fix duration\\n        if (swiper.velocity !== 0) {\\n          if (rtl) {\\n            momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\\n          } else {\\n            momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\\n          }\\n        } else if (params.freeModeSticky) {\\n          swiper.slideToClosest();\\n          return;\\n        }\\n\\n        if (params.freeModeMomentumBounce && doBounce) {\\n          swiper.updateProgress(afterBouncePosition);\\n          swiper.setTransition(momentumDuration);\\n          swiper.setTranslate(newPosition);\\n          swiper.transitionStart(true, swiper.swipeDirection);\\n          swiper.animating = true;\\n          $wrapperEl.transitionEnd(function () {\\n            if (!swiper || swiper.destroyed || !data.allowMomentumBounce) { return; }\\n            swiper.emit('momentumBounce');\\n\\n            swiper.setTransition(params.speed);\\n            swiper.setTranslate(afterBouncePosition);\\n            $wrapperEl.transitionEnd(function () {\\n              if (!swiper || swiper.destroyed) { return; }\\n              swiper.transitionEnd();\\n            });\\n          });\\n        } else if (swiper.velocity) {\\n          swiper.updateProgress(newPosition);\\n          swiper.setTransition(momentumDuration);\\n          swiper.setTranslate(newPosition);\\n          swiper.transitionStart(true, swiper.swipeDirection);\\n          if (!swiper.animating) {\\n            swiper.animating = true;\\n            $wrapperEl.transitionEnd(function () {\\n              if (!swiper || swiper.destroyed) { return; }\\n              swiper.transitionEnd();\\n            });\\n          }\\n        } else {\\n          swiper.updateProgress(newPosition);\\n        }\\n\\n        swiper.updateActiveIndex();\\n        swiper.updateSlidesClasses();\\n      } else if (params.freeModeSticky) {\\n        swiper.slideToClosest();\\n        return;\\n      }\\n\\n      if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {\\n        swiper.updateProgress();\\n        swiper.updateActiveIndex();\\n        swiper.updateSlidesClasses();\\n      }\\n      return;\\n    }\\n\\n    // Find current slide\\n    var stopIndex = 0;\\n    var groupSize = swiper.slidesSizesGrid[0];\\n    for (var i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {\\n      if (typeof slidesGrid[i + params.slidesPerGroup] !== 'undefined') {\\n        if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {\\n          stopIndex = i;\\n          groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];\\n        }\\n      } else if (currentPos >= slidesGrid[i]) {\\n        stopIndex = i;\\n        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\\n      }\\n    }\\n\\n    // Find current slide size\\n    var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\\n\\n    if (timeDiff > params.longSwipesMs) {\\n      // Long touches\\n      if (!params.longSwipes) {\\n        swiper.slideTo(swiper.activeIndex);\\n        return;\\n      }\\n      if (swiper.swipeDirection === 'next') {\\n        if (ratio >= params.longSwipesRatio) { swiper.slideTo(stopIndex + params.slidesPerGroup); }\\n        else { swiper.slideTo(stopIndex); }\\n      }\\n      if (swiper.swipeDirection === 'prev') {\\n        if (ratio > (1 - params.longSwipesRatio)) { swiper.slideTo(stopIndex + params.slidesPerGroup); }\\n        else { swiper.slideTo(stopIndex); }\\n      }\\n    } else {\\n      // Short swipes\\n      if (!params.shortSwipes) {\\n        swiper.slideTo(swiper.activeIndex);\\n        return;\\n      }\\n      if (swiper.swipeDirection === 'next') {\\n        swiper.slideTo(stopIndex + params.slidesPerGroup);\\n      }\\n      if (swiper.swipeDirection === 'prev') {\\n        swiper.slideTo(stopIndex);\\n      }\\n    }\\n  }\\n\\n  function onResize () {\\n    var swiper = this;\\n\\n    var params = swiper.params;\\n    var el = swiper.el;\\n\\n    if (el && el.offsetWidth === 0) { return; }\\n\\n    // Breakpoints\\n    if (params.breakpoints) {\\n      swiper.setBreakpoint();\\n    }\\n\\n    // Save locks\\n    var allowSlideNext = swiper.allowSlideNext;\\n    var allowSlidePrev = swiper.allowSlidePrev;\\n    var snapGrid = swiper.snapGrid;\\n\\n    // Disable locks on resize\\n    swiper.allowSlideNext = true;\\n    swiper.allowSlidePrev = true;\\n\\n    swiper.updateSize();\\n    swiper.updateSlides();\\n\\n    if (params.freeMode) {\\n      var newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());\\n      swiper.setTranslate(newTranslate);\\n      swiper.updateActiveIndex();\\n      swiper.updateSlidesClasses();\\n\\n      if (params.autoHeight) {\\n        swiper.updateAutoHeight();\\n      }\\n    } else {\\n      swiper.updateSlidesClasses();\\n      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {\\n        swiper.slideTo(swiper.slides.length - 1, 0, false, true);\\n      } else {\\n        swiper.slideTo(swiper.activeIndex, 0, false, true);\\n      }\\n    }\\n    // Return locks after resize\\n    swiper.allowSlidePrev = allowSlidePrev;\\n    swiper.allowSlideNext = allowSlideNext;\\n\\n    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\\n      swiper.checkOverflow();\\n    }\\n  }\\n\\n  function onClick (e) {\\n    var swiper = this;\\n    if (!swiper.allowClick) {\\n      if (swiper.params.preventClicks) { e.preventDefault(); }\\n      if (swiper.params.preventClicksPropagation && swiper.animating) {\\n        e.stopPropagation();\\n        e.stopImmediatePropagation();\\n      }\\n    }\\n  }\\n\\n  function attachEvents() {\\n    var swiper = this;\\n    var params = swiper.params;\\n    var touchEvents = swiper.touchEvents;\\n    var el = swiper.el;\\n    var wrapperEl = swiper.wrapperEl;\\n\\n    {\\n      swiper.onTouchStart = onTouchStart.bind(swiper);\\n      swiper.onTouchMove = onTouchMove.bind(swiper);\\n      swiper.onTouchEnd = onTouchEnd.bind(swiper);\\n    }\\n\\n    swiper.onClick = onClick.bind(swiper);\\n\\n    var target = params.touchEventsTarget === 'container' ? el : wrapperEl;\\n    var capture = !!params.nested;\\n\\n    // Touch Events\\n    {\\n      if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {\\n        target.addEventListener(touchEvents.start, swiper.onTouchStart, false);\\n        doc.addEventListener(touchEvents.move, swiper.onTouchMove, capture);\\n        doc.addEventListener(touchEvents.end, swiper.onTouchEnd, false);\\n      } else {\\n        if (Support.touch) {\\n          var passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;\\n          target.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);\\n          target.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? { passive: false, capture: capture } : capture);\\n          target.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);\\n        }\\n        if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {\\n          target.addEventListener('mousedown', swiper.onTouchStart, false);\\n          doc.addEventListener('mousemove', swiper.onTouchMove, capture);\\n          doc.addEventListener('mouseup', swiper.onTouchEnd, false);\\n        }\\n      }\\n      // Prevent Links Clicks\\n      if (params.preventClicks || params.preventClicksPropagation) {\\n        target.addEventListener('click', swiper.onClick, true);\\n      }\\n    }\\n\\n    // Resize handler\\n    swiper.on((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize, true);\\n  }\\n\\n  function detachEvents() {\\n    var swiper = this;\\n\\n    var params = swiper.params;\\n    var touchEvents = swiper.touchEvents;\\n    var el = swiper.el;\\n    var wrapperEl = swiper.wrapperEl;\\n\\n    var target = params.touchEventsTarget === 'container' ? el : wrapperEl;\\n    var capture = !!params.nested;\\n\\n    // Touch Events\\n    {\\n      if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {\\n        target.removeEventListener(touchEvents.start, swiper.onTouchStart, false);\\n        doc.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);\\n        doc.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);\\n      } else {\\n        if (Support.touch) {\\n          var passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;\\n          target.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);\\n          target.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);\\n          target.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);\\n        }\\n        if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {\\n          target.removeEventListener('mousedown', swiper.onTouchStart, false);\\n          doc.removeEventListener('mousemove', swiper.onTouchMove, capture);\\n          doc.removeEventListener('mouseup', swiper.onTouchEnd, false);\\n        }\\n      }\\n      // Prevent Links Clicks\\n      if (params.preventClicks || params.preventClicksPropagation) {\\n        target.removeEventListener('click', swiper.onClick, true);\\n      }\\n    }\\n\\n    // Resize handler\\n    swiper.off((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize);\\n  }\\n\\n  var events = {\\n    attachEvents: attachEvents,\\n    detachEvents: detachEvents,\\n  };\\n\\n  function setBreakpoint () {\\n    var swiper = this;\\n    var activeIndex = swiper.activeIndex;\\n    var initialized = swiper.initialized;\\n    var loopedSlides = swiper.loopedSlides; if ( loopedSlides === void 0 ) loopedSlides = 0;\\n    var params = swiper.params;\\n    var breakpoints = params.breakpoints;\\n    if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) { return; }\\n\\n    // Set breakpoint for window width and update parameters\\n    var breakpoint = swiper.getBreakpoint(breakpoints);\\n\\n    if (breakpoint && swiper.currentBreakpoint !== breakpoint) {\\n      var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\\n      if (breakpointOnlyParams) {\\n        ['slidesPerView', 'spaceBetween', 'slidesPerGroup'].forEach(function (param) {\\n          var paramValue = breakpointOnlyParams[param];\\n          if (typeof paramValue === 'undefined') { return; }\\n          if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {\\n            breakpointOnlyParams[param] = 'auto';\\n          } else if (param === 'slidesPerView') {\\n            breakpointOnlyParams[param] = parseFloat(paramValue);\\n          } else {\\n            breakpointOnlyParams[param] = parseInt(paramValue, 10);\\n          }\\n        });\\n      }\\n\\n      var breakpointParams = breakpointOnlyParams || swiper.originalParams;\\n      var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView);\\n\\n      Utils.extend(swiper.params, breakpointParams);\\n\\n      Utils.extend(swiper, {\\n        allowTouchMove: swiper.params.allowTouchMove,\\n        allowSlideNext: swiper.params.allowSlideNext,\\n        allowSlidePrev: swiper.params.allowSlidePrev,\\n      });\\n\\n      swiper.currentBreakpoint = breakpoint;\\n\\n      if (needsReLoop && initialized) {\\n        swiper.loopDestroy();\\n        swiper.loopCreate();\\n        swiper.updateSlides();\\n        swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);\\n      }\\n      swiper.emit('breakpoint', breakpointParams);\\n    }\\n  }\\n\\n  function getBreakpoint (breakpoints) {\\n    var swiper = this;\\n    // Get breakpoint for window width\\n    if (!breakpoints) { return undefined; }\\n    var breakpoint = false;\\n    var points = [];\\n    Object.keys(breakpoints).forEach(function (point) {\\n      points.push(point);\\n    });\\n    points.sort(function (a, b) { return parseInt(a, 10) - parseInt(b, 10); });\\n    for (var i = 0; i < points.length; i += 1) {\\n      var point = points[i];\\n      if (swiper.params.breakpointsInverse) {\\n        if (point <= win.innerWidth) {\\n          breakpoint = point;\\n        }\\n      } else if (point >= win.innerWidth && !breakpoint) {\\n        breakpoint = point;\\n      }\\n    }\\n    return breakpoint || 'max';\\n  }\\n\\n  var breakpoints = { setBreakpoint: setBreakpoint, getBreakpoint: getBreakpoint };\\n\\n  var Browser = (function Browser() {\\n    function isSafari() {\\n      var ua = win.navigator.userAgent.toLowerCase();\\n      return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);\\n    }\\n    return {\\n      isIE: !!win.navigator.userAgent.match(/Trident/g) || !!win.navigator.userAgent.match(/MSIE/g),\\n      isEdge: !!win.navigator.userAgent.match(/Edge/g),\\n      isSafari: isSafari(),\\n      isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win.navigator.userAgent),\\n    };\\n  }());\\n\\n  function addClasses () {\\n    var swiper = this;\\n    var classNames = swiper.classNames;\\n    var params = swiper.params;\\n    var rtl = swiper.rtl;\\n    var $el = swiper.$el;\\n    var suffixes = [];\\n\\n    suffixes.push(params.direction);\\n\\n    if (params.freeMode) {\\n      suffixes.push('free-mode');\\n    }\\n    if (!Support.flexbox) {\\n      suffixes.push('no-flexbox');\\n    }\\n    if (params.autoHeight) {\\n      suffixes.push('autoheight');\\n    }\\n    if (rtl) {\\n      suffixes.push('rtl');\\n    }\\n    if (params.slidesPerColumn > 1) {\\n      suffixes.push('multirow');\\n    }\\n    if (Device.android) {\\n      suffixes.push('android');\\n    }\\n    if (Device.ios) {\\n      suffixes.push('ios');\\n    }\\n    // WP8 Touch Events Fix\\n    if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {\\n      suffixes.push((\\\"wp8-\\\" + (params.direction)));\\n    }\\n\\n    suffixes.forEach(function (suffix) {\\n      classNames.push(params.containerModifierClass + suffix);\\n    });\\n\\n    $el.addClass(classNames.join(' '));\\n  }\\n\\n  function removeClasses () {\\n    var swiper = this;\\n    var $el = swiper.$el;\\n    var classNames = swiper.classNames;\\n\\n    $el.removeClass(classNames.join(' '));\\n  }\\n\\n  var classes = { addClasses: addClasses, removeClasses: removeClasses };\\n\\n  function loadImage (imageEl, src, srcset, sizes, checkForComplete, callback) {\\n    var image;\\n    function onReady() {\\n      if (callback) { callback(); }\\n    }\\n    if (!imageEl.complete || !checkForComplete) {\\n      if (src) {\\n        image = new win.Image();\\n        image.onload = onReady;\\n        image.onerror = onReady;\\n        if (sizes) {\\n          image.sizes = sizes;\\n        }\\n        if (srcset) {\\n          image.srcset = srcset;\\n        }\\n        if (src) {\\n          image.src = src;\\n        }\\n      } else {\\n        onReady();\\n      }\\n    } else {\\n      // image already loaded...\\n      onReady();\\n    }\\n  }\\n\\n  function preloadImages () {\\n    var swiper = this;\\n    swiper.imagesToLoad = swiper.$el.find('img');\\n    function onReady() {\\n      if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) { return; }\\n      if (swiper.imagesLoaded !== undefined) { swiper.imagesLoaded += 1; }\\n      if (swiper.imagesLoaded === swiper.imagesToLoad.length) {\\n        if (swiper.params.updateOnImagesReady) { swiper.update(); }\\n        swiper.emit('imagesReady');\\n      }\\n    }\\n    for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {\\n      var imageEl = swiper.imagesToLoad[i];\\n      swiper.loadImage(\\n        imageEl,\\n        imageEl.currentSrc || imageEl.getAttribute('src'),\\n        imageEl.srcset || imageEl.getAttribute('srcset'),\\n        imageEl.sizes || imageEl.getAttribute('sizes'),\\n        true,\\n        onReady\\n      );\\n    }\\n  }\\n\\n  var images = {\\n    loadImage: loadImage,\\n    preloadImages: preloadImages,\\n  };\\n\\n  function checkOverflow() {\\n    var swiper = this;\\n    var wasLocked = swiper.isLocked;\\n\\n    swiper.isLocked = swiper.snapGrid.length === 1;\\n    swiper.allowSlideNext = !swiper.isLocked;\\n    swiper.allowSlidePrev = !swiper.isLocked;\\n\\n    // events\\n    if (wasLocked !== swiper.isLocked) { swiper.emit(swiper.isLocked ? 'lock' : 'unlock'); }\\n\\n    if (wasLocked && wasLocked !== swiper.isLocked) {\\n      swiper.isEnd = false;\\n      swiper.navigation.update();\\n    }\\n  }\\n\\n  var checkOverflow$1 = { checkOverflow: checkOverflow };\\n\\n  var defaults = {\\n    init: true,\\n    direction: 'horizontal',\\n    touchEventsTarget: 'container',\\n    initialSlide: 0,\\n    speed: 300,\\n    //\\n    preventInteractionOnTransition: false,\\n\\n    // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).\\n    edgeSwipeDetection: false,\\n    edgeSwipeThreshold: 20,\\n\\n    // Free mode\\n    freeMode: false,\\n    freeModeMomentum: true,\\n    freeModeMomentumRatio: 1,\\n    freeModeMomentumBounce: true,\\n    freeModeMomentumBounceRatio: 1,\\n    freeModeMomentumVelocityRatio: 1,\\n    freeModeSticky: false,\\n    freeModeMinimumVelocity: 0.02,\\n\\n    // Autoheight\\n    autoHeight: false,\\n\\n    // Set wrapper width\\n    setWrapperSize: false,\\n\\n    // Virtual Translate\\n    virtualTranslate: false,\\n\\n    // Effects\\n    effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\\n\\n    // Breakpoints\\n    breakpoints: undefined,\\n    breakpointsInverse: false,\\n\\n    // Slides grid\\n    spaceBetween: 0,\\n    slidesPerView: 1,\\n    slidesPerColumn: 1,\\n    slidesPerColumnFill: 'column',\\n    slidesPerGroup: 1,\\n    centeredSlides: false,\\n    slidesOffsetBefore: 0, // in px\\n    slidesOffsetAfter: 0, // in px\\n    normalizeSlideIndex: true,\\n    centerInsufficientSlides: false,\\n\\n    // Disable swiper and hide navigation when container not overflow\\n    watchOverflow: false,\\n\\n    // Round length\\n    roundLengths: false,\\n\\n    // Touches\\n    touchRatio: 1,\\n    touchAngle: 45,\\n    simulateTouch: true,\\n    shortSwipes: true,\\n    longSwipes: true,\\n    longSwipesRatio: 0.5,\\n    longSwipesMs: 300,\\n    followFinger: true,\\n    allowTouchMove: true,\\n    threshold: 0,\\n    touchMoveStopPropagation: true,\\n    touchStartPreventDefault: true,\\n    touchStartForcePreventDefault: false,\\n    touchReleaseOnEdges: false,\\n\\n    // Unique Navigation Elements\\n    uniqueNavElements: true,\\n\\n    // Resistance\\n    resistance: true,\\n    resistanceRatio: 0.85,\\n\\n    // Progress\\n    watchSlidesProgress: false,\\n    watchSlidesVisibility: false,\\n\\n    // Cursor\\n    grabCursor: false,\\n\\n    // Clicks\\n    preventClicks: true,\\n    preventClicksPropagation: true,\\n    slideToClickedSlide: false,\\n\\n    // Images\\n    preloadImages: true,\\n    updateOnImagesReady: true,\\n\\n    // loop\\n    loop: false,\\n    loopAdditionalSlides: 0,\\n    loopedSlides: null,\\n    loopFillGroupWithBlank: false,\\n\\n    // Swiping/no swiping\\n    allowSlidePrev: true,\\n    allowSlideNext: true,\\n    swipeHandler: null, // '.swipe-handler',\\n    noSwiping: true,\\n    noSwipingClass: 'swiper-no-swiping',\\n    noSwipingSelector: null,\\n\\n    // Passive Listeners\\n    passiveListeners: true,\\n\\n    // NS\\n    containerModifierClass: 'swiper-container-', // NEW\\n    slideClass: 'swiper-slide',\\n    slideBlankClass: 'swiper-slide-invisible-blank',\\n    slideActiveClass: 'swiper-slide-active',\\n    slideDuplicateActiveClass: 'swiper-slide-duplicate-active',\\n    slideVisibleClass: 'swiper-slide-visible',\\n    slideDuplicateClass: 'swiper-slide-duplicate',\\n    slideNextClass: 'swiper-slide-next',\\n    slideDuplicateNextClass: 'swiper-slide-duplicate-next',\\n    slidePrevClass: 'swiper-slide-prev',\\n    slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',\\n    wrapperClass: 'swiper-wrapper',\\n\\n    // Callbacks\\n    runCallbacksOnInit: true,\\n  };\\n\\n  var prototypes = {\\n    update: update,\\n    translate: translate,\\n    transition: transition$1,\\n    slide: slide,\\n    loop: loop,\\n    grabCursor: grabCursor,\\n    manipulation: manipulation,\\n    events: events,\\n    breakpoints: breakpoints,\\n    checkOverflow: checkOverflow$1,\\n    classes: classes,\\n    images: images,\\n  };\\n\\n  var extendedDefaults = {};\\n\\n  var Swiper = /*@__PURE__*/(function (SwiperClass$$1) {\\n    function Swiper() {\\n      var assign;\\n\\n      var args = [], len = arguments.length;\\n      while ( len-- ) args[ len ] = arguments[ len ];\\n      var el;\\n      var params;\\n      if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {\\n        params = args[0];\\n      } else {\\n        (assign = args, el = assign[0], params = assign[1]);\\n      }\\n      if (!params) { params = {}; }\\n\\n      params = Utils.extend({}, params);\\n      if (el && !params.el) { params.el = el; }\\n\\n      SwiperClass$$1.call(this, params);\\n\\n      Object.keys(prototypes).forEach(function (prototypeGroup) {\\n        Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {\\n          if (!Swiper.prototype[protoMethod]) {\\n            Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\\n          }\\n        });\\n      });\\n\\n      // Swiper Instance\\n      var swiper = this;\\n      if (typeof swiper.modules === 'undefined') {\\n        swiper.modules = {};\\n      }\\n      Object.keys(swiper.modules).forEach(function (moduleName) {\\n        var module = swiper.modules[moduleName];\\n        if (module.params) {\\n          var moduleParamName = Object.keys(module.params)[0];\\n          var moduleParams = module.params[moduleParamName];\\n          if (typeof moduleParams !== 'object' || moduleParams === null) { return; }\\n          if (!(moduleParamName in params && 'enabled' in moduleParams)) { return; }\\n          if (params[moduleParamName] === true) {\\n            params[moduleParamName] = { enabled: true };\\n          }\\n          if (\\n            typeof params[moduleParamName] === 'object'\\n            && !('enabled' in params[moduleParamName])\\n          ) {\\n            params[moduleParamName].enabled = true;\\n          }\\n          if (!params[moduleParamName]) { params[moduleParamName] = { enabled: false }; }\\n        }\\n      });\\n\\n      // Extend defaults with modules params\\n      var swiperParams = Utils.extend({}, defaults);\\n      swiper.useModulesParams(swiperParams);\\n\\n      // Extend defaults with passed params\\n      swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);\\n      swiper.originalParams = Utils.extend({}, swiper.params);\\n      swiper.passedParams = Utils.extend({}, params);\\n\\n      // Save Dom lib\\n      swiper.$ = $;\\n\\n      // Find el\\n      var $el = $(swiper.params.el);\\n      el = $el[0];\\n\\n      if (!el) {\\n        return undefined;\\n      }\\n\\n      if ($el.length > 1) {\\n        var swipers = [];\\n        $el.each(function (index, containerEl) {\\n          var newParams = Utils.extend({}, params, { el: containerEl });\\n          swipers.push(new Swiper(newParams));\\n        });\\n        return swipers;\\n      }\\n\\n      el.swiper = swiper;\\n      $el.data('swiper', swiper);\\n\\n      // Find Wrapper\\n      var $wrapperEl = $el.children((\\\".\\\" + (swiper.params.wrapperClass)));\\n\\n      // Extend Swiper\\n      Utils.extend(swiper, {\\n        $el: $el,\\n        el: el,\\n        $wrapperEl: $wrapperEl,\\n        wrapperEl: $wrapperEl[0],\\n\\n        // Classes\\n        classNames: [],\\n\\n        // Slides\\n        slides: $(),\\n        slidesGrid: [],\\n        snapGrid: [],\\n        slidesSizesGrid: [],\\n\\n        // isDirection\\n        isHorizontal: function isHorizontal() {\\n          return swiper.params.direction === 'horizontal';\\n        },\\n        isVertical: function isVertical() {\\n          return swiper.params.direction === 'vertical';\\n        },\\n        // RTL\\n        rtl: (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),\\n        rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),\\n        wrongRTL: $wrapperEl.css('display') === '-webkit-box',\\n\\n        // Indexes\\n        activeIndex: 0,\\n        realIndex: 0,\\n\\n        //\\n        isBeginning: true,\\n        isEnd: false,\\n\\n        // Props\\n        translate: 0,\\n        previousTranslate: 0,\\n        progress: 0,\\n        velocity: 0,\\n        animating: false,\\n\\n        // Locks\\n        allowSlideNext: swiper.params.allowSlideNext,\\n        allowSlidePrev: swiper.params.allowSlidePrev,\\n\\n        // Touch Events\\n        touchEvents: (function touchEvents() {\\n          var touch = ['touchstart', 'touchmove', 'touchend'];\\n          var desktop = ['mousedown', 'mousemove', 'mouseup'];\\n          if (Support.pointerEvents) {\\n            desktop = ['pointerdown', 'pointermove', 'pointerup'];\\n          } else if (Support.prefixedPointerEvents) {\\n            desktop = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp'];\\n          }\\n          swiper.touchEventsTouch = {\\n            start: touch[0],\\n            move: touch[1],\\n            end: touch[2],\\n          };\\n          swiper.touchEventsDesktop = {\\n            start: desktop[0],\\n            move: desktop[1],\\n            end: desktop[2],\\n          };\\n          return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;\\n        }()),\\n        touchEventsData: {\\n          isTouched: undefined,\\n          isMoved: undefined,\\n          allowTouchCallbacks: undefined,\\n          touchStartTime: undefined,\\n          isScrolling: undefined,\\n          currentTranslate: undefined,\\n          startTranslate: undefined,\\n          allowThresholdMove: undefined,\\n          // Form elements to match\\n          formElements: 'input, select, option, textarea, button, video',\\n          // Last click time\\n          lastClickTime: Utils.now(),\\n          clickTimeout: undefined,\\n          // Velocities\\n          velocities: [],\\n          allowMomentumBounce: undefined,\\n          isTouchEvent: undefined,\\n          startMoving: undefined,\\n        },\\n\\n        // Clicks\\n        allowClick: true,\\n\\n        // Touches\\n        allowTouchMove: swiper.params.allowTouchMove,\\n\\n        touches: {\\n          startX: 0,\\n          startY: 0,\\n          currentX: 0,\\n          currentY: 0,\\n          diff: 0,\\n        },\\n\\n        // Images\\n        imagesToLoad: [],\\n        imagesLoaded: 0,\\n\\n      });\\n\\n      // Install Modules\\n      swiper.useModules();\\n\\n      // Init\\n      if (swiper.params.init) {\\n        swiper.init();\\n      }\\n\\n      // Return app instance\\n      return swiper;\\n    }\\n\\n    if ( SwiperClass$$1 ) Swiper.__proto__ = SwiperClass$$1;\\n    Swiper.prototype = Object.create( SwiperClass$$1 && SwiperClass$$1.prototype );\\n    Swiper.prototype.constructor = Swiper;\\n\\n    var staticAccessors = { extendedDefaults: { configurable: true },defaults: { configurable: true },Class: { configurable: true },$: { configurable: true } };\\n\\n    Swiper.prototype.slidesPerViewDynamic = function slidesPerViewDynamic () {\\n      var swiper = this;\\n      var params = swiper.params;\\n      var slides = swiper.slides;\\n      var slidesGrid = swiper.slidesGrid;\\n      var swiperSize = swiper.size;\\n      var activeIndex = swiper.activeIndex;\\n      var spv = 1;\\n      if (params.centeredSlides) {\\n        var slideSize = slides[activeIndex].swiperSlideSize;\\n        var breakLoop;\\n        for (var i = activeIndex + 1; i < slides.length; i += 1) {\\n          if (slides[i] && !breakLoop) {\\n            slideSize += slides[i].swiperSlideSize;\\n            spv += 1;\\n            if (slideSize > swiperSize) { breakLoop = true; }\\n          }\\n        }\\n        for (var i$1 = activeIndex - 1; i$1 >= 0; i$1 -= 1) {\\n          if (slides[i$1] && !breakLoop) {\\n            slideSize += slides[i$1].swiperSlideSize;\\n            spv += 1;\\n            if (slideSize > swiperSize) { breakLoop = true; }\\n          }\\n        }\\n      } else {\\n        for (var i$2 = activeIndex + 1; i$2 < slides.length; i$2 += 1) {\\n          if (slidesGrid[i$2] - slidesGrid[activeIndex] < swiperSize) {\\n            spv += 1;\\n          }\\n        }\\n      }\\n      return spv;\\n    };\\n\\n    Swiper.prototype.update = function update$$1 () {\\n      var swiper = this;\\n      if (!swiper || swiper.destroyed) { return; }\\n      var snapGrid = swiper.snapGrid;\\n      var params = swiper.params;\\n      // Breakpoints\\n      if (params.breakpoints) {\\n        swiper.setBreakpoint();\\n      }\\n      swiper.updateSize();\\n      swiper.updateSlides();\\n      swiper.updateProgress();\\n      swiper.updateSlidesClasses();\\n\\n      function setTranslate() {\\n        var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\\n        var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\\n        swiper.setTranslate(newTranslate);\\n        swiper.updateActiveIndex();\\n        swiper.updateSlidesClasses();\\n      }\\n      var translated;\\n      if (swiper.params.freeMode) {\\n        setTranslate();\\n        if (swiper.params.autoHeight) {\\n          swiper.updateAutoHeight();\\n        }\\n      } else {\\n        if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {\\n          translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);\\n        } else {\\n          translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\\n        }\\n        if (!translated) {\\n          setTranslate();\\n        }\\n      }\\n      if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\\n        swiper.checkOverflow();\\n      }\\n      swiper.emit('update');\\n    };\\n\\n    Swiper.prototype.init = function init () {\\n      var swiper = this;\\n      if (swiper.initialized) { return; }\\n\\n      swiper.emit('beforeInit');\\n\\n      // Set breakpoint\\n      if (swiper.params.breakpoints) {\\n        swiper.setBreakpoint();\\n      }\\n\\n      // Add Classes\\n      swiper.addClasses();\\n\\n      // Create loop\\n      if (swiper.params.loop) {\\n        swiper.loopCreate();\\n      }\\n\\n      // Update size\\n      swiper.updateSize();\\n\\n      // Update slides\\n      swiper.updateSlides();\\n\\n      if (swiper.params.watchOverflow) {\\n        swiper.checkOverflow();\\n      }\\n\\n      // Set Grab Cursor\\n      if (swiper.params.grabCursor) {\\n        swiper.setGrabCursor();\\n      }\\n\\n      if (swiper.params.preloadImages) {\\n        swiper.preloadImages();\\n      }\\n\\n      // Slide To Initial Slide\\n      if (swiper.params.loop) {\\n        swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);\\n      } else {\\n        swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);\\n      }\\n\\n      // Attach events\\n      swiper.attachEvents();\\n\\n      // Init Flag\\n      swiper.initialized = true;\\n\\n      // Emit\\n      swiper.emit('init');\\n    };\\n\\n    Swiper.prototype.destroy = function destroy (deleteInstance, cleanStyles) {\\n      if ( deleteInstance === void 0 ) deleteInstance = true;\\n      if ( cleanStyles === void 0 ) cleanStyles = true;\\n\\n      var swiper = this;\\n      var params = swiper.params;\\n      var $el = swiper.$el;\\n      var $wrapperEl = swiper.$wrapperEl;\\n      var slides = swiper.slides;\\n\\n      if (typeof swiper.params === 'undefined' || swiper.destroyed) {\\n        return null;\\n      }\\n\\n      swiper.emit('beforeDestroy');\\n\\n      // Init Flag\\n      swiper.initialized = false;\\n\\n      // Detach events\\n      swiper.detachEvents();\\n\\n      // Destroy loop\\n      if (params.loop) {\\n        swiper.loopDestroy();\\n      }\\n\\n      // Cleanup styles\\n      if (cleanStyles) {\\n        swiper.removeClasses();\\n        $el.removeAttr('style');\\n        $wrapperEl.removeAttr('style');\\n        if (slides && slides.length) {\\n          slides\\n            .removeClass([\\n              params.slideVisibleClass,\\n              params.slideActiveClass,\\n              params.slideNextClass,\\n              params.slidePrevClass ].join(' '))\\n            .removeAttr('style')\\n            .removeAttr('data-swiper-slide-index')\\n            .removeAttr('data-swiper-column')\\n            .removeAttr('data-swiper-row');\\n        }\\n      }\\n\\n      swiper.emit('destroy');\\n\\n      // Detach emitter events\\n      Object.keys(swiper.eventsListeners).forEach(function (eventName) {\\n        swiper.off(eventName);\\n      });\\n\\n      if (deleteInstance !== false) {\\n        swiper.$el[0].swiper = null;\\n        swiper.$el.data('swiper', null);\\n        Utils.deleteProps(swiper);\\n      }\\n      swiper.destroyed = true;\\n\\n      return null;\\n    };\\n\\n    Swiper.extendDefaults = function extendDefaults (newDefaults) {\\n      Utils.extend(extendedDefaults, newDefaults);\\n    };\\n\\n    staticAccessors.extendedDefaults.get = function () {\\n      return extendedDefaults;\\n    };\\n\\n    staticAccessors.defaults.get = function () {\\n      return defaults;\\n    };\\n\\n    staticAccessors.Class.get = function () {\\n      return SwiperClass$$1;\\n    };\\n\\n    staticAccessors.$.get = function () {\\n      return $;\\n    };\\n\\n    Object.defineProperties( Swiper, staticAccessors );\\n\\n    return Swiper;\\n  }(SwiperClass));\\n\\n  var Device$1 = {\\n    name: 'device',\\n    proto: {\\n      device: Device,\\n    },\\n    static: {\\n      device: Device,\\n    },\\n  };\\n\\n  var Support$1 = {\\n    name: 'support',\\n    proto: {\\n      support: Support,\\n    },\\n    static: {\\n      support: Support,\\n    },\\n  };\\n\\n  var Browser$1 = {\\n    name: 'browser',\\n    proto: {\\n      browser: Browser,\\n    },\\n    static: {\\n      browser: Browser,\\n    },\\n  };\\n\\n  var Resize = {\\n    name: 'resize',\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        resize: {\\n          resizeHandler: function resizeHandler() {\\n            if (!swiper || swiper.destroyed || !swiper.initialized) { return; }\\n            swiper.emit('beforeResize');\\n            swiper.emit('resize');\\n          },\\n          orientationChangeHandler: function orientationChangeHandler() {\\n            if (!swiper || swiper.destroyed || !swiper.initialized) { return; }\\n            swiper.emit('orientationchange');\\n          },\\n        },\\n      });\\n    },\\n    on: {\\n      init: function init() {\\n        var swiper = this;\\n        // Emit resize\\n        win.addEventListener('resize', swiper.resize.resizeHandler);\\n\\n        // Emit orientationchange\\n        win.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);\\n      },\\n      destroy: function destroy() {\\n        var swiper = this;\\n        win.removeEventListener('resize', swiper.resize.resizeHandler);\\n        win.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);\\n      },\\n    },\\n  };\\n\\n  var Observer = {\\n    func: win.MutationObserver || win.WebkitMutationObserver,\\n    attach: function attach(target, options) {\\n      if ( options === void 0 ) options = {};\\n\\n      var swiper = this;\\n\\n      var ObserverFunc = Observer.func;\\n      var observer = new ObserverFunc(function (mutations) {\\n        // The observerUpdate event should only be triggered\\n        // once despite the number of mutations.  Additional\\n        // triggers are redundant and are very costly\\n        if (mutations.length === 1) {\\n          swiper.emit('observerUpdate', mutations[0]);\\n          return;\\n        }\\n        var observerUpdate = function observerUpdate() {\\n          swiper.emit('observerUpdate', mutations[0]);\\n        };\\n\\n        if (win.requestAnimationFrame) {\\n          win.requestAnimationFrame(observerUpdate);\\n        } else {\\n          win.setTimeout(observerUpdate, 0);\\n        }\\n      });\\n\\n      observer.observe(target, {\\n        attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\\n        childList: typeof options.childList === 'undefined' ? true : options.childList,\\n        characterData: typeof options.characterData === 'undefined' ? true : options.characterData,\\n      });\\n\\n      swiper.observer.observers.push(observer);\\n    },\\n    init: function init() {\\n      var swiper = this;\\n      if (!Support.observer || !swiper.params.observer) { return; }\\n      if (swiper.params.observeParents) {\\n        var containerParents = swiper.$el.parents();\\n        for (var i = 0; i < containerParents.length; i += 1) {\\n          swiper.observer.attach(containerParents[i]);\\n        }\\n      }\\n      // Observe container\\n      swiper.observer.attach(swiper.$el[0], { childList: swiper.params.observeSlideChildren });\\n\\n      // Observe wrapper\\n      swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });\\n    },\\n    destroy: function destroy() {\\n      var swiper = this;\\n      swiper.observer.observers.forEach(function (observer) {\\n        observer.disconnect();\\n      });\\n      swiper.observer.observers = [];\\n    },\\n  };\\n\\n  var Observer$1 = {\\n    name: 'observer',\\n    params: {\\n      observer: false,\\n      observeParents: false,\\n      observeSlideChildren: false,\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        observer: {\\n          init: Observer.init.bind(swiper),\\n          attach: Observer.attach.bind(swiper),\\n          destroy: Observer.destroy.bind(swiper),\\n          observers: [],\\n        },\\n      });\\n    },\\n    on: {\\n      init: function init() {\\n        var swiper = this;\\n        swiper.observer.init();\\n      },\\n      destroy: function destroy() {\\n        var swiper = this;\\n        swiper.observer.destroy();\\n      },\\n    },\\n  };\\n\\n  var Virtual = {\\n    update: function update(force) {\\n      var swiper = this;\\n      var ref = swiper.params;\\n      var slidesPerView = ref.slidesPerView;\\n      var slidesPerGroup = ref.slidesPerGroup;\\n      var centeredSlides = ref.centeredSlides;\\n      var ref$1 = swiper.params.virtual;\\n      var addSlidesBefore = ref$1.addSlidesBefore;\\n      var addSlidesAfter = ref$1.addSlidesAfter;\\n      var ref$2 = swiper.virtual;\\n      var previousFrom = ref$2.from;\\n      var previousTo = ref$2.to;\\n      var slides = ref$2.slides;\\n      var previousSlidesGrid = ref$2.slidesGrid;\\n      var renderSlide = ref$2.renderSlide;\\n      var previousOffset = ref$2.offset;\\n      swiper.updateActiveIndex();\\n      var activeIndex = swiper.activeIndex || 0;\\n\\n      var offsetProp;\\n      if (swiper.rtlTranslate) { offsetProp = 'right'; }\\n      else { offsetProp = swiper.isHorizontal() ? 'left' : 'top'; }\\n\\n      var slidesAfter;\\n      var slidesBefore;\\n      if (centeredSlides) {\\n        slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\\n        slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\\n      } else {\\n        slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;\\n        slidesBefore = slidesPerGroup + addSlidesAfter;\\n      }\\n      var from = Math.max((activeIndex || 0) - slidesBefore, 0);\\n      var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);\\n      var offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\\n\\n      Utils.extend(swiper.virtual, {\\n        from: from,\\n        to: to,\\n        offset: offset,\\n        slidesGrid: swiper.slidesGrid,\\n      });\\n\\n      function onRendered() {\\n        swiper.updateSlides();\\n        swiper.updateProgress();\\n        swiper.updateSlidesClasses();\\n        if (swiper.lazy && swiper.params.lazy.enabled) {\\n          swiper.lazy.load();\\n        }\\n      }\\n\\n      if (previousFrom === from && previousTo === to && !force) {\\n        if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\\n          swiper.slides.css(offsetProp, (offset + \\\"px\\\"));\\n        }\\n        swiper.updateProgress();\\n        return;\\n      }\\n      if (swiper.params.virtual.renderExternal) {\\n        swiper.params.virtual.renderExternal.call(swiper, {\\n          offset: offset,\\n          from: from,\\n          to: to,\\n          slides: (function getSlides() {\\n            var slidesToRender = [];\\n            for (var i = from; i <= to; i += 1) {\\n              slidesToRender.push(slides[i]);\\n            }\\n            return slidesToRender;\\n          }()),\\n        });\\n        onRendered();\\n        return;\\n      }\\n      var prependIndexes = [];\\n      var appendIndexes = [];\\n      if (force) {\\n        swiper.$wrapperEl.find((\\\".\\\" + (swiper.params.slideClass))).remove();\\n      } else {\\n        for (var i = previousFrom; i <= previousTo; i += 1) {\\n          if (i < from || i > to) {\\n            swiper.$wrapperEl.find((\\\".\\\" + (swiper.params.slideClass) + \\\"[data-swiper-slide-index=\\\\\\\"\\\" + i + \\\"\\\\\\\"]\\\")).remove();\\n          }\\n        }\\n      }\\n      for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {\\n        if (i$1 >= from && i$1 <= to) {\\n          if (typeof previousTo === 'undefined' || force) {\\n            appendIndexes.push(i$1);\\n          } else {\\n            if (i$1 > previousTo) { appendIndexes.push(i$1); }\\n            if (i$1 < previousFrom) { prependIndexes.push(i$1); }\\n          }\\n        }\\n      }\\n      appendIndexes.forEach(function (index) {\\n        swiper.$wrapperEl.append(renderSlide(slides[index], index));\\n      });\\n      prependIndexes.sort(function (a, b) { return b - a; }).forEach(function (index) {\\n        swiper.$wrapperEl.prepend(renderSlide(slides[index], index));\\n      });\\n      swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, (offset + \\\"px\\\"));\\n      onRendered();\\n    },\\n    renderSlide: function renderSlide(slide, index) {\\n      var swiper = this;\\n      var params = swiper.params.virtual;\\n      if (params.cache && swiper.virtual.cache[index]) {\\n        return swiper.virtual.cache[index];\\n      }\\n      var $slideEl = params.renderSlide\\n        ? $(params.renderSlide.call(swiper, slide, index))\\n        : $((\\\"<div class=\\\\\\\"\\\" + (swiper.params.slideClass) + \\\"\\\\\\\" data-swiper-slide-index=\\\\\\\"\\\" + index + \\\"\\\\\\\">\\\" + slide + \\\"</div>\\\"));\\n      if (!$slideEl.attr('data-swiper-slide-index')) { $slideEl.attr('data-swiper-slide-index', index); }\\n      if (params.cache) { swiper.virtual.cache[index] = $slideEl; }\\n      return $slideEl;\\n    },\\n    appendSlide: function appendSlide(slide) {\\n      var swiper = this;\\n      swiper.virtual.slides.push(slide);\\n      swiper.virtual.update(true);\\n    },\\n    prependSlide: function prependSlide(slide) {\\n      var swiper = this;\\n      swiper.virtual.slides.unshift(slide);\\n      if (swiper.params.virtual.cache) {\\n        var cache = swiper.virtual.cache;\\n        var newCache = {};\\n        Object.keys(cache).forEach(function (cachedIndex) {\\n          newCache[cachedIndex + 1] = cache[cachedIndex];\\n        });\\n        swiper.virtual.cache = newCache;\\n      }\\n      swiper.virtual.update(true);\\n      swiper.slideNext(0);\\n    },\\n  };\\n\\n  var Virtual$1 = {\\n    name: 'virtual',\\n    params: {\\n      virtual: {\\n        enabled: false,\\n        slides: [],\\n        cache: true,\\n        renderSlide: null,\\n        renderExternal: null,\\n        addSlidesBefore: 0,\\n        addSlidesAfter: 0,\\n      },\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        virtual: {\\n          update: Virtual.update.bind(swiper),\\n          appendSlide: Virtual.appendSlide.bind(swiper),\\n          prependSlide: Virtual.prependSlide.bind(swiper),\\n          renderSlide: Virtual.renderSlide.bind(swiper),\\n          slides: swiper.params.virtual.slides,\\n          cache: {},\\n        },\\n      });\\n    },\\n    on: {\\n      beforeInit: function beforeInit() {\\n        var swiper = this;\\n        if (!swiper.params.virtual.enabled) { return; }\\n        swiper.classNames.push(((swiper.params.containerModifierClass) + \\\"virtual\\\"));\\n        var overwriteParams = {\\n          watchSlidesProgress: true,\\n        };\\n        Utils.extend(swiper.params, overwriteParams);\\n        Utils.extend(swiper.originalParams, overwriteParams);\\n\\n        if (!swiper.params.initialSlide) {\\n          swiper.virtual.update();\\n        }\\n      },\\n      setTranslate: function setTranslate() {\\n        var swiper = this;\\n        if (!swiper.params.virtual.enabled) { return; }\\n        swiper.virtual.update();\\n      },\\n    },\\n  };\\n\\n  var Keyboard = {\\n    handle: function handle(event) {\\n      var swiper = this;\\n      var rtl = swiper.rtlTranslate;\\n      var e = event;\\n      if (e.originalEvent) { e = e.originalEvent; } // jquery fix\\n      var kc = e.keyCode || e.charCode;\\n      // Directions locks\\n      if (!swiper.allowSlideNext && ((swiper.isHorizontal() && kc === 39) || (swiper.isVertical() && kc === 40))) {\\n        return false;\\n      }\\n      if (!swiper.allowSlidePrev && ((swiper.isHorizontal() && kc === 37) || (swiper.isVertical() && kc === 38))) {\\n        return false;\\n      }\\n      if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\\n        return undefined;\\n      }\\n      if (doc.activeElement && doc.activeElement.nodeName && (doc.activeElement.nodeName.toLowerCase() === 'input' || doc.activeElement.nodeName.toLowerCase() === 'textarea')) {\\n        return undefined;\\n      }\\n      if (swiper.params.keyboard.onlyInViewport && (kc === 37 || kc === 39 || kc === 38 || kc === 40)) {\\n        var inView = false;\\n        // Check that swiper should be inside of visible area of window\\n        if (swiper.$el.parents((\\\".\\\" + (swiper.params.slideClass))).length > 0 && swiper.$el.parents((\\\".\\\" + (swiper.params.slideActiveClass))).length === 0) {\\n          return undefined;\\n        }\\n        var windowWidth = win.innerWidth;\\n        var windowHeight = win.innerHeight;\\n        var swiperOffset = swiper.$el.offset();\\n        if (rtl) { swiperOffset.left -= swiper.$el[0].scrollLeft; }\\n        var swiperCoord = [\\n          [swiperOffset.left, swiperOffset.top],\\n          [swiperOffset.left + swiper.width, swiperOffset.top],\\n          [swiperOffset.left, swiperOffset.top + swiper.height],\\n          [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height] ];\\n        for (var i = 0; i < swiperCoord.length; i += 1) {\\n          var point = swiperCoord[i];\\n          if (\\n            point[0] >= 0 && point[0] <= windowWidth\\n            && point[1] >= 0 && point[1] <= windowHeight\\n          ) {\\n            inView = true;\\n          }\\n        }\\n        if (!inView) { return undefined; }\\n      }\\n      if (swiper.isHorizontal()) {\\n        if (kc === 37 || kc === 39) {\\n          if (e.preventDefault) { e.preventDefault(); }\\n          else { e.returnValue = false; }\\n        }\\n        if ((kc === 39 && !rtl) || (kc === 37 && rtl)) { swiper.slideNext(); }\\n        if ((kc === 37 && !rtl) || (kc === 39 && rtl)) { swiper.slidePrev(); }\\n      } else {\\n        if (kc === 38 || kc === 40) {\\n          if (e.preventDefault) { e.preventDefault(); }\\n          else { e.returnValue = false; }\\n        }\\n        if (kc === 40) { swiper.slideNext(); }\\n        if (kc === 38) { swiper.slidePrev(); }\\n      }\\n      swiper.emit('keyPress', kc);\\n      return undefined;\\n    },\\n    enable: function enable() {\\n      var swiper = this;\\n      if (swiper.keyboard.enabled) { return; }\\n      $(doc).on('keydown', swiper.keyboard.handle);\\n      swiper.keyboard.enabled = true;\\n    },\\n    disable: function disable() {\\n      var swiper = this;\\n      if (!swiper.keyboard.enabled) { return; }\\n      $(doc).off('keydown', swiper.keyboard.handle);\\n      swiper.keyboard.enabled = false;\\n    },\\n  };\\n\\n  var Keyboard$1 = {\\n    name: 'keyboard',\\n    params: {\\n      keyboard: {\\n        enabled: false,\\n        onlyInViewport: true,\\n      },\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        keyboard: {\\n          enabled: false,\\n          enable: Keyboard.enable.bind(swiper),\\n          disable: Keyboard.disable.bind(swiper),\\n          handle: Keyboard.handle.bind(swiper),\\n        },\\n      });\\n    },\\n    on: {\\n      init: function init() {\\n        var swiper = this;\\n        if (swiper.params.keyboard.enabled) {\\n          swiper.keyboard.enable();\\n        }\\n      },\\n      destroy: function destroy() {\\n        var swiper = this;\\n        if (swiper.keyboard.enabled) {\\n          swiper.keyboard.disable();\\n        }\\n      },\\n    },\\n  };\\n\\n  function isEventSupported() {\\n    var eventName = 'onwheel';\\n    var isSupported = eventName in doc;\\n\\n    if (!isSupported) {\\n      var element = doc.createElement('div');\\n      element.setAttribute(eventName, 'return;');\\n      isSupported = typeof element[eventName] === 'function';\\n    }\\n\\n    if (!isSupported\\n      && doc.implementation\\n      && doc.implementation.hasFeature\\n      // always returns true in newer browsers as per the standard.\\n      // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\\n      && doc.implementation.hasFeature('', '') !== true\\n    ) {\\n      // This is the only way to test support for the `wheel` event in IE9+.\\n      isSupported = doc.implementation.hasFeature('Events.wheel', '3.0');\\n    }\\n\\n    return isSupported;\\n  }\\n  var Mousewheel = {\\n    lastScrollTime: Utils.now(),\\n    event: (function getEvent() {\\n      if (win.navigator.userAgent.indexOf('firefox') > -1) { return 'DOMMouseScroll'; }\\n      return isEventSupported() ? 'wheel' : 'mousewheel';\\n    }()),\\n    normalize: function normalize(e) {\\n      // Reasonable defaults\\n      var PIXEL_STEP = 10;\\n      var LINE_HEIGHT = 40;\\n      var PAGE_HEIGHT = 800;\\n\\n      var sX = 0;\\n      var sY = 0; // spinX, spinY\\n      var pX = 0;\\n      var pY = 0; // pixelX, pixelY\\n\\n      // Legacy\\n      if ('detail' in e) {\\n        sY = e.detail;\\n      }\\n      if ('wheelDelta' in e) {\\n        sY = -e.wheelDelta / 120;\\n      }\\n      if ('wheelDeltaY' in e) {\\n        sY = -e.wheelDeltaY / 120;\\n      }\\n      if ('wheelDeltaX' in e) {\\n        sX = -e.wheelDeltaX / 120;\\n      }\\n\\n      // side scrolling on FF with DOMMouseScroll\\n      if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\\n        sX = sY;\\n        sY = 0;\\n      }\\n\\n      pX = sX * PIXEL_STEP;\\n      pY = sY * PIXEL_STEP;\\n\\n      if ('deltaY' in e) {\\n        pY = e.deltaY;\\n      }\\n      if ('deltaX' in e) {\\n        pX = e.deltaX;\\n      }\\n\\n      if ((pX || pY) && e.deltaMode) {\\n        if (e.deltaMode === 1) { // delta in LINE units\\n          pX *= LINE_HEIGHT;\\n          pY *= LINE_HEIGHT;\\n        } else { // delta in PAGE units\\n          pX *= PAGE_HEIGHT;\\n          pY *= PAGE_HEIGHT;\\n        }\\n      }\\n\\n      // Fall-back if spin cannot be determined\\n      if (pX && !sX) {\\n        sX = (pX < 1) ? -1 : 1;\\n      }\\n      if (pY && !sY) {\\n        sY = (pY < 1) ? -1 : 1;\\n      }\\n\\n      return {\\n        spinX: sX,\\n        spinY: sY,\\n        pixelX: pX,\\n        pixelY: pY,\\n      };\\n    },\\n    handleMouseEnter: function handleMouseEnter() {\\n      var swiper = this;\\n      swiper.mouseEntered = true;\\n    },\\n    handleMouseLeave: function handleMouseLeave() {\\n      var swiper = this;\\n      swiper.mouseEntered = false;\\n    },\\n    handle: function handle(event) {\\n      var e = event;\\n      var swiper = this;\\n      var params = swiper.params.mousewheel;\\n\\n      if (!swiper.mouseEntered && !params.releaseOnEdges) { return true; }\\n\\n      if (e.originalEvent) { e = e.originalEvent; } // jquery fix\\n      var delta = 0;\\n      var rtlFactor = swiper.rtlTranslate ? -1 : 1;\\n\\n      var data = Mousewheel.normalize(e);\\n\\n      if (params.forceToAxis) {\\n        if (swiper.isHorizontal()) {\\n          if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) { delta = data.pixelX * rtlFactor; }\\n          else { return true; }\\n        } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) { delta = data.pixelY; }\\n        else { return true; }\\n      } else {\\n        delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\\n      }\\n\\n      if (delta === 0) { return true; }\\n\\n      if (params.invert) { delta = -delta; }\\n\\n      if (!swiper.params.freeMode) {\\n        if (Utils.now() - swiper.mousewheel.lastScrollTime > 60) {\\n          if (delta < 0) {\\n            if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\\n              swiper.slideNext();\\n              swiper.emit('scroll', e);\\n            } else if (params.releaseOnEdges) { return true; }\\n          } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\\n            swiper.slidePrev();\\n            swiper.emit('scroll', e);\\n          } else if (params.releaseOnEdges) { return true; }\\n        }\\n        swiper.mousewheel.lastScrollTime = (new win.Date()).getTime();\\n      } else {\\n        // Freemode or scrollContainer:\\n        if (swiper.params.loop) {\\n          swiper.loopFix();\\n        }\\n        var position = swiper.getTranslate() + (delta * params.sensitivity);\\n        var wasBeginning = swiper.isBeginning;\\n        var wasEnd = swiper.isEnd;\\n\\n        if (position >= swiper.minTranslate()) { position = swiper.minTranslate(); }\\n        if (position <= swiper.maxTranslate()) { position = swiper.maxTranslate(); }\\n\\n        swiper.setTransition(0);\\n        swiper.setTranslate(position);\\n        swiper.updateProgress();\\n        swiper.updateActiveIndex();\\n        swiper.updateSlidesClasses();\\n\\n        if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {\\n          swiper.updateSlidesClasses();\\n        }\\n\\n        if (swiper.params.freeModeSticky) {\\n          clearTimeout(swiper.mousewheel.timeout);\\n          swiper.mousewheel.timeout = Utils.nextTick(function () {\\n            swiper.slideToClosest();\\n          }, 300);\\n        }\\n        // Emit event\\n        swiper.emit('scroll', e);\\n\\n        // Stop autoplay\\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) { swiper.autoplay.stop(); }\\n        // Return page scroll on edge positions\\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) { return true; }\\n      }\\n\\n      if (e.preventDefault) { e.preventDefault(); }\\n      else { e.returnValue = false; }\\n      return false;\\n    },\\n    enable: function enable() {\\n      var swiper = this;\\n      if (!Mousewheel.event) { return false; }\\n      if (swiper.mousewheel.enabled) { return false; }\\n      var target = swiper.$el;\\n      if (swiper.params.mousewheel.eventsTarged !== 'container') {\\n        target = $(swiper.params.mousewheel.eventsTarged);\\n      }\\n      target.on('mouseenter', swiper.mousewheel.handleMouseEnter);\\n      target.on('mouseleave', swiper.mousewheel.handleMouseLeave);\\n      target.on(Mousewheel.event, swiper.mousewheel.handle);\\n      swiper.mousewheel.enabled = true;\\n      return true;\\n    },\\n    disable: function disable() {\\n      var swiper = this;\\n      if (!Mousewheel.event) { return false; }\\n      if (!swiper.mousewheel.enabled) { return false; }\\n      var target = swiper.$el;\\n      if (swiper.params.mousewheel.eventsTarged !== 'container') {\\n        target = $(swiper.params.mousewheel.eventsTarged);\\n      }\\n      target.off(Mousewheel.event, swiper.mousewheel.handle);\\n      swiper.mousewheel.enabled = false;\\n      return true;\\n    },\\n  };\\n\\n  var Mousewheel$1 = {\\n    name: 'mousewheel',\\n    params: {\\n      mousewheel: {\\n        enabled: false,\\n        releaseOnEdges: false,\\n        invert: false,\\n        forceToAxis: false,\\n        sensitivity: 1,\\n        eventsTarged: 'container',\\n      },\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        mousewheel: {\\n          enabled: false,\\n          enable: Mousewheel.enable.bind(swiper),\\n          disable: Mousewheel.disable.bind(swiper),\\n          handle: Mousewheel.handle.bind(swiper),\\n          handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),\\n          handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),\\n          lastScrollTime: Utils.now(),\\n        },\\n      });\\n    },\\n    on: {\\n      init: function init() {\\n        var swiper = this;\\n        if (swiper.params.mousewheel.enabled) { swiper.mousewheel.enable(); }\\n      },\\n      destroy: function destroy() {\\n        var swiper = this;\\n        if (swiper.mousewheel.enabled) { swiper.mousewheel.disable(); }\\n      },\\n    },\\n  };\\n\\n  var Navigation = {\\n    update: function update() {\\n      // Update Navigation Buttons\\n      var swiper = this;\\n      var params = swiper.params.navigation;\\n\\n      if (swiper.params.loop) { return; }\\n      var ref = swiper.navigation;\\n      var $nextEl = ref.$nextEl;\\n      var $prevEl = ref.$prevEl;\\n\\n      if ($prevEl && $prevEl.length > 0) {\\n        if (swiper.isBeginning) {\\n          $prevEl.addClass(params.disabledClass);\\n        } else {\\n          $prevEl.removeClass(params.disabledClass);\\n        }\\n        $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\\n      }\\n      if ($nextEl && $nextEl.length > 0) {\\n        if (swiper.isEnd) {\\n          $nextEl.addClass(params.disabledClass);\\n        } else {\\n          $nextEl.removeClass(params.disabledClass);\\n        }\\n        $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\\n      }\\n    },\\n    onPrevClick: function onPrevClick(e) {\\n      var swiper = this;\\n      e.preventDefault();\\n      if (swiper.isBeginning && !swiper.params.loop) { return; }\\n      swiper.slidePrev();\\n    },\\n    onNextClick: function onNextClick(e) {\\n      var swiper = this;\\n      e.preventDefault();\\n      if (swiper.isEnd && !swiper.params.loop) { return; }\\n      swiper.slideNext();\\n    },\\n    init: function init() {\\n      var swiper = this;\\n      var params = swiper.params.navigation;\\n      if (!(params.nextEl || params.prevEl)) { return; }\\n\\n      var $nextEl;\\n      var $prevEl;\\n      if (params.nextEl) {\\n        $nextEl = $(params.nextEl);\\n        if (\\n          swiper.params.uniqueNavElements\\n          && typeof params.nextEl === 'string'\\n          && $nextEl.length > 1\\n          && swiper.$el.find(params.nextEl).length === 1\\n        ) {\\n          $nextEl = swiper.$el.find(params.nextEl);\\n        }\\n      }\\n      if (params.prevEl) {\\n        $prevEl = $(params.prevEl);\\n        if (\\n          swiper.params.uniqueNavElements\\n          && typeof params.prevEl === 'string'\\n          && $prevEl.length > 1\\n          && swiper.$el.find(params.prevEl).length === 1\\n        ) {\\n          $prevEl = swiper.$el.find(params.prevEl);\\n        }\\n      }\\n\\n      if ($nextEl && $nextEl.length > 0) {\\n        $nextEl.on('click', swiper.navigation.onNextClick);\\n      }\\n      if ($prevEl && $prevEl.length > 0) {\\n        $prevEl.on('click', swiper.navigation.onPrevClick);\\n      }\\n\\n      Utils.extend(swiper.navigation, {\\n        $nextEl: $nextEl,\\n        nextEl: $nextEl && $nextEl[0],\\n        $prevEl: $prevEl,\\n        prevEl: $prevEl && $prevEl[0],\\n      });\\n    },\\n    destroy: function destroy() {\\n      var swiper = this;\\n      var ref = swiper.navigation;\\n      var $nextEl = ref.$nextEl;\\n      var $prevEl = ref.$prevEl;\\n      if ($nextEl && $nextEl.length) {\\n        $nextEl.off('click', swiper.navigation.onNextClick);\\n        $nextEl.removeClass(swiper.params.navigation.disabledClass);\\n      }\\n      if ($prevEl && $prevEl.length) {\\n        $prevEl.off('click', swiper.navigation.onPrevClick);\\n        $prevEl.removeClass(swiper.params.navigation.disabledClass);\\n      }\\n    },\\n  };\\n\\n  var Navigation$1 = {\\n    name: 'navigation',\\n    params: {\\n      navigation: {\\n        nextEl: null,\\n        prevEl: null,\\n\\n        hideOnClick: false,\\n        disabledClass: 'swiper-button-disabled',\\n        hiddenClass: 'swiper-button-hidden',\\n        lockClass: 'swiper-button-lock',\\n      },\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        navigation: {\\n          init: Navigation.init.bind(swiper),\\n          update: Navigation.update.bind(swiper),\\n          destroy: Navigation.destroy.bind(swiper),\\n          onNextClick: Navigation.onNextClick.bind(swiper),\\n          onPrevClick: Navigation.onPrevClick.bind(swiper),\\n        },\\n      });\\n    },\\n    on: {\\n      init: function init() {\\n        var swiper = this;\\n        swiper.navigation.init();\\n        swiper.navigation.update();\\n      },\\n      toEdge: function toEdge() {\\n        var swiper = this;\\n        swiper.navigation.update();\\n      },\\n      fromEdge: function fromEdge() {\\n        var swiper = this;\\n        swiper.navigation.update();\\n      },\\n      destroy: function destroy() {\\n        var swiper = this;\\n        swiper.navigation.destroy();\\n      },\\n      click: function click(e) {\\n        var swiper = this;\\n        var ref = swiper.navigation;\\n        var $nextEl = ref.$nextEl;\\n        var $prevEl = ref.$prevEl;\\n        if (\\n          swiper.params.navigation.hideOnClick\\n          && !$(e.target).is($prevEl)\\n          && !$(e.target).is($nextEl)\\n        ) {\\n          if ($nextEl) { $nextEl.toggleClass(swiper.params.navigation.hiddenClass); }\\n          if ($prevEl) { $prevEl.toggleClass(swiper.params.navigation.hiddenClass); }\\n        }\\n      },\\n    },\\n  };\\n\\n  var Pagination = {\\n    update: function update() {\\n      // Render || Update Pagination bullets/items\\n      var swiper = this;\\n      var rtl = swiper.rtl;\\n      var params = swiper.params.pagination;\\n      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }\\n      var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\\n      var $el = swiper.pagination.$el;\\n      // Current/Total\\n      var current;\\n      var total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\\n      if (swiper.params.loop) {\\n        current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);\\n        if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {\\n          current -= (slidesLength - (swiper.loopedSlides * 2));\\n        }\\n        if (current > total - 1) { current -= total; }\\n        if (current < 0 && swiper.params.paginationType !== 'bullets') { current = total + current; }\\n      } else if (typeof swiper.snapIndex !== 'undefined') {\\n        current = swiper.snapIndex;\\n      } else {\\n        current = swiper.activeIndex || 0;\\n      }\\n      // Types\\n      if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\\n        var bullets = swiper.pagination.bullets;\\n        var firstIndex;\\n        var lastIndex;\\n        var midIndex;\\n        if (params.dynamicBullets) {\\n          swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);\\n          $el.css(swiper.isHorizontal() ? 'width' : 'height', ((swiper.pagination.bulletSize * (params.dynamicMainBullets + 4)) + \\\"px\\\"));\\n          if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {\\n            swiper.pagination.dynamicBulletIndex += (current - swiper.previousIndex);\\n            if (swiper.pagination.dynamicBulletIndex > (params.dynamicMainBullets - 1)) {\\n              swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;\\n            } else if (swiper.pagination.dynamicBulletIndex < 0) {\\n              swiper.pagination.dynamicBulletIndex = 0;\\n            }\\n          }\\n          firstIndex = current - swiper.pagination.dynamicBulletIndex;\\n          lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\\n          midIndex = (lastIndex + firstIndex) / 2;\\n        }\\n        bullets.removeClass(((params.bulletActiveClass) + \\\" \\\" + (params.bulletActiveClass) + \\\"-next \\\" + (params.bulletActiveClass) + \\\"-next-next \\\" + (params.bulletActiveClass) + \\\"-prev \\\" + (params.bulletActiveClass) + \\\"-prev-prev \\\" + (params.bulletActiveClass) + \\\"-main\\\"));\\n        if ($el.length > 1) {\\n          bullets.each(function (index, bullet) {\\n            var $bullet = $(bullet);\\n            var bulletIndex = $bullet.index();\\n            if (bulletIndex === current) {\\n              $bullet.addClass(params.bulletActiveClass);\\n            }\\n            if (params.dynamicBullets) {\\n              if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\\n                $bullet.addClass(((params.bulletActiveClass) + \\\"-main\\\"));\\n              }\\n              if (bulletIndex === firstIndex) {\\n                $bullet\\n                  .prev()\\n                  .addClass(((params.bulletActiveClass) + \\\"-prev\\\"))\\n                  .prev()\\n                  .addClass(((params.bulletActiveClass) + \\\"-prev-prev\\\"));\\n              }\\n              if (bulletIndex === lastIndex) {\\n                $bullet\\n                  .next()\\n                  .addClass(((params.bulletActiveClass) + \\\"-next\\\"))\\n                  .next()\\n                  .addClass(((params.bulletActiveClass) + \\\"-next-next\\\"));\\n              }\\n            }\\n          });\\n        } else {\\n          var $bullet = bullets.eq(current);\\n          $bullet.addClass(params.bulletActiveClass);\\n          if (params.dynamicBullets) {\\n            var $firstDisplayedBullet = bullets.eq(firstIndex);\\n            var $lastDisplayedBullet = bullets.eq(lastIndex);\\n            for (var i = firstIndex; i <= lastIndex; i += 1) {\\n              bullets.eq(i).addClass(((params.bulletActiveClass) + \\\"-main\\\"));\\n            }\\n            $firstDisplayedBullet\\n              .prev()\\n              .addClass(((params.bulletActiveClass) + \\\"-prev\\\"))\\n              .prev()\\n              .addClass(((params.bulletActiveClass) + \\\"-prev-prev\\\"));\\n            $lastDisplayedBullet\\n              .next()\\n              .addClass(((params.bulletActiveClass) + \\\"-next\\\"))\\n              .next()\\n              .addClass(((params.bulletActiveClass) + \\\"-next-next\\\"));\\n          }\\n        }\\n        if (params.dynamicBullets) {\\n          var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\\n          var bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (midIndex * swiper.pagination.bulletSize);\\n          var offsetProp = rtl ? 'right' : 'left';\\n          bullets.css(swiper.isHorizontal() ? offsetProp : 'top', (bulletsOffset + \\\"px\\\"));\\n        }\\n      }\\n      if (params.type === 'fraction') {\\n        $el.find((\\\".\\\" + (params.currentClass))).text(params.formatFractionCurrent(current + 1));\\n        $el.find((\\\".\\\" + (params.totalClass))).text(params.formatFractionTotal(total));\\n      }\\n      if (params.type === 'progressbar') {\\n        var progressbarDirection;\\n        if (params.progressbarOpposite) {\\n          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\\n        } else {\\n          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\\n        }\\n        var scale = (current + 1) / total;\\n        var scaleX = 1;\\n        var scaleY = 1;\\n        if (progressbarDirection === 'horizontal') {\\n          scaleX = scale;\\n        } else {\\n          scaleY = scale;\\n        }\\n        $el.find((\\\".\\\" + (params.progressbarFillClass))).transform((\\\"translate3d(0,0,0) scaleX(\\\" + scaleX + \\\") scaleY(\\\" + scaleY + \\\")\\\")).transition(swiper.params.speed);\\n      }\\n      if (params.type === 'custom' && params.renderCustom) {\\n        $el.html(params.renderCustom(swiper, current + 1, total));\\n        swiper.emit('paginationRender', swiper, $el[0]);\\n      } else {\\n        swiper.emit('paginationUpdate', swiper, $el[0]);\\n      }\\n      $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\\n    },\\n    render: function render() {\\n      // Render Container\\n      var swiper = this;\\n      var params = swiper.params.pagination;\\n      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }\\n      var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\\n\\n      var $el = swiper.pagination.$el;\\n      var paginationHTML = '';\\n      if (params.type === 'bullets') {\\n        var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\\n        for (var i = 0; i < numberOfBullets; i += 1) {\\n          if (params.renderBullet) {\\n            paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\\n          } else {\\n            paginationHTML += \\\"<\\\" + (params.bulletElement) + \\\" class=\\\\\\\"\\\" + (params.bulletClass) + \\\"\\\\\\\"></\\\" + (params.bulletElement) + \\\">\\\";\\n          }\\n        }\\n        $el.html(paginationHTML);\\n        swiper.pagination.bullets = $el.find((\\\".\\\" + (params.bulletClass)));\\n      }\\n      if (params.type === 'fraction') {\\n        if (params.renderFraction) {\\n          paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\\n        } else {\\n          paginationHTML = \\\"<span class=\\\\\\\"\\\" + (params.currentClass) + \\\"\\\\\\\"></span>\\\"\\n          + ' / '\\n          + \\\"<span class=\\\\\\\"\\\" + (params.totalClass) + \\\"\\\\\\\"></span>\\\";\\n        }\\n        $el.html(paginationHTML);\\n      }\\n      if (params.type === 'progressbar') {\\n        if (params.renderProgressbar) {\\n          paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\\n        } else {\\n          paginationHTML = \\\"<span class=\\\\\\\"\\\" + (params.progressbarFillClass) + \\\"\\\\\\\"></span>\\\";\\n        }\\n        $el.html(paginationHTML);\\n      }\\n      if (params.type !== 'custom') {\\n        swiper.emit('paginationRender', swiper.pagination.$el[0]);\\n      }\\n    },\\n    init: function init() {\\n      var swiper = this;\\n      var params = swiper.params.pagination;\\n      if (!params.el) { return; }\\n\\n      var $el = $(params.el);\\n      if ($el.length === 0) { return; }\\n\\n      if (\\n        swiper.params.uniqueNavElements\\n        && typeof params.el === 'string'\\n        && $el.length > 1\\n        && swiper.$el.find(params.el).length === 1\\n      ) {\\n        $el = swiper.$el.find(params.el);\\n      }\\n\\n      if (params.type === 'bullets' && params.clickable) {\\n        $el.addClass(params.clickableClass);\\n      }\\n\\n      $el.addClass(params.modifierClass + params.type);\\n\\n      if (params.type === 'bullets' && params.dynamicBullets) {\\n        $el.addClass((\\\"\\\" + (params.modifierClass) + (params.type) + \\\"-dynamic\\\"));\\n        swiper.pagination.dynamicBulletIndex = 0;\\n        if (params.dynamicMainBullets < 1) {\\n          params.dynamicMainBullets = 1;\\n        }\\n      }\\n      if (params.type === 'progressbar' && params.progressbarOpposite) {\\n        $el.addClass(params.progressbarOppositeClass);\\n      }\\n\\n      if (params.clickable) {\\n        $el.on('click', (\\\".\\\" + (params.bulletClass)), function onClick(e) {\\n          e.preventDefault();\\n          var index = $(this).index() * swiper.params.slidesPerGroup;\\n          if (swiper.params.loop) { index += swiper.loopedSlides; }\\n          swiper.slideTo(index);\\n        });\\n      }\\n\\n      Utils.extend(swiper.pagination, {\\n        $el: $el,\\n        el: $el[0],\\n      });\\n    },\\n    destroy: function destroy() {\\n      var swiper = this;\\n      var params = swiper.params.pagination;\\n      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }\\n      var $el = swiper.pagination.$el;\\n\\n      $el.removeClass(params.hiddenClass);\\n      $el.removeClass(params.modifierClass + params.type);\\n      if (swiper.pagination.bullets) { swiper.pagination.bullets.removeClass(params.bulletActiveClass); }\\n      if (params.clickable) {\\n        $el.off('click', (\\\".\\\" + (params.bulletClass)));\\n      }\\n    },\\n  };\\n\\n  var Pagination$1 = {\\n    name: 'pagination',\\n    params: {\\n      pagination: {\\n        el: null,\\n        bulletElement: 'span',\\n        clickable: false,\\n        hideOnClick: false,\\n        renderBullet: null,\\n        renderProgressbar: null,\\n        renderFraction: null,\\n        renderCustom: null,\\n        progressbarOpposite: false,\\n        type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'\\n        dynamicBullets: false,\\n        dynamicMainBullets: 1,\\n        formatFractionCurrent: function (number) { return number; },\\n        formatFractionTotal: function (number) { return number; },\\n        bulletClass: 'swiper-pagination-bullet',\\n        bulletActiveClass: 'swiper-pagination-bullet-active',\\n        modifierClass: 'swiper-pagination-', // NEW\\n        currentClass: 'swiper-pagination-current',\\n        totalClass: 'swiper-pagination-total',\\n        hiddenClass: 'swiper-pagination-hidden',\\n        progressbarFillClass: 'swiper-pagination-progressbar-fill',\\n        progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',\\n        clickableClass: 'swiper-pagination-clickable', // NEW\\n        lockClass: 'swiper-pagination-lock',\\n      },\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        pagination: {\\n          init: Pagination.init.bind(swiper),\\n          render: Pagination.render.bind(swiper),\\n          update: Pagination.update.bind(swiper),\\n          destroy: Pagination.destroy.bind(swiper),\\n          dynamicBulletIndex: 0,\\n        },\\n      });\\n    },\\n    on: {\\n      init: function init() {\\n        var swiper = this;\\n        swiper.pagination.init();\\n        swiper.pagination.render();\\n        swiper.pagination.update();\\n      },\\n      activeIndexChange: function activeIndexChange() {\\n        var swiper = this;\\n        if (swiper.params.loop) {\\n          swiper.pagination.update();\\n        } else if (typeof swiper.snapIndex === 'undefined') {\\n          swiper.pagination.update();\\n        }\\n      },\\n      snapIndexChange: function snapIndexChange() {\\n        var swiper = this;\\n        if (!swiper.params.loop) {\\n          swiper.pagination.update();\\n        }\\n      },\\n      slidesLengthChange: function slidesLengthChange() {\\n        var swiper = this;\\n        if (swiper.params.loop) {\\n          swiper.pagination.render();\\n          swiper.pagination.update();\\n        }\\n      },\\n      snapGridLengthChange: function snapGridLengthChange() {\\n        var swiper = this;\\n        if (!swiper.params.loop) {\\n          swiper.pagination.render();\\n          swiper.pagination.update();\\n        }\\n      },\\n      destroy: function destroy() {\\n        var swiper = this;\\n        swiper.pagination.destroy();\\n      },\\n      click: function click(e) {\\n        var swiper = this;\\n        if (\\n          swiper.params.pagination.el\\n          && swiper.params.pagination.hideOnClick\\n          && swiper.pagination.$el.length > 0\\n          && !$(e.target).hasClass(swiper.params.pagination.bulletClass)\\n        ) {\\n          swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);\\n        }\\n      },\\n    },\\n  };\\n\\n  var Scrollbar = {\\n    setTranslate: function setTranslate() {\\n      var swiper = this;\\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }\\n      var scrollbar = swiper.scrollbar;\\n      var rtl = swiper.rtlTranslate;\\n      var progress = swiper.progress;\\n      var dragSize = scrollbar.dragSize;\\n      var trackSize = scrollbar.trackSize;\\n      var $dragEl = scrollbar.$dragEl;\\n      var $el = scrollbar.$el;\\n      var params = swiper.params.scrollbar;\\n\\n      var newSize = dragSize;\\n      var newPos = (trackSize - dragSize) * progress;\\n      if (rtl) {\\n        newPos = -newPos;\\n        if (newPos > 0) {\\n          newSize = dragSize - newPos;\\n          newPos = 0;\\n        } else if (-newPos + dragSize > trackSize) {\\n          newSize = trackSize + newPos;\\n        }\\n      } else if (newPos < 0) {\\n        newSize = dragSize + newPos;\\n        newPos = 0;\\n      } else if (newPos + dragSize > trackSize) {\\n        newSize = trackSize - newPos;\\n      }\\n      if (swiper.isHorizontal()) {\\n        if (Support.transforms3d) {\\n          $dragEl.transform((\\\"translate3d(\\\" + newPos + \\\"px, 0, 0)\\\"));\\n        } else {\\n          $dragEl.transform((\\\"translateX(\\\" + newPos + \\\"px)\\\"));\\n        }\\n        $dragEl[0].style.width = newSize + \\\"px\\\";\\n      } else {\\n        if (Support.transforms3d) {\\n          $dragEl.transform((\\\"translate3d(0px, \\\" + newPos + \\\"px, 0)\\\"));\\n        } else {\\n          $dragEl.transform((\\\"translateY(\\\" + newPos + \\\"px)\\\"));\\n        }\\n        $dragEl[0].style.height = newSize + \\\"px\\\";\\n      }\\n      if (params.hide) {\\n        clearTimeout(swiper.scrollbar.timeout);\\n        $el[0].style.opacity = 1;\\n        swiper.scrollbar.timeout = setTimeout(function () {\\n          $el[0].style.opacity = 0;\\n          $el.transition(400);\\n        }, 1000);\\n      }\\n    },\\n    setTransition: function setTransition(duration) {\\n      var swiper = this;\\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }\\n      swiper.scrollbar.$dragEl.transition(duration);\\n    },\\n    updateSize: function updateSize() {\\n      var swiper = this;\\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }\\n\\n      var scrollbar = swiper.scrollbar;\\n      var $dragEl = scrollbar.$dragEl;\\n      var $el = scrollbar.$el;\\n\\n      $dragEl[0].style.width = '';\\n      $dragEl[0].style.height = '';\\n      var trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;\\n\\n      var divider = swiper.size / swiper.virtualSize;\\n      var moveDivider = divider * (trackSize / swiper.size);\\n      var dragSize;\\n      if (swiper.params.scrollbar.dragSize === 'auto') {\\n        dragSize = trackSize * divider;\\n      } else {\\n        dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\\n      }\\n\\n      if (swiper.isHorizontal()) {\\n        $dragEl[0].style.width = dragSize + \\\"px\\\";\\n      } else {\\n        $dragEl[0].style.height = dragSize + \\\"px\\\";\\n      }\\n\\n      if (divider >= 1) {\\n        $el[0].style.display = 'none';\\n      } else {\\n        $el[0].style.display = '';\\n      }\\n      if (swiper.params.scrollbarHide) {\\n        $el[0].style.opacity = 0;\\n      }\\n      Utils.extend(scrollbar, {\\n        trackSize: trackSize,\\n        divider: divider,\\n        moveDivider: moveDivider,\\n        dragSize: dragSize,\\n      });\\n      scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);\\n    },\\n    setDragPosition: function setDragPosition(e) {\\n      var swiper = this;\\n      var scrollbar = swiper.scrollbar;\\n      var rtl = swiper.rtlTranslate;\\n      var $el = scrollbar.$el;\\n      var dragSize = scrollbar.dragSize;\\n      var trackSize = scrollbar.trackSize;\\n\\n      var pointerPosition;\\n      if (swiper.isHorizontal()) {\\n        pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX);\\n      } else {\\n        pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY);\\n      }\\n      var positionRatio;\\n      positionRatio = ((pointerPosition) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragSize / 2)) / (trackSize - dragSize);\\n      positionRatio = Math.max(Math.min(positionRatio, 1), 0);\\n      if (rtl) {\\n        positionRatio = 1 - positionRatio;\\n      }\\n\\n      var position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);\\n\\n      swiper.updateProgress(position);\\n      swiper.setTranslate(position);\\n      swiper.updateActiveIndex();\\n      swiper.updateSlidesClasses();\\n    },\\n    onDragStart: function onDragStart(e) {\\n      var swiper = this;\\n      var params = swiper.params.scrollbar;\\n      var scrollbar = swiper.scrollbar;\\n      var $wrapperEl = swiper.$wrapperEl;\\n      var $el = scrollbar.$el;\\n      var $dragEl = scrollbar.$dragEl;\\n      swiper.scrollbar.isTouched = true;\\n      e.preventDefault();\\n      e.stopPropagation();\\n\\n      $wrapperEl.transition(100);\\n      $dragEl.transition(100);\\n      scrollbar.setDragPosition(e);\\n\\n      clearTimeout(swiper.scrollbar.dragTimeout);\\n\\n      $el.transition(0);\\n      if (params.hide) {\\n        $el.css('opacity', 1);\\n      }\\n      swiper.emit('scrollbarDragStart', e);\\n    },\\n    onDragMove: function onDragMove(e) {\\n      var swiper = this;\\n      var scrollbar = swiper.scrollbar;\\n      var $wrapperEl = swiper.$wrapperEl;\\n      var $el = scrollbar.$el;\\n      var $dragEl = scrollbar.$dragEl;\\n\\n      if (!swiper.scrollbar.isTouched) { return; }\\n      if (e.preventDefault) { e.preventDefault(); }\\n      else { e.returnValue = false; }\\n      scrollbar.setDragPosition(e);\\n      $wrapperEl.transition(0);\\n      $el.transition(0);\\n      $dragEl.transition(0);\\n      swiper.emit('scrollbarDragMove', e);\\n    },\\n    onDragEnd: function onDragEnd(e) {\\n      var swiper = this;\\n\\n      var params = swiper.params.scrollbar;\\n      var scrollbar = swiper.scrollbar;\\n      var $el = scrollbar.$el;\\n\\n      if (!swiper.scrollbar.isTouched) { return; }\\n      swiper.scrollbar.isTouched = false;\\n      if (params.hide) {\\n        clearTimeout(swiper.scrollbar.dragTimeout);\\n        swiper.scrollbar.dragTimeout = Utils.nextTick(function () {\\n          $el.css('opacity', 0);\\n          $el.transition(400);\\n        }, 1000);\\n      }\\n      swiper.emit('scrollbarDragEnd', e);\\n      if (params.snapOnRelease) {\\n        swiper.slideToClosest();\\n      }\\n    },\\n    enableDraggable: function enableDraggable() {\\n      var swiper = this;\\n      if (!swiper.params.scrollbar.el) { return; }\\n      var scrollbar = swiper.scrollbar;\\n      var touchEventsTouch = swiper.touchEventsTouch;\\n      var touchEventsDesktop = swiper.touchEventsDesktop;\\n      var params = swiper.params;\\n      var $el = scrollbar.$el;\\n      var target = $el[0];\\n      var activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;\\n      var passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;\\n      if (!Support.touch) {\\n        target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);\\n        doc.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);\\n        doc.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);\\n      } else {\\n        target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);\\n        target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);\\n        target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);\\n      }\\n    },\\n    disableDraggable: function disableDraggable() {\\n      var swiper = this;\\n      if (!swiper.params.scrollbar.el) { return; }\\n      var scrollbar = swiper.scrollbar;\\n      var touchEventsTouch = swiper.touchEventsTouch;\\n      var touchEventsDesktop = swiper.touchEventsDesktop;\\n      var params = swiper.params;\\n      var $el = scrollbar.$el;\\n      var target = $el[0];\\n      var activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;\\n      var passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;\\n      if (!Support.touch) {\\n        target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);\\n        doc.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);\\n        doc.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);\\n      } else {\\n        target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);\\n        target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);\\n        target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);\\n      }\\n    },\\n    init: function init() {\\n      var swiper = this;\\n      if (!swiper.params.scrollbar.el) { return; }\\n      var scrollbar = swiper.scrollbar;\\n      var $swiperEl = swiper.$el;\\n      var params = swiper.params.scrollbar;\\n\\n      var $el = $(params.el);\\n      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {\\n        $el = $swiperEl.find(params.el);\\n      }\\n\\n      var $dragEl = $el.find((\\\".\\\" + (swiper.params.scrollbar.dragClass)));\\n      if ($dragEl.length === 0) {\\n        $dragEl = $((\\\"<div class=\\\\\\\"\\\" + (swiper.params.scrollbar.dragClass) + \\\"\\\\\\\"></div>\\\"));\\n        $el.append($dragEl);\\n      }\\n\\n      Utils.extend(scrollbar, {\\n        $el: $el,\\n        el: $el[0],\\n        $dragEl: $dragEl,\\n        dragEl: $dragEl[0],\\n      });\\n\\n      if (params.draggable) {\\n        scrollbar.enableDraggable();\\n      }\\n    },\\n    destroy: function destroy() {\\n      var swiper = this;\\n      swiper.scrollbar.disableDraggable();\\n    },\\n  };\\n\\n  var Scrollbar$1 = {\\n    name: 'scrollbar',\\n    params: {\\n      scrollbar: {\\n        el: null,\\n        dragSize: 'auto',\\n        hide: false,\\n        draggable: false,\\n        snapOnRelease: true,\\n        lockClass: 'swiper-scrollbar-lock',\\n        dragClass: 'swiper-scrollbar-drag',\\n      },\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        scrollbar: {\\n          init: Scrollbar.init.bind(swiper),\\n          destroy: Scrollbar.destroy.bind(swiper),\\n          updateSize: Scrollbar.updateSize.bind(swiper),\\n          setTranslate: Scrollbar.setTranslate.bind(swiper),\\n          setTransition: Scrollbar.setTransition.bind(swiper),\\n          enableDraggable: Scrollbar.enableDraggable.bind(swiper),\\n          disableDraggable: Scrollbar.disableDraggable.bind(swiper),\\n          setDragPosition: Scrollbar.setDragPosition.bind(swiper),\\n          onDragStart: Scrollbar.onDragStart.bind(swiper),\\n          onDragMove: Scrollbar.onDragMove.bind(swiper),\\n          onDragEnd: Scrollbar.onDragEnd.bind(swiper),\\n          isTouched: false,\\n          timeout: null,\\n          dragTimeout: null,\\n        },\\n      });\\n    },\\n    on: {\\n      init: function init() {\\n        var swiper = this;\\n        swiper.scrollbar.init();\\n        swiper.scrollbar.updateSize();\\n        swiper.scrollbar.setTranslate();\\n      },\\n      update: function update() {\\n        var swiper = this;\\n        swiper.scrollbar.updateSize();\\n      },\\n      resize: function resize() {\\n        var swiper = this;\\n        swiper.scrollbar.updateSize();\\n      },\\n      observerUpdate: function observerUpdate() {\\n        var swiper = this;\\n        swiper.scrollbar.updateSize();\\n      },\\n      setTranslate: function setTranslate() {\\n        var swiper = this;\\n        swiper.scrollbar.setTranslate();\\n      },\\n      setTransition: function setTransition(duration) {\\n        var swiper = this;\\n        swiper.scrollbar.setTransition(duration);\\n      },\\n      destroy: function destroy() {\\n        var swiper = this;\\n        swiper.scrollbar.destroy();\\n      },\\n    },\\n  };\\n\\n  var Parallax = {\\n    setTransform: function setTransform(el, progress) {\\n      var swiper = this;\\n      var rtl = swiper.rtl;\\n\\n      var $el = $(el);\\n      var rtlFactor = rtl ? -1 : 1;\\n\\n      var p = $el.attr('data-swiper-parallax') || '0';\\n      var x = $el.attr('data-swiper-parallax-x');\\n      var y = $el.attr('data-swiper-parallax-y');\\n      var scale = $el.attr('data-swiper-parallax-scale');\\n      var opacity = $el.attr('data-swiper-parallax-opacity');\\n\\n      if (x || y) {\\n        x = x || '0';\\n        y = y || '0';\\n      } else if (swiper.isHorizontal()) {\\n        x = p;\\n        y = '0';\\n      } else {\\n        y = p;\\n        x = '0';\\n      }\\n\\n      if ((x).indexOf('%') >= 0) {\\n        x = (parseInt(x, 10) * progress * rtlFactor) + \\\"%\\\";\\n      } else {\\n        x = (x * progress * rtlFactor) + \\\"px\\\";\\n      }\\n      if ((y).indexOf('%') >= 0) {\\n        y = (parseInt(y, 10) * progress) + \\\"%\\\";\\n      } else {\\n        y = (y * progress) + \\\"px\\\";\\n      }\\n\\n      if (typeof opacity !== 'undefined' && opacity !== null) {\\n        var currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));\\n        $el[0].style.opacity = currentOpacity;\\n      }\\n      if (typeof scale === 'undefined' || scale === null) {\\n        $el.transform((\\\"translate3d(\\\" + x + \\\", \\\" + y + \\\", 0px)\\\"));\\n      } else {\\n        var currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));\\n        $el.transform((\\\"translate3d(\\\" + x + \\\", \\\" + y + \\\", 0px) scale(\\\" + currentScale + \\\")\\\"));\\n      }\\n    },\\n    setTranslate: function setTranslate() {\\n      var swiper = this;\\n      var $el = swiper.$el;\\n      var slides = swiper.slides;\\n      var progress = swiper.progress;\\n      var snapGrid = swiper.snapGrid;\\n      $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')\\n        .each(function (index, el) {\\n          swiper.parallax.setTransform(el, progress);\\n        });\\n      slides.each(function (slideIndex, slideEl) {\\n        var slideProgress = slideEl.progress;\\n        if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\\n          slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));\\n        }\\n        slideProgress = Math.min(Math.max(slideProgress, -1), 1);\\n        $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')\\n          .each(function (index, el) {\\n            swiper.parallax.setTransform(el, slideProgress);\\n          });\\n      });\\n    },\\n    setTransition: function setTransition(duration) {\\n      if ( duration === void 0 ) duration = this.params.speed;\\n\\n      var swiper = this;\\n      var $el = swiper.$el;\\n      $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')\\n        .each(function (index, parallaxEl) {\\n          var $parallaxEl = $(parallaxEl);\\n          var parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;\\n          if (duration === 0) { parallaxDuration = 0; }\\n          $parallaxEl.transition(parallaxDuration);\\n        });\\n    },\\n  };\\n\\n  var Parallax$1 = {\\n    name: 'parallax',\\n    params: {\\n      parallax: {\\n        enabled: false,\\n      },\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        parallax: {\\n          setTransform: Parallax.setTransform.bind(swiper),\\n          setTranslate: Parallax.setTranslate.bind(swiper),\\n          setTransition: Parallax.setTransition.bind(swiper),\\n        },\\n      });\\n    },\\n    on: {\\n      beforeInit: function beforeInit() {\\n        var swiper = this;\\n        if (!swiper.params.parallax.enabled) { return; }\\n        swiper.params.watchSlidesProgress = true;\\n        swiper.originalParams.watchSlidesProgress = true;\\n      },\\n      init: function init() {\\n        var swiper = this;\\n        if (!swiper.params.parallax) { return; }\\n        swiper.parallax.setTranslate();\\n      },\\n      setTranslate: function setTranslate() {\\n        var swiper = this;\\n        if (!swiper.params.parallax) { return; }\\n        swiper.parallax.setTranslate();\\n      },\\n      setTransition: function setTransition(duration) {\\n        var swiper = this;\\n        if (!swiper.params.parallax) { return; }\\n        swiper.parallax.setTransition(duration);\\n      },\\n    },\\n  };\\n\\n  var Zoom = {\\n    // Calc Scale From Multi-touches\\n    getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {\\n      if (e.targetTouches.length < 2) { return 1; }\\n      var x1 = e.targetTouches[0].pageX;\\n      var y1 = e.targetTouches[0].pageY;\\n      var x2 = e.targetTouches[1].pageX;\\n      var y2 = e.targetTouches[1].pageY;\\n      var distance = Math.sqrt((Math.pow( (x2 - x1), 2 )) + (Math.pow( (y2 - y1), 2 )));\\n      return distance;\\n    },\\n    // Events\\n    onGestureStart: function onGestureStart(e) {\\n      var swiper = this;\\n      var params = swiper.params.zoom;\\n      var zoom = swiper.zoom;\\n      var gesture = zoom.gesture;\\n      zoom.fakeGestureTouched = false;\\n      zoom.fakeGestureMoved = false;\\n      if (!Support.gestures) {\\n        if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {\\n          return;\\n        }\\n        zoom.fakeGestureTouched = true;\\n        gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);\\n      }\\n      if (!gesture.$slideEl || !gesture.$slideEl.length) {\\n        gesture.$slideEl = $(e.target).closest('.swiper-slide');\\n        if (gesture.$slideEl.length === 0) { gesture.$slideEl = swiper.slides.eq(swiper.activeIndex); }\\n        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');\\n        gesture.$imageWrapEl = gesture.$imageEl.parent((\\\".\\\" + (params.containerClass)));\\n        gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\\n        if (gesture.$imageWrapEl.length === 0) {\\n          gesture.$imageEl = undefined;\\n          return;\\n        }\\n      }\\n      gesture.$imageEl.transition(0);\\n      swiper.zoom.isScaling = true;\\n    },\\n    onGestureChange: function onGestureChange(e) {\\n      var swiper = this;\\n      var params = swiper.params.zoom;\\n      var zoom = swiper.zoom;\\n      var gesture = zoom.gesture;\\n      if (!Support.gestures) {\\n        if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {\\n          return;\\n        }\\n        zoom.fakeGestureMoved = true;\\n        gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);\\n      }\\n      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }\\n      if (Support.gestures) {\\n        zoom.scale = e.scale * zoom.currentScale;\\n      } else {\\n        zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;\\n      }\\n      if (zoom.scale > gesture.maxRatio) {\\n        zoom.scale = (gesture.maxRatio - 1) + (Math.pow( ((zoom.scale - gesture.maxRatio) + 1), 0.5 ));\\n      }\\n      if (zoom.scale < params.minRatio) {\\n        zoom.scale = (params.minRatio + 1) - (Math.pow( ((params.minRatio - zoom.scale) + 1), 0.5 ));\\n      }\\n      gesture.$imageEl.transform((\\\"translate3d(0,0,0) scale(\\\" + (zoom.scale) + \\\")\\\"));\\n    },\\n    onGestureEnd: function onGestureEnd(e) {\\n      var swiper = this;\\n      var params = swiper.params.zoom;\\n      var zoom = swiper.zoom;\\n      var gesture = zoom.gesture;\\n      if (!Support.gestures) {\\n        if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {\\n          return;\\n        }\\n        if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {\\n          return;\\n        }\\n        zoom.fakeGestureTouched = false;\\n        zoom.fakeGestureMoved = false;\\n      }\\n      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }\\n      zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\\n      gesture.$imageEl.transition(swiper.params.speed).transform((\\\"translate3d(0,0,0) scale(\\\" + (zoom.scale) + \\\")\\\"));\\n      zoom.currentScale = zoom.scale;\\n      zoom.isScaling = false;\\n      if (zoom.scale === 1) { gesture.$slideEl = undefined; }\\n    },\\n    onTouchStart: function onTouchStart(e) {\\n      var swiper = this;\\n      var zoom = swiper.zoom;\\n      var gesture = zoom.gesture;\\n      var image = zoom.image;\\n      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }\\n      if (image.isTouched) { return; }\\n      if (Device.android) { e.preventDefault(); }\\n      image.isTouched = true;\\n      image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;\\n      image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;\\n    },\\n    onTouchMove: function onTouchMove(e) {\\n      var swiper = this;\\n      var zoom = swiper.zoom;\\n      var gesture = zoom.gesture;\\n      var image = zoom.image;\\n      var velocity = zoom.velocity;\\n      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }\\n      swiper.allowClick = false;\\n      if (!image.isTouched || !gesture.$slideEl) { return; }\\n\\n      if (!image.isMoved) {\\n        image.width = gesture.$imageEl[0].offsetWidth;\\n        image.height = gesture.$imageEl[0].offsetHeight;\\n        image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;\\n        image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;\\n        gesture.slideWidth = gesture.$slideEl[0].offsetWidth;\\n        gesture.slideHeight = gesture.$slideEl[0].offsetHeight;\\n        gesture.$imageWrapEl.transition(0);\\n        if (swiper.rtl) {\\n          image.startX = -image.startX;\\n          image.startY = -image.startY;\\n        }\\n      }\\n      // Define if we need image drag\\n      var scaledWidth = image.width * zoom.scale;\\n      var scaledHeight = image.height * zoom.scale;\\n\\n      if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) { return; }\\n\\n      image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);\\n      image.maxX = -image.minX;\\n      image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);\\n      image.maxY = -image.minY;\\n\\n      image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;\\n      image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;\\n\\n      if (!image.isMoved && !zoom.isScaling) {\\n        if (\\n          swiper.isHorizontal()\\n          && (\\n            (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x)\\n            || (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)\\n          )\\n        ) {\\n          image.isTouched = false;\\n          return;\\n        } if (\\n          !swiper.isHorizontal()\\n          && (\\n            (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y)\\n            || (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)\\n          )\\n        ) {\\n          image.isTouched = false;\\n          return;\\n        }\\n      }\\n      e.preventDefault();\\n      e.stopPropagation();\\n\\n      image.isMoved = true;\\n      image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;\\n      image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;\\n\\n      if (image.currentX < image.minX) {\\n        image.currentX = (image.minX + 1) - (Math.pow( ((image.minX - image.currentX) + 1), 0.8 ));\\n      }\\n      if (image.currentX > image.maxX) {\\n        image.currentX = (image.maxX - 1) + (Math.pow( ((image.currentX - image.maxX) + 1), 0.8 ));\\n      }\\n\\n      if (image.currentY < image.minY) {\\n        image.currentY = (image.minY + 1) - (Math.pow( ((image.minY - image.currentY) + 1), 0.8 ));\\n      }\\n      if (image.currentY > image.maxY) {\\n        image.currentY = (image.maxY - 1) + (Math.pow( ((image.currentY - image.maxY) + 1), 0.8 ));\\n      }\\n\\n      // Velocity\\n      if (!velocity.prevPositionX) { velocity.prevPositionX = image.touchesCurrent.x; }\\n      if (!velocity.prevPositionY) { velocity.prevPositionY = image.touchesCurrent.y; }\\n      if (!velocity.prevTime) { velocity.prevTime = Date.now(); }\\n      velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\\n      velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\\n      if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) { velocity.x = 0; }\\n      if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) { velocity.y = 0; }\\n      velocity.prevPositionX = image.touchesCurrent.x;\\n      velocity.prevPositionY = image.touchesCurrent.y;\\n      velocity.prevTime = Date.now();\\n\\n      gesture.$imageWrapEl.transform((\\\"translate3d(\\\" + (image.currentX) + \\\"px, \\\" + (image.currentY) + \\\"px,0)\\\"));\\n    },\\n    onTouchEnd: function onTouchEnd() {\\n      var swiper = this;\\n      var zoom = swiper.zoom;\\n      var gesture = zoom.gesture;\\n      var image = zoom.image;\\n      var velocity = zoom.velocity;\\n      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }\\n      if (!image.isTouched || !image.isMoved) {\\n        image.isTouched = false;\\n        image.isMoved = false;\\n        return;\\n      }\\n      image.isTouched = false;\\n      image.isMoved = false;\\n      var momentumDurationX = 300;\\n      var momentumDurationY = 300;\\n      var momentumDistanceX = velocity.x * momentumDurationX;\\n      var newPositionX = image.currentX + momentumDistanceX;\\n      var momentumDistanceY = velocity.y * momentumDurationY;\\n      var newPositionY = image.currentY + momentumDistanceY;\\n\\n      // Fix duration\\n      if (velocity.x !== 0) { momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x); }\\n      if (velocity.y !== 0) { momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y); }\\n      var momentumDuration = Math.max(momentumDurationX, momentumDurationY);\\n\\n      image.currentX = newPositionX;\\n      image.currentY = newPositionY;\\n\\n      // Define if we need image drag\\n      var scaledWidth = image.width * zoom.scale;\\n      var scaledHeight = image.height * zoom.scale;\\n      image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);\\n      image.maxX = -image.minX;\\n      image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);\\n      image.maxY = -image.minY;\\n      image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\\n      image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\\n\\n      gesture.$imageWrapEl.transition(momentumDuration).transform((\\\"translate3d(\\\" + (image.currentX) + \\\"px, \\\" + (image.currentY) + \\\"px,0)\\\"));\\n    },\\n    onTransitionEnd: function onTransitionEnd() {\\n      var swiper = this;\\n      var zoom = swiper.zoom;\\n      var gesture = zoom.gesture;\\n      if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {\\n        gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');\\n        gesture.$imageWrapEl.transform('translate3d(0,0,0)');\\n\\n        zoom.scale = 1;\\n        zoom.currentScale = 1;\\n\\n        gesture.$slideEl = undefined;\\n        gesture.$imageEl = undefined;\\n        gesture.$imageWrapEl = undefined;\\n      }\\n    },\\n    // Toggle Zoom\\n    toggle: function toggle(e) {\\n      var swiper = this;\\n      var zoom = swiper.zoom;\\n\\n      if (zoom.scale && zoom.scale !== 1) {\\n        // Zoom Out\\n        zoom.out();\\n      } else {\\n        // Zoom In\\n        zoom.in(e);\\n      }\\n    },\\n    in: function in$1(e) {\\n      var swiper = this;\\n\\n      var zoom = swiper.zoom;\\n      var params = swiper.params.zoom;\\n      var gesture = zoom.gesture;\\n      var image = zoom.image;\\n\\n      if (!gesture.$slideEl) {\\n        gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);\\n        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');\\n        gesture.$imageWrapEl = gesture.$imageEl.parent((\\\".\\\" + (params.containerClass)));\\n      }\\n      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }\\n\\n      gesture.$slideEl.addClass((\\\"\\\" + (params.zoomedSlideClass)));\\n\\n      var touchX;\\n      var touchY;\\n      var offsetX;\\n      var offsetY;\\n      var diffX;\\n      var diffY;\\n      var translateX;\\n      var translateY;\\n      var imageWidth;\\n      var imageHeight;\\n      var scaledWidth;\\n      var scaledHeight;\\n      var translateMinX;\\n      var translateMinY;\\n      var translateMaxX;\\n      var translateMaxY;\\n      var slideWidth;\\n      var slideHeight;\\n\\n      if (typeof image.touchesStart.x === 'undefined' && e) {\\n        touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;\\n        touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;\\n      } else {\\n        touchX = image.touchesStart.x;\\n        touchY = image.touchesStart.y;\\n      }\\n\\n      zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\\n      zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\\n      if (e) {\\n        slideWidth = gesture.$slideEl[0].offsetWidth;\\n        slideHeight = gesture.$slideEl[0].offsetHeight;\\n        offsetX = gesture.$slideEl.offset().left;\\n        offsetY = gesture.$slideEl.offset().top;\\n        diffX = (offsetX + (slideWidth / 2)) - touchX;\\n        diffY = (offsetY + (slideHeight / 2)) - touchY;\\n\\n        imageWidth = gesture.$imageEl[0].offsetWidth;\\n        imageHeight = gesture.$imageEl[0].offsetHeight;\\n        scaledWidth = imageWidth * zoom.scale;\\n        scaledHeight = imageHeight * zoom.scale;\\n\\n        translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);\\n        translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);\\n        translateMaxX = -translateMinX;\\n        translateMaxY = -translateMinY;\\n\\n        translateX = diffX * zoom.scale;\\n        translateY = diffY * zoom.scale;\\n\\n        if (translateX < translateMinX) {\\n          translateX = translateMinX;\\n        }\\n        if (translateX > translateMaxX) {\\n          translateX = translateMaxX;\\n        }\\n\\n        if (translateY < translateMinY) {\\n          translateY = translateMinY;\\n        }\\n        if (translateY > translateMaxY) {\\n          translateY = translateMaxY;\\n        }\\n      } else {\\n        translateX = 0;\\n        translateY = 0;\\n      }\\n      gesture.$imageWrapEl.transition(300).transform((\\\"translate3d(\\\" + translateX + \\\"px, \\\" + translateY + \\\"px,0)\\\"));\\n      gesture.$imageEl.transition(300).transform((\\\"translate3d(0,0,0) scale(\\\" + (zoom.scale) + \\\")\\\"));\\n    },\\n    out: function out() {\\n      var swiper = this;\\n\\n      var zoom = swiper.zoom;\\n      var params = swiper.params.zoom;\\n      var gesture = zoom.gesture;\\n\\n      if (!gesture.$slideEl) {\\n        gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);\\n        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');\\n        gesture.$imageWrapEl = gesture.$imageEl.parent((\\\".\\\" + (params.containerClass)));\\n      }\\n      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }\\n\\n      zoom.scale = 1;\\n      zoom.currentScale = 1;\\n      gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');\\n      gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');\\n      gesture.$slideEl.removeClass((\\\"\\\" + (params.zoomedSlideClass)));\\n      gesture.$slideEl = undefined;\\n    },\\n    // Attach/Detach Events\\n    enable: function enable() {\\n      var swiper = this;\\n      var zoom = swiper.zoom;\\n      if (zoom.enabled) { return; }\\n      zoom.enabled = true;\\n\\n      var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;\\n\\n      // Scale image\\n      if (Support.gestures) {\\n        swiper.$wrapperEl.on('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);\\n        swiper.$wrapperEl.on('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);\\n        swiper.$wrapperEl.on('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);\\n      } else if (swiper.touchEvents.start === 'touchstart') {\\n        swiper.$wrapperEl.on(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);\\n        swiper.$wrapperEl.on(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);\\n        swiper.$wrapperEl.on(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);\\n      }\\n\\n      // Move image\\n      swiper.$wrapperEl.on(swiper.touchEvents.move, (\\\".\\\" + (swiper.params.zoom.containerClass)), zoom.onTouchMove);\\n    },\\n    disable: function disable() {\\n      var swiper = this;\\n      var zoom = swiper.zoom;\\n      if (!zoom.enabled) { return; }\\n\\n      swiper.zoom.enabled = false;\\n\\n      var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;\\n\\n      // Scale image\\n      if (Support.gestures) {\\n        swiper.$wrapperEl.off('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);\\n        swiper.$wrapperEl.off('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);\\n        swiper.$wrapperEl.off('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);\\n      } else if (swiper.touchEvents.start === 'touchstart') {\\n        swiper.$wrapperEl.off(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);\\n        swiper.$wrapperEl.off(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);\\n        swiper.$wrapperEl.off(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);\\n      }\\n\\n      // Move image\\n      swiper.$wrapperEl.off(swiper.touchEvents.move, (\\\".\\\" + (swiper.params.zoom.containerClass)), zoom.onTouchMove);\\n    },\\n  };\\n\\n  var Zoom$1 = {\\n    name: 'zoom',\\n    params: {\\n      zoom: {\\n        enabled: false,\\n        maxRatio: 3,\\n        minRatio: 1,\\n        toggle: true,\\n        containerClass: 'swiper-zoom-container',\\n        zoomedSlideClass: 'swiper-slide-zoomed',\\n      },\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      var zoom = {\\n        enabled: false,\\n        scale: 1,\\n        currentScale: 1,\\n        isScaling: false,\\n        gesture: {\\n          $slideEl: undefined,\\n          slideWidth: undefined,\\n          slideHeight: undefined,\\n          $imageEl: undefined,\\n          $imageWrapEl: undefined,\\n          maxRatio: 3,\\n        },\\n        image: {\\n          isTouched: undefined,\\n          isMoved: undefined,\\n          currentX: undefined,\\n          currentY: undefined,\\n          minX: undefined,\\n          minY: undefined,\\n          maxX: undefined,\\n          maxY: undefined,\\n          width: undefined,\\n          height: undefined,\\n          startX: undefined,\\n          startY: undefined,\\n          touchesStart: {},\\n          touchesCurrent: {},\\n        },\\n        velocity: {\\n          x: undefined,\\n          y: undefined,\\n          prevPositionX: undefined,\\n          prevPositionY: undefined,\\n          prevTime: undefined,\\n        },\\n      };\\n\\n      ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach(function (methodName) {\\n        zoom[methodName] = Zoom[methodName].bind(swiper);\\n      });\\n      Utils.extend(swiper, {\\n        zoom: zoom,\\n      });\\n\\n      var scale = 1;\\n      Object.defineProperty(swiper.zoom, 'scale', {\\n        get: function get() {\\n          return scale;\\n        },\\n        set: function set(value) {\\n          if (scale !== value) {\\n            var imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;\\n            var slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;\\n            swiper.emit('zoomChange', value, imageEl, slideEl);\\n          }\\n          scale = value;\\n        },\\n      });\\n    },\\n    on: {\\n      init: function init() {\\n        var swiper = this;\\n        if (swiper.params.zoom.enabled) {\\n          swiper.zoom.enable();\\n        }\\n      },\\n      destroy: function destroy() {\\n        var swiper = this;\\n        swiper.zoom.disable();\\n      },\\n      touchStart: function touchStart(e) {\\n        var swiper = this;\\n        if (!swiper.zoom.enabled) { return; }\\n        swiper.zoom.onTouchStart(e);\\n      },\\n      touchEnd: function touchEnd(e) {\\n        var swiper = this;\\n        if (!swiper.zoom.enabled) { return; }\\n        swiper.zoom.onTouchEnd(e);\\n      },\\n      doubleTap: function doubleTap(e) {\\n        var swiper = this;\\n        if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\\n          swiper.zoom.toggle(e);\\n        }\\n      },\\n      transitionEnd: function transitionEnd() {\\n        var swiper = this;\\n        if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\\n          swiper.zoom.onTransitionEnd();\\n        }\\n      },\\n    },\\n  };\\n\\n  var Lazy = {\\n    loadInSlide: function loadInSlide(index, loadInDuplicate) {\\n      if ( loadInDuplicate === void 0 ) loadInDuplicate = true;\\n\\n      var swiper = this;\\n      var params = swiper.params.lazy;\\n      if (typeof index === 'undefined') { return; }\\n      if (swiper.slides.length === 0) { return; }\\n      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;\\n\\n      var $slideEl = isVirtual\\n        ? swiper.$wrapperEl.children((\\\".\\\" + (swiper.params.slideClass) + \\\"[data-swiper-slide-index=\\\\\\\"\\\" + index + \\\"\\\\\\\"]\\\"))\\n        : swiper.slides.eq(index);\\n\\n      var $images = $slideEl.find((\\\".\\\" + (params.elementClass) + \\\":not(.\\\" + (params.loadedClass) + \\\"):not(.\\\" + (params.loadingClass) + \\\")\\\"));\\n      if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {\\n        $images = $images.add($slideEl[0]);\\n      }\\n      if ($images.length === 0) { return; }\\n\\n      $images.each(function (imageIndex, imageEl) {\\n        var $imageEl = $(imageEl);\\n        $imageEl.addClass(params.loadingClass);\\n\\n        var background = $imageEl.attr('data-background');\\n        var src = $imageEl.attr('data-src');\\n        var srcset = $imageEl.attr('data-srcset');\\n        var sizes = $imageEl.attr('data-sizes');\\n\\n        swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, function () {\\n          if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) { return; }\\n          if (background) {\\n            $imageEl.css('background-image', (\\\"url(\\\\\\\"\\\" + background + \\\"\\\\\\\")\\\"));\\n            $imageEl.removeAttr('data-background');\\n          } else {\\n            if (srcset) {\\n              $imageEl.attr('srcset', srcset);\\n              $imageEl.removeAttr('data-srcset');\\n            }\\n            if (sizes) {\\n              $imageEl.attr('sizes', sizes);\\n              $imageEl.removeAttr('data-sizes');\\n            }\\n            if (src) {\\n              $imageEl.attr('src', src);\\n              $imageEl.removeAttr('data-src');\\n            }\\n          }\\n\\n          $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);\\n          $slideEl.find((\\\".\\\" + (params.preloaderClass))).remove();\\n          if (swiper.params.loop && loadInDuplicate) {\\n            var slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');\\n            if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {\\n              var originalSlide = swiper.$wrapperEl.children((\\\"[data-swiper-slide-index=\\\\\\\"\\\" + slideOriginalIndex + \\\"\\\\\\\"]:not(.\\\" + (swiper.params.slideDuplicateClass) + \\\")\\\"));\\n              swiper.lazy.loadInSlide(originalSlide.index(), false);\\n            } else {\\n              var duplicatedSlide = swiper.$wrapperEl.children((\\\".\\\" + (swiper.params.slideDuplicateClass) + \\\"[data-swiper-slide-index=\\\\\\\"\\\" + slideOriginalIndex + \\\"\\\\\\\"]\\\"));\\n              swiper.lazy.loadInSlide(duplicatedSlide.index(), false);\\n            }\\n          }\\n          swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);\\n        });\\n\\n        swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);\\n      });\\n    },\\n    load: function load() {\\n      var swiper = this;\\n      var $wrapperEl = swiper.$wrapperEl;\\n      var swiperParams = swiper.params;\\n      var slides = swiper.slides;\\n      var activeIndex = swiper.activeIndex;\\n      var isVirtual = swiper.virtual && swiperParams.virtual.enabled;\\n      var params = swiperParams.lazy;\\n\\n      var slidesPerView = swiperParams.slidesPerView;\\n      if (slidesPerView === 'auto') {\\n        slidesPerView = 0;\\n      }\\n\\n      function slideExist(index) {\\n        if (isVirtual) {\\n          if ($wrapperEl.children((\\\".\\\" + (swiperParams.slideClass) + \\\"[data-swiper-slide-index=\\\\\\\"\\\" + index + \\\"\\\\\\\"]\\\")).length) {\\n            return true;\\n          }\\n        } else if (slides[index]) { return true; }\\n        return false;\\n      }\\n      function slideIndex(slideEl) {\\n        if (isVirtual) {\\n          return $(slideEl).attr('data-swiper-slide-index');\\n        }\\n        return $(slideEl).index();\\n      }\\n\\n      if (!swiper.lazy.initialImageLoaded) { swiper.lazy.initialImageLoaded = true; }\\n      if (swiper.params.watchSlidesVisibility) {\\n        $wrapperEl.children((\\\".\\\" + (swiperParams.slideVisibleClass))).each(function (elIndex, slideEl) {\\n          var index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();\\n          swiper.lazy.loadInSlide(index);\\n        });\\n      } else if (slidesPerView > 1) {\\n        for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {\\n          if (slideExist(i)) { swiper.lazy.loadInSlide(i); }\\n        }\\n      } else {\\n        swiper.lazy.loadInSlide(activeIndex);\\n      }\\n      if (params.loadPrevNext) {\\n        if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {\\n          var amount = params.loadPrevNextAmount;\\n          var spv = slidesPerView;\\n          var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);\\n          var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);\\n          // Next Slides\\n          for (var i$1 = activeIndex + slidesPerView; i$1 < maxIndex; i$1 += 1) {\\n            if (slideExist(i$1)) { swiper.lazy.loadInSlide(i$1); }\\n          }\\n          // Prev Slides\\n          for (var i$2 = minIndex; i$2 < activeIndex; i$2 += 1) {\\n            if (slideExist(i$2)) { swiper.lazy.loadInSlide(i$2); }\\n          }\\n        } else {\\n          var nextSlide = $wrapperEl.children((\\\".\\\" + (swiperParams.slideNextClass)));\\n          if (nextSlide.length > 0) { swiper.lazy.loadInSlide(slideIndex(nextSlide)); }\\n\\n          var prevSlide = $wrapperEl.children((\\\".\\\" + (swiperParams.slidePrevClass)));\\n          if (prevSlide.length > 0) { swiper.lazy.loadInSlide(slideIndex(prevSlide)); }\\n        }\\n      }\\n    },\\n  };\\n\\n  var Lazy$1 = {\\n    name: 'lazy',\\n    params: {\\n      lazy: {\\n        enabled: false,\\n        loadPrevNext: false,\\n        loadPrevNextAmount: 1,\\n        loadOnTransitionStart: false,\\n\\n        elementClass: 'swiper-lazy',\\n        loadingClass: 'swiper-lazy-loading',\\n        loadedClass: 'swiper-lazy-loaded',\\n        preloaderClass: 'swiper-lazy-preloader',\\n      },\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        lazy: {\\n          initialImageLoaded: false,\\n          load: Lazy.load.bind(swiper),\\n          loadInSlide: Lazy.loadInSlide.bind(swiper),\\n        },\\n      });\\n    },\\n    on: {\\n      beforeInit: function beforeInit() {\\n        var swiper = this;\\n        if (swiper.params.lazy.enabled && swiper.params.preloadImages) {\\n          swiper.params.preloadImages = false;\\n        }\\n      },\\n      init: function init() {\\n        var swiper = this;\\n        if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {\\n          swiper.lazy.load();\\n        }\\n      },\\n      scroll: function scroll() {\\n        var swiper = this;\\n        if (swiper.params.freeMode && !swiper.params.freeModeSticky) {\\n          swiper.lazy.load();\\n        }\\n      },\\n      resize: function resize() {\\n        var swiper = this;\\n        if (swiper.params.lazy.enabled) {\\n          swiper.lazy.load();\\n        }\\n      },\\n      scrollbarDragMove: function scrollbarDragMove() {\\n        var swiper = this;\\n        if (swiper.params.lazy.enabled) {\\n          swiper.lazy.load();\\n        }\\n      },\\n      transitionStart: function transitionStart() {\\n        var swiper = this;\\n        if (swiper.params.lazy.enabled) {\\n          if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {\\n            swiper.lazy.load();\\n          }\\n        }\\n      },\\n      transitionEnd: function transitionEnd() {\\n        var swiper = this;\\n        if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {\\n          swiper.lazy.load();\\n        }\\n      },\\n    },\\n  };\\n\\n  /* eslint no-bitwise: [\\\"error\\\", { \\\"allow\\\": [\\\">>\\\"] }] */\\n\\n  var Controller = {\\n    LinearSpline: function LinearSpline(x, y) {\\n      var binarySearch = (function search() {\\n        var maxIndex;\\n        var minIndex;\\n        var guess;\\n        return function (array, val) {\\n          minIndex = -1;\\n          maxIndex = array.length;\\n          while (maxIndex - minIndex > 1) {\\n            guess = maxIndex + minIndex >> 1;\\n            if (array[guess] <= val) {\\n              minIndex = guess;\\n            } else {\\n              maxIndex = guess;\\n            }\\n          }\\n          return maxIndex;\\n        };\\n      }());\\n      this.x = x;\\n      this.y = y;\\n      this.lastIndex = x.length - 1;\\n      // Given an x value (x2), return the expected y2 value:\\n      // (x1,y1) is the known point before given value,\\n      // (x3,y3) is the known point after given value.\\n      var i1;\\n      var i3;\\n\\n      this.interpolate = function interpolate(x2) {\\n        if (!x2) { return 0; }\\n\\n        // Get the indexes of x1 and x3 (the array indexes before and after given x2):\\n        i3 = binarySearch(this.x, x2);\\n        i1 = i3 - 1;\\n\\n        // We have our indexes i1 & i3, so we can calculate already:\\n        // y2 := ((x2x1)  (y3y1))  (x3x1) + y1\\n        return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];\\n      };\\n      return this;\\n    },\\n    // xxx: for now i will just save one spline function to to\\n    getInterpolateFunction: function getInterpolateFunction(c) {\\n      var swiper = this;\\n      if (!swiper.controller.spline) {\\n        swiper.controller.spline = swiper.params.loop\\n          ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid)\\n          : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);\\n      }\\n    },\\n    setTranslate: function setTranslate(setTranslate$1, byController) {\\n      var swiper = this;\\n      var controlled = swiper.controller.control;\\n      var multiplier;\\n      var controlledTranslate;\\n      function setControlledTranslate(c) {\\n        // this will create an Interpolate function based on the snapGrids\\n        // x is the Grid of the scrolled scroller and y will be the controlled scroller\\n        // it makes sense to create this only once and recall it for the interpolation\\n        // the function does a lot of value caching for performance\\n        var translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\\n        if (swiper.params.controller.by === 'slide') {\\n          swiper.controller.getInterpolateFunction(c);\\n          // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\\n          // but it did not work out\\n          controlledTranslate = -swiper.controller.spline.interpolate(-translate);\\n        }\\n\\n        if (!controlledTranslate || swiper.params.controller.by === 'container') {\\n          multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\\n          controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();\\n        }\\n\\n        if (swiper.params.controller.inverse) {\\n          controlledTranslate = c.maxTranslate() - controlledTranslate;\\n        }\\n        c.updateProgress(controlledTranslate);\\n        c.setTranslate(controlledTranslate, swiper);\\n        c.updateActiveIndex();\\n        c.updateSlidesClasses();\\n      }\\n      if (Array.isArray(controlled)) {\\n        for (var i = 0; i < controlled.length; i += 1) {\\n          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\\n            setControlledTranslate(controlled[i]);\\n          }\\n        }\\n      } else if (controlled instanceof Swiper && byController !== controlled) {\\n        setControlledTranslate(controlled);\\n      }\\n    },\\n    setTransition: function setTransition(duration, byController) {\\n      var swiper = this;\\n      var controlled = swiper.controller.control;\\n      var i;\\n      function setControlledTransition(c) {\\n        c.setTransition(duration, swiper);\\n        if (duration !== 0) {\\n          c.transitionStart();\\n          if (c.params.autoHeight) {\\n            Utils.nextTick(function () {\\n              c.updateAutoHeight();\\n            });\\n          }\\n          c.$wrapperEl.transitionEnd(function () {\\n            if (!controlled) { return; }\\n            if (c.params.loop && swiper.params.controller.by === 'slide') {\\n              c.loopFix();\\n            }\\n            c.transitionEnd();\\n          });\\n        }\\n      }\\n      if (Array.isArray(controlled)) {\\n        for (i = 0; i < controlled.length; i += 1) {\\n          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\\n            setControlledTransition(controlled[i]);\\n          }\\n        }\\n      } else if (controlled instanceof Swiper && byController !== controlled) {\\n        setControlledTransition(controlled);\\n      }\\n    },\\n  };\\n  var Controller$1 = {\\n    name: 'controller',\\n    params: {\\n      controller: {\\n        control: undefined,\\n        inverse: false,\\n        by: 'slide', // or 'container'\\n      },\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        controller: {\\n          control: swiper.params.controller.control,\\n          getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),\\n          setTranslate: Controller.setTranslate.bind(swiper),\\n          setTransition: Controller.setTransition.bind(swiper),\\n        },\\n      });\\n    },\\n    on: {\\n      update: function update() {\\n        var swiper = this;\\n        if (!swiper.controller.control) { return; }\\n        if (swiper.controller.spline) {\\n          swiper.controller.spline = undefined;\\n          delete swiper.controller.spline;\\n        }\\n      },\\n      resize: function resize() {\\n        var swiper = this;\\n        if (!swiper.controller.control) { return; }\\n        if (swiper.controller.spline) {\\n          swiper.controller.spline = undefined;\\n          delete swiper.controller.spline;\\n        }\\n      },\\n      observerUpdate: function observerUpdate() {\\n        var swiper = this;\\n        if (!swiper.controller.control) { return; }\\n        if (swiper.controller.spline) {\\n          swiper.controller.spline = undefined;\\n          delete swiper.controller.spline;\\n        }\\n      },\\n      setTranslate: function setTranslate(translate, byController) {\\n        var swiper = this;\\n        if (!swiper.controller.control) { return; }\\n        swiper.controller.setTranslate(translate, byController);\\n      },\\n      setTransition: function setTransition(duration, byController) {\\n        var swiper = this;\\n        if (!swiper.controller.control) { return; }\\n        swiper.controller.setTransition(duration, byController);\\n      },\\n    },\\n  };\\n\\n  var a11y = {\\n    makeElFocusable: function makeElFocusable($el) {\\n      $el.attr('tabIndex', '0');\\n      return $el;\\n    },\\n    addElRole: function addElRole($el, role) {\\n      $el.attr('role', role);\\n      return $el;\\n    },\\n    addElLabel: function addElLabel($el, label) {\\n      $el.attr('aria-label', label);\\n      return $el;\\n    },\\n    disableEl: function disableEl($el) {\\n      $el.attr('aria-disabled', true);\\n      return $el;\\n    },\\n    enableEl: function enableEl($el) {\\n      $el.attr('aria-disabled', false);\\n      return $el;\\n    },\\n    onEnterKey: function onEnterKey(e) {\\n      var swiper = this;\\n      var params = swiper.params.a11y;\\n      if (e.keyCode !== 13) { return; }\\n      var $targetEl = $(e.target);\\n      if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {\\n        if (!(swiper.isEnd && !swiper.params.loop)) {\\n          swiper.slideNext();\\n        }\\n        if (swiper.isEnd) {\\n          swiper.a11y.notify(params.lastSlideMessage);\\n        } else {\\n          swiper.a11y.notify(params.nextSlideMessage);\\n        }\\n      }\\n      if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {\\n        if (!(swiper.isBeginning && !swiper.params.loop)) {\\n          swiper.slidePrev();\\n        }\\n        if (swiper.isBeginning) {\\n          swiper.a11y.notify(params.firstSlideMessage);\\n        } else {\\n          swiper.a11y.notify(params.prevSlideMessage);\\n        }\\n      }\\n      if (swiper.pagination && $targetEl.is((\\\".\\\" + (swiper.params.pagination.bulletClass)))) {\\n        $targetEl[0].click();\\n      }\\n    },\\n    notify: function notify(message) {\\n      var swiper = this;\\n      var notification = swiper.a11y.liveRegion;\\n      if (notification.length === 0) { return; }\\n      notification.html('');\\n      notification.html(message);\\n    },\\n    updateNavigation: function updateNavigation() {\\n      var swiper = this;\\n\\n      if (swiper.params.loop) { return; }\\n      var ref = swiper.navigation;\\n      var $nextEl = ref.$nextEl;\\n      var $prevEl = ref.$prevEl;\\n\\n      if ($prevEl && $prevEl.length > 0) {\\n        if (swiper.isBeginning) {\\n          swiper.a11y.disableEl($prevEl);\\n        } else {\\n          swiper.a11y.enableEl($prevEl);\\n        }\\n      }\\n      if ($nextEl && $nextEl.length > 0) {\\n        if (swiper.isEnd) {\\n          swiper.a11y.disableEl($nextEl);\\n        } else {\\n          swiper.a11y.enableEl($nextEl);\\n        }\\n      }\\n    },\\n    updatePagination: function updatePagination() {\\n      var swiper = this;\\n      var params = swiper.params.a11y;\\n      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {\\n        swiper.pagination.bullets.each(function (bulletIndex, bulletEl) {\\n          var $bulletEl = $(bulletEl);\\n          swiper.a11y.makeElFocusable($bulletEl);\\n          swiper.a11y.addElRole($bulletEl, 'button');\\n          swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));\\n        });\\n      }\\n    },\\n    init: function init() {\\n      var swiper = this;\\n\\n      swiper.$el.append(swiper.a11y.liveRegion);\\n\\n      // Navigation\\n      var params = swiper.params.a11y;\\n      var $nextEl;\\n      var $prevEl;\\n      if (swiper.navigation && swiper.navigation.$nextEl) {\\n        $nextEl = swiper.navigation.$nextEl;\\n      }\\n      if (swiper.navigation && swiper.navigation.$prevEl) {\\n        $prevEl = swiper.navigation.$prevEl;\\n      }\\n      if ($nextEl) {\\n        swiper.a11y.makeElFocusable($nextEl);\\n        swiper.a11y.addElRole($nextEl, 'button');\\n        swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);\\n        $nextEl.on('keydown', swiper.a11y.onEnterKey);\\n      }\\n      if ($prevEl) {\\n        swiper.a11y.makeElFocusable($prevEl);\\n        swiper.a11y.addElRole($prevEl, 'button');\\n        swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);\\n        $prevEl.on('keydown', swiper.a11y.onEnterKey);\\n      }\\n\\n      // Pagination\\n      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {\\n        swiper.pagination.$el.on('keydown', (\\\".\\\" + (swiper.params.pagination.bulletClass)), swiper.a11y.onEnterKey);\\n      }\\n    },\\n    destroy: function destroy() {\\n      var swiper = this;\\n      if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) { swiper.a11y.liveRegion.remove(); }\\n\\n      var $nextEl;\\n      var $prevEl;\\n      if (swiper.navigation && swiper.navigation.$nextEl) {\\n        $nextEl = swiper.navigation.$nextEl;\\n      }\\n      if (swiper.navigation && swiper.navigation.$prevEl) {\\n        $prevEl = swiper.navigation.$prevEl;\\n      }\\n      if ($nextEl) {\\n        $nextEl.off('keydown', swiper.a11y.onEnterKey);\\n      }\\n      if ($prevEl) {\\n        $prevEl.off('keydown', swiper.a11y.onEnterKey);\\n      }\\n\\n      // Pagination\\n      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {\\n        swiper.pagination.$el.off('keydown', (\\\".\\\" + (swiper.params.pagination.bulletClass)), swiper.a11y.onEnterKey);\\n      }\\n    },\\n  };\\n  var A11y = {\\n    name: 'a11y',\\n    params: {\\n      a11y: {\\n        enabled: true,\\n        notificationClass: 'swiper-notification',\\n        prevSlideMessage: 'Previous slide',\\n        nextSlideMessage: 'Next slide',\\n        firstSlideMessage: 'This is the first slide',\\n        lastSlideMessage: 'This is the last slide',\\n        paginationBulletMessage: 'Go to slide {{index}}',\\n      },\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        a11y: {\\n          liveRegion: $((\\\"<span class=\\\\\\\"\\\" + (swiper.params.a11y.notificationClass) + \\\"\\\\\\\" aria-live=\\\\\\\"assertive\\\\\\\" aria-atomic=\\\\\\\"true\\\\\\\"></span>\\\")),\\n        },\\n      });\\n      Object.keys(a11y).forEach(function (methodName) {\\n        swiper.a11y[methodName] = a11y[methodName].bind(swiper);\\n      });\\n    },\\n    on: {\\n      init: function init() {\\n        var swiper = this;\\n        if (!swiper.params.a11y.enabled) { return; }\\n        swiper.a11y.init();\\n        swiper.a11y.updateNavigation();\\n      },\\n      toEdge: function toEdge() {\\n        var swiper = this;\\n        if (!swiper.params.a11y.enabled) { return; }\\n        swiper.a11y.updateNavigation();\\n      },\\n      fromEdge: function fromEdge() {\\n        var swiper = this;\\n        if (!swiper.params.a11y.enabled) { return; }\\n        swiper.a11y.updateNavigation();\\n      },\\n      paginationUpdate: function paginationUpdate() {\\n        var swiper = this;\\n        if (!swiper.params.a11y.enabled) { return; }\\n        swiper.a11y.updatePagination();\\n      },\\n      destroy: function destroy() {\\n        var swiper = this;\\n        if (!swiper.params.a11y.enabled) { return; }\\n        swiper.a11y.destroy();\\n      },\\n    },\\n  };\\n\\n  var History = {\\n    init: function init() {\\n      var swiper = this;\\n      if (!swiper.params.history) { return; }\\n      if (!win.history || !win.history.pushState) {\\n        swiper.params.history.enabled = false;\\n        swiper.params.hashNavigation.enabled = true;\\n        return;\\n      }\\n      var history = swiper.history;\\n      history.initialized = true;\\n      history.paths = History.getPathValues();\\n      if (!history.paths.key && !history.paths.value) { return; }\\n      history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);\\n      if (!swiper.params.history.replaceState) {\\n        win.addEventListener('popstate', swiper.history.setHistoryPopState);\\n      }\\n    },\\n    destroy: function destroy() {\\n      var swiper = this;\\n      if (!swiper.params.history.replaceState) {\\n        win.removeEventListener('popstate', swiper.history.setHistoryPopState);\\n      }\\n    },\\n    setHistoryPopState: function setHistoryPopState() {\\n      var swiper = this;\\n      swiper.history.paths = History.getPathValues();\\n      swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);\\n    },\\n    getPathValues: function getPathValues() {\\n      var pathArray = win.location.pathname.slice(1).split('/').filter(function (part) { return part !== ''; });\\n      var total = pathArray.length;\\n      var key = pathArray[total - 2];\\n      var value = pathArray[total - 1];\\n      return { key: key, value: value };\\n    },\\n    setHistory: function setHistory(key, index) {\\n      var swiper = this;\\n      if (!swiper.history.initialized || !swiper.params.history.enabled) { return; }\\n      var slide = swiper.slides.eq(index);\\n      var value = History.slugify(slide.attr('data-history'));\\n      if (!win.location.pathname.includes(key)) {\\n        value = key + \\\"/\\\" + value;\\n      }\\n      var currentState = win.history.state;\\n      if (currentState && currentState.value === value) {\\n        return;\\n      }\\n      if (swiper.params.history.replaceState) {\\n        win.history.replaceState({ value: value }, null, value);\\n      } else {\\n        win.history.pushState({ value: value }, null, value);\\n      }\\n    },\\n    slugify: function slugify(text) {\\n      return text.toString().toLowerCase()\\n        .replace(/\\\\s+/g, '-')\\n        .replace(/[^\\\\w-]+/g, '')\\n        .replace(/--+/g, '-')\\n        .replace(/^-+/, '')\\n        .replace(/-+$/, '');\\n    },\\n    scrollToSlide: function scrollToSlide(speed, value, runCallbacks) {\\n      var swiper = this;\\n      if (value) {\\n        for (var i = 0, length = swiper.slides.length; i < length; i += 1) {\\n          var slide = swiper.slides.eq(i);\\n          var slideHistory = History.slugify(slide.attr('data-history'));\\n          if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {\\n            var index = slide.index();\\n            swiper.slideTo(index, speed, runCallbacks);\\n          }\\n        }\\n      } else {\\n        swiper.slideTo(0, speed, runCallbacks);\\n      }\\n    },\\n  };\\n\\n  var History$1 = {\\n    name: 'history',\\n    params: {\\n      history: {\\n        enabled: false,\\n        replaceState: false,\\n        key: 'slides',\\n      },\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        history: {\\n          init: History.init.bind(swiper),\\n          setHistory: History.setHistory.bind(swiper),\\n          setHistoryPopState: History.setHistoryPopState.bind(swiper),\\n          scrollToSlide: History.scrollToSlide.bind(swiper),\\n          destroy: History.destroy.bind(swiper),\\n        },\\n      });\\n    },\\n    on: {\\n      init: function init() {\\n        var swiper = this;\\n        if (swiper.params.history.enabled) {\\n          swiper.history.init();\\n        }\\n      },\\n      destroy: function destroy() {\\n        var swiper = this;\\n        if (swiper.params.history.enabled) {\\n          swiper.history.destroy();\\n        }\\n      },\\n      transitionEnd: function transitionEnd() {\\n        var swiper = this;\\n        if (swiper.history.initialized) {\\n          swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);\\n        }\\n      },\\n    },\\n  };\\n\\n  var HashNavigation = {\\n    onHashCange: function onHashCange() {\\n      var swiper = this;\\n      var newHash = doc.location.hash.replace('#', '');\\n      var activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');\\n      if (newHash !== activeSlideHash) {\\n        var newIndex = swiper.$wrapperEl.children((\\\".\\\" + (swiper.params.slideClass) + \\\"[data-hash=\\\\\\\"\\\" + newHash + \\\"\\\\\\\"]\\\")).index();\\n        if (typeof newIndex === 'undefined') { return; }\\n        swiper.slideTo(newIndex);\\n      }\\n    },\\n    setHash: function setHash() {\\n      var swiper = this;\\n      if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) { return; }\\n      if (swiper.params.hashNavigation.replaceState && win.history && win.history.replaceState) {\\n        win.history.replaceState(null, null, ((\\\"#\\\" + (swiper.slides.eq(swiper.activeIndex).attr('data-hash'))) || false));\\n      } else {\\n        var slide = swiper.slides.eq(swiper.activeIndex);\\n        var hash = slide.attr('data-hash') || slide.attr('data-history');\\n        doc.location.hash = hash || '';\\n      }\\n    },\\n    init: function init() {\\n      var swiper = this;\\n      if (!swiper.params.hashNavigation.enabled || (swiper.params.history && swiper.params.history.enabled)) { return; }\\n      swiper.hashNavigation.initialized = true;\\n      var hash = doc.location.hash.replace('#', '');\\n      if (hash) {\\n        var speed = 0;\\n        for (var i = 0, length = swiper.slides.length; i < length; i += 1) {\\n          var slide = swiper.slides.eq(i);\\n          var slideHash = slide.attr('data-hash') || slide.attr('data-history');\\n          if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {\\n            var index = slide.index();\\n            swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);\\n          }\\n        }\\n      }\\n      if (swiper.params.hashNavigation.watchState) {\\n        $(win).on('hashchange', swiper.hashNavigation.onHashCange);\\n      }\\n    },\\n    destroy: function destroy() {\\n      var swiper = this;\\n      if (swiper.params.hashNavigation.watchState) {\\n        $(win).off('hashchange', swiper.hashNavigation.onHashCange);\\n      }\\n    },\\n  };\\n  var HashNavigation$1 = {\\n    name: 'hash-navigation',\\n    params: {\\n      hashNavigation: {\\n        enabled: false,\\n        replaceState: false,\\n        watchState: false,\\n      },\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        hashNavigation: {\\n          initialized: false,\\n          init: HashNavigation.init.bind(swiper),\\n          destroy: HashNavigation.destroy.bind(swiper),\\n          setHash: HashNavigation.setHash.bind(swiper),\\n          onHashCange: HashNavigation.onHashCange.bind(swiper),\\n        },\\n      });\\n    },\\n    on: {\\n      init: function init() {\\n        var swiper = this;\\n        if (swiper.params.hashNavigation.enabled) {\\n          swiper.hashNavigation.init();\\n        }\\n      },\\n      destroy: function destroy() {\\n        var swiper = this;\\n        if (swiper.params.hashNavigation.enabled) {\\n          swiper.hashNavigation.destroy();\\n        }\\n      },\\n      transitionEnd: function transitionEnd() {\\n        var swiper = this;\\n        if (swiper.hashNavigation.initialized) {\\n          swiper.hashNavigation.setHash();\\n        }\\n      },\\n    },\\n  };\\n\\n  /* eslint no-underscore-dangle: \\\"off\\\" */\\n\\n  var Autoplay = {\\n    run: function run() {\\n      var swiper = this;\\n      var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);\\n      var delay = swiper.params.autoplay.delay;\\n      if ($activeSlideEl.attr('data-swiper-autoplay')) {\\n        delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;\\n      }\\n      swiper.autoplay.timeout = Utils.nextTick(function () {\\n        if (swiper.params.autoplay.reverseDirection) {\\n          if (swiper.params.loop) {\\n            swiper.loopFix();\\n            swiper.slidePrev(swiper.params.speed, true, true);\\n            swiper.emit('autoplay');\\n          } else if (!swiper.isBeginning) {\\n            swiper.slidePrev(swiper.params.speed, true, true);\\n            swiper.emit('autoplay');\\n          } else if (!swiper.params.autoplay.stopOnLastSlide) {\\n            swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);\\n            swiper.emit('autoplay');\\n          } else {\\n            swiper.autoplay.stop();\\n          }\\n        } else if (swiper.params.loop) {\\n          swiper.loopFix();\\n          swiper.slideNext(swiper.params.speed, true, true);\\n          swiper.emit('autoplay');\\n        } else if (!swiper.isEnd) {\\n          swiper.slideNext(swiper.params.speed, true, true);\\n          swiper.emit('autoplay');\\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\\n          swiper.slideTo(0, swiper.params.speed, true, true);\\n          swiper.emit('autoplay');\\n        } else {\\n          swiper.autoplay.stop();\\n        }\\n      }, delay);\\n    },\\n    start: function start() {\\n      var swiper = this;\\n      if (typeof swiper.autoplay.timeout !== 'undefined') { return false; }\\n      if (swiper.autoplay.running) { return false; }\\n      swiper.autoplay.running = true;\\n      swiper.emit('autoplayStart');\\n      swiper.autoplay.run();\\n      return true;\\n    },\\n    stop: function stop() {\\n      var swiper = this;\\n      if (!swiper.autoplay.running) { return false; }\\n      if (typeof swiper.autoplay.timeout === 'undefined') { return false; }\\n\\n      if (swiper.autoplay.timeout) {\\n        clearTimeout(swiper.autoplay.timeout);\\n        swiper.autoplay.timeout = undefined;\\n      }\\n      swiper.autoplay.running = false;\\n      swiper.emit('autoplayStop');\\n      return true;\\n    },\\n    pause: function pause(speed) {\\n      var swiper = this;\\n      if (!swiper.autoplay.running) { return; }\\n      if (swiper.autoplay.paused) { return; }\\n      if (swiper.autoplay.timeout) { clearTimeout(swiper.autoplay.timeout); }\\n      swiper.autoplay.paused = true;\\n      if (speed === 0 || !swiper.params.autoplay.waitForTransition) {\\n        swiper.autoplay.paused = false;\\n        swiper.autoplay.run();\\n      } else {\\n        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);\\n        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);\\n      }\\n    },\\n  };\\n\\n  var Autoplay$1 = {\\n    name: 'autoplay',\\n    params: {\\n      autoplay: {\\n        enabled: false,\\n        delay: 3000,\\n        waitForTransition: true,\\n        disableOnInteraction: true,\\n        stopOnLastSlide: false,\\n        reverseDirection: false,\\n      },\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        autoplay: {\\n          running: false,\\n          paused: false,\\n          run: Autoplay.run.bind(swiper),\\n          start: Autoplay.start.bind(swiper),\\n          stop: Autoplay.stop.bind(swiper),\\n          pause: Autoplay.pause.bind(swiper),\\n          onTransitionEnd: function onTransitionEnd(e) {\\n            if (!swiper || swiper.destroyed || !swiper.$wrapperEl) { return; }\\n            if (e.target !== this) { return; }\\n            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);\\n            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);\\n            swiper.autoplay.paused = false;\\n            if (!swiper.autoplay.running) {\\n              swiper.autoplay.stop();\\n            } else {\\n              swiper.autoplay.run();\\n            }\\n          },\\n        },\\n      });\\n    },\\n    on: {\\n      init: function init() {\\n        var swiper = this;\\n        if (swiper.params.autoplay.enabled) {\\n          swiper.autoplay.start();\\n        }\\n      },\\n      beforeTransitionStart: function beforeTransitionStart(speed, internal) {\\n        var swiper = this;\\n        if (swiper.autoplay.running) {\\n          if (internal || !swiper.params.autoplay.disableOnInteraction) {\\n            swiper.autoplay.pause(speed);\\n          } else {\\n            swiper.autoplay.stop();\\n          }\\n        }\\n      },\\n      sliderFirstMove: function sliderFirstMove() {\\n        var swiper = this;\\n        if (swiper.autoplay.running) {\\n          if (swiper.params.autoplay.disableOnInteraction) {\\n            swiper.autoplay.stop();\\n          } else {\\n            swiper.autoplay.pause();\\n          }\\n        }\\n      },\\n      destroy: function destroy() {\\n        var swiper = this;\\n        if (swiper.autoplay.running) {\\n          swiper.autoplay.stop();\\n        }\\n      },\\n    },\\n  };\\n\\n  var Fade = {\\n    setTranslate: function setTranslate() {\\n      var swiper = this;\\n      var slides = swiper.slides;\\n      for (var i = 0; i < slides.length; i += 1) {\\n        var $slideEl = swiper.slides.eq(i);\\n        var offset = $slideEl[0].swiperSlideOffset;\\n        var tx = -offset;\\n        if (!swiper.params.virtualTranslate) { tx -= swiper.translate; }\\n        var ty = 0;\\n        if (!swiper.isHorizontal()) {\\n          ty = tx;\\n          tx = 0;\\n        }\\n        var slideOpacity = swiper.params.fadeEffect.crossFade\\n          ? Math.max(1 - Math.abs($slideEl[0].progress), 0)\\n          : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);\\n        $slideEl\\n          .css({\\n            opacity: slideOpacity,\\n          })\\n          .transform((\\\"translate3d(\\\" + tx + \\\"px, \\\" + ty + \\\"px, 0px)\\\"));\\n      }\\n    },\\n    setTransition: function setTransition(duration) {\\n      var swiper = this;\\n      var slides = swiper.slides;\\n      var $wrapperEl = swiper.$wrapperEl;\\n      slides.transition(duration);\\n      if (swiper.params.virtualTranslate && duration !== 0) {\\n        var eventTriggered = false;\\n        slides.transitionEnd(function () {\\n          if (eventTriggered) { return; }\\n          if (!swiper || swiper.destroyed) { return; }\\n          eventTriggered = true;\\n          swiper.animating = false;\\n          var triggerEvents = ['webkitTransitionEnd', 'transitionend'];\\n          for (var i = 0; i < triggerEvents.length; i += 1) {\\n            $wrapperEl.trigger(triggerEvents[i]);\\n          }\\n        });\\n      }\\n    },\\n  };\\n\\n  var EffectFade = {\\n    name: 'effect-fade',\\n    params: {\\n      fadeEffect: {\\n        crossFade: false,\\n      },\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        fadeEffect: {\\n          setTranslate: Fade.setTranslate.bind(swiper),\\n          setTransition: Fade.setTransition.bind(swiper),\\n        },\\n      });\\n    },\\n    on: {\\n      beforeInit: function beforeInit() {\\n        var swiper = this;\\n        if (swiper.params.effect !== 'fade') { return; }\\n        swiper.classNames.push(((swiper.params.containerModifierClass) + \\\"fade\\\"));\\n        var overwriteParams = {\\n          slidesPerView: 1,\\n          slidesPerColumn: 1,\\n          slidesPerGroup: 1,\\n          watchSlidesProgress: true,\\n          spaceBetween: 0,\\n          virtualTranslate: true,\\n        };\\n        Utils.extend(swiper.params, overwriteParams);\\n        Utils.extend(swiper.originalParams, overwriteParams);\\n      },\\n      setTranslate: function setTranslate() {\\n        var swiper = this;\\n        if (swiper.params.effect !== 'fade') { return; }\\n        swiper.fadeEffect.setTranslate();\\n      },\\n      setTransition: function setTransition(duration) {\\n        var swiper = this;\\n        if (swiper.params.effect !== 'fade') { return; }\\n        swiper.fadeEffect.setTransition(duration);\\n      },\\n    },\\n  };\\n\\n  var Cube = {\\n    setTranslate: function setTranslate() {\\n      var swiper = this;\\n      var $el = swiper.$el;\\n      var $wrapperEl = swiper.$wrapperEl;\\n      var slides = swiper.slides;\\n      var swiperWidth = swiper.width;\\n      var swiperHeight = swiper.height;\\n      var rtl = swiper.rtlTranslate;\\n      var swiperSize = swiper.size;\\n      var params = swiper.params.cubeEffect;\\n      var isHorizontal = swiper.isHorizontal();\\n      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;\\n      var wrapperRotate = 0;\\n      var $cubeShadowEl;\\n      if (params.shadow) {\\n        if (isHorizontal) {\\n          $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');\\n          if ($cubeShadowEl.length === 0) {\\n            $cubeShadowEl = $('<div class=\\\"swiper-cube-shadow\\\"></div>');\\n            $wrapperEl.append($cubeShadowEl);\\n          }\\n          $cubeShadowEl.css({ height: (swiperWidth + \\\"px\\\") });\\n        } else {\\n          $cubeShadowEl = $el.find('.swiper-cube-shadow');\\n          if ($cubeShadowEl.length === 0) {\\n            $cubeShadowEl = $('<div class=\\\"swiper-cube-shadow\\\"></div>');\\n            $el.append($cubeShadowEl);\\n          }\\n        }\\n      }\\n      for (var i = 0; i < slides.length; i += 1) {\\n        var $slideEl = slides.eq(i);\\n        var slideIndex = i;\\n        if (isVirtual) {\\n          slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);\\n        }\\n        var slideAngle = slideIndex * 90;\\n        var round = Math.floor(slideAngle / 360);\\n        if (rtl) {\\n          slideAngle = -slideAngle;\\n          round = Math.floor(-slideAngle / 360);\\n        }\\n        var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);\\n        var tx = 0;\\n        var ty = 0;\\n        var tz = 0;\\n        if (slideIndex % 4 === 0) {\\n          tx = -round * 4 * swiperSize;\\n          tz = 0;\\n        } else if ((slideIndex - 1) % 4 === 0) {\\n          tx = 0;\\n          tz = -round * 4 * swiperSize;\\n        } else if ((slideIndex - 2) % 4 === 0) {\\n          tx = swiperSize + (round * 4 * swiperSize);\\n          tz = swiperSize;\\n        } else if ((slideIndex - 3) % 4 === 0) {\\n          tx = -swiperSize;\\n          tz = (3 * swiperSize) + (swiperSize * 4 * round);\\n        }\\n        if (rtl) {\\n          tx = -tx;\\n        }\\n\\n        if (!isHorizontal) {\\n          ty = tx;\\n          tx = 0;\\n        }\\n\\n        var transform = \\\"rotateX(\\\" + (isHorizontal ? 0 : -slideAngle) + \\\"deg) rotateY(\\\" + (isHorizontal ? slideAngle : 0) + \\\"deg) translate3d(\\\" + tx + \\\"px, \\\" + ty + \\\"px, \\\" + tz + \\\"px)\\\";\\n        if (progress <= 1 && progress > -1) {\\n          wrapperRotate = (slideIndex * 90) + (progress * 90);\\n          if (rtl) { wrapperRotate = (-slideIndex * 90) - (progress * 90); }\\n        }\\n        $slideEl.transform(transform);\\n        if (params.slideShadows) {\\n          // Set shadows\\n          var shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');\\n          var shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');\\n          if (shadowBefore.length === 0) {\\n            shadowBefore = $((\\\"<div class=\\\\\\\"swiper-slide-shadow-\\\" + (isHorizontal ? 'left' : 'top') + \\\"\\\\\\\"></div>\\\"));\\n            $slideEl.append(shadowBefore);\\n          }\\n          if (shadowAfter.length === 0) {\\n            shadowAfter = $((\\\"<div class=\\\\\\\"swiper-slide-shadow-\\\" + (isHorizontal ? 'right' : 'bottom') + \\\"\\\\\\\"></div>\\\"));\\n            $slideEl.append(shadowAfter);\\n          }\\n          if (shadowBefore.length) { shadowBefore[0].style.opacity = Math.max(-progress, 0); }\\n          if (shadowAfter.length) { shadowAfter[0].style.opacity = Math.max(progress, 0); }\\n        }\\n      }\\n      $wrapperEl.css({\\n        '-webkit-transform-origin': (\\\"50% 50% -\\\" + (swiperSize / 2) + \\\"px\\\"),\\n        '-moz-transform-origin': (\\\"50% 50% -\\\" + (swiperSize / 2) + \\\"px\\\"),\\n        '-ms-transform-origin': (\\\"50% 50% -\\\" + (swiperSize / 2) + \\\"px\\\"),\\n        'transform-origin': (\\\"50% 50% -\\\" + (swiperSize / 2) + \\\"px\\\"),\\n      });\\n\\n      if (params.shadow) {\\n        if (isHorizontal) {\\n          $cubeShadowEl.transform((\\\"translate3d(0px, \\\" + ((swiperWidth / 2) + params.shadowOffset) + \\\"px, \\\" + (-swiperWidth / 2) + \\\"px) rotateX(90deg) rotateZ(0deg) scale(\\\" + (params.shadowScale) + \\\")\\\"));\\n        } else {\\n          var shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);\\n          var multiplier = 1.5 - (\\n            (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2)\\n            + (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)\\n          );\\n          var scale1 = params.shadowScale;\\n          var scale2 = params.shadowScale / multiplier;\\n          var offset = params.shadowOffset;\\n          $cubeShadowEl.transform((\\\"scale3d(\\\" + scale1 + \\\", 1, \\\" + scale2 + \\\") translate3d(0px, \\\" + ((swiperHeight / 2) + offset) + \\\"px, \\\" + (-swiperHeight / 2 / scale2) + \\\"px) rotateX(-90deg)\\\"));\\n        }\\n      }\\n      var zFactor = (Browser.isSafari || Browser.isUiWebView) ? (-swiperSize / 2) : 0;\\n      $wrapperEl\\n        .transform((\\\"translate3d(0px,0,\\\" + zFactor + \\\"px) rotateX(\\\" + (swiper.isHorizontal() ? 0 : wrapperRotate) + \\\"deg) rotateY(\\\" + (swiper.isHorizontal() ? -wrapperRotate : 0) + \\\"deg)\\\"));\\n    },\\n    setTransition: function setTransition(duration) {\\n      var swiper = this;\\n      var $el = swiper.$el;\\n      var slides = swiper.slides;\\n      slides\\n        .transition(duration)\\n        .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')\\n        .transition(duration);\\n      if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\\n        $el.find('.swiper-cube-shadow').transition(duration);\\n      }\\n    },\\n  };\\n\\n  var EffectCube = {\\n    name: 'effect-cube',\\n    params: {\\n      cubeEffect: {\\n        slideShadows: true,\\n        shadow: true,\\n        shadowOffset: 20,\\n        shadowScale: 0.94,\\n      },\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        cubeEffect: {\\n          setTranslate: Cube.setTranslate.bind(swiper),\\n          setTransition: Cube.setTransition.bind(swiper),\\n        },\\n      });\\n    },\\n    on: {\\n      beforeInit: function beforeInit() {\\n        var swiper = this;\\n        if (swiper.params.effect !== 'cube') { return; }\\n        swiper.classNames.push(((swiper.params.containerModifierClass) + \\\"cube\\\"));\\n        swiper.classNames.push(((swiper.params.containerModifierClass) + \\\"3d\\\"));\\n        var overwriteParams = {\\n          slidesPerView: 1,\\n          slidesPerColumn: 1,\\n          slidesPerGroup: 1,\\n          watchSlidesProgress: true,\\n          resistanceRatio: 0,\\n          spaceBetween: 0,\\n          centeredSlides: false,\\n          virtualTranslate: true,\\n        };\\n        Utils.extend(swiper.params, overwriteParams);\\n        Utils.extend(swiper.originalParams, overwriteParams);\\n      },\\n      setTranslate: function setTranslate() {\\n        var swiper = this;\\n        if (swiper.params.effect !== 'cube') { return; }\\n        swiper.cubeEffect.setTranslate();\\n      },\\n      setTransition: function setTransition(duration) {\\n        var swiper = this;\\n        if (swiper.params.effect !== 'cube') { return; }\\n        swiper.cubeEffect.setTransition(duration);\\n      },\\n    },\\n  };\\n\\n  var Flip = {\\n    setTranslate: function setTranslate() {\\n      var swiper = this;\\n      var slides = swiper.slides;\\n      var rtl = swiper.rtlTranslate;\\n      for (var i = 0; i < slides.length; i += 1) {\\n        var $slideEl = slides.eq(i);\\n        var progress = $slideEl[0].progress;\\n        if (swiper.params.flipEffect.limitRotation) {\\n          progress = Math.max(Math.min($slideEl[0].progress, 1), -1);\\n        }\\n        var offset = $slideEl[0].swiperSlideOffset;\\n        var rotate = -180 * progress;\\n        var rotateY = rotate;\\n        var rotateX = 0;\\n        var tx = -offset;\\n        var ty = 0;\\n        if (!swiper.isHorizontal()) {\\n          ty = tx;\\n          tx = 0;\\n          rotateX = -rotateY;\\n          rotateY = 0;\\n        } else if (rtl) {\\n          rotateY = -rotateY;\\n        }\\n\\n        $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\\n\\n        if (swiper.params.flipEffect.slideShadows) {\\n          // Set shadows\\n          var shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');\\n          var shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');\\n          if (shadowBefore.length === 0) {\\n            shadowBefore = $((\\\"<div class=\\\\\\\"swiper-slide-shadow-\\\" + (swiper.isHorizontal() ? 'left' : 'top') + \\\"\\\\\\\"></div>\\\"));\\n            $slideEl.append(shadowBefore);\\n          }\\n          if (shadowAfter.length === 0) {\\n            shadowAfter = $((\\\"<div class=\\\\\\\"swiper-slide-shadow-\\\" + (swiper.isHorizontal() ? 'right' : 'bottom') + \\\"\\\\\\\"></div>\\\"));\\n            $slideEl.append(shadowAfter);\\n          }\\n          if (shadowBefore.length) { shadowBefore[0].style.opacity = Math.max(-progress, 0); }\\n          if (shadowAfter.length) { shadowAfter[0].style.opacity = Math.max(progress, 0); }\\n        }\\n        $slideEl\\n          .transform((\\\"translate3d(\\\" + tx + \\\"px, \\\" + ty + \\\"px, 0px) rotateX(\\\" + rotateX + \\\"deg) rotateY(\\\" + rotateY + \\\"deg)\\\"));\\n      }\\n    },\\n    setTransition: function setTransition(duration) {\\n      var swiper = this;\\n      var slides = swiper.slides;\\n      var activeIndex = swiper.activeIndex;\\n      var $wrapperEl = swiper.$wrapperEl;\\n      slides\\n        .transition(duration)\\n        .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')\\n        .transition(duration);\\n      if (swiper.params.virtualTranslate && duration !== 0) {\\n        var eventTriggered = false;\\n        // eslint-disable-next-line\\n        slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {\\n          if (eventTriggered) { return; }\\n          if (!swiper || swiper.destroyed) { return; }\\n          // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;\\n          eventTriggered = true;\\n          swiper.animating = false;\\n          var triggerEvents = ['webkitTransitionEnd', 'transitionend'];\\n          for (var i = 0; i < triggerEvents.length; i += 1) {\\n            $wrapperEl.trigger(triggerEvents[i]);\\n          }\\n        });\\n      }\\n    },\\n  };\\n\\n  var EffectFlip = {\\n    name: 'effect-flip',\\n    params: {\\n      flipEffect: {\\n        slideShadows: true,\\n        limitRotation: true,\\n      },\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        flipEffect: {\\n          setTranslate: Flip.setTranslate.bind(swiper),\\n          setTransition: Flip.setTransition.bind(swiper),\\n        },\\n      });\\n    },\\n    on: {\\n      beforeInit: function beforeInit() {\\n        var swiper = this;\\n        if (swiper.params.effect !== 'flip') { return; }\\n        swiper.classNames.push(((swiper.params.containerModifierClass) + \\\"flip\\\"));\\n        swiper.classNames.push(((swiper.params.containerModifierClass) + \\\"3d\\\"));\\n        var overwriteParams = {\\n          slidesPerView: 1,\\n          slidesPerColumn: 1,\\n          slidesPerGroup: 1,\\n          watchSlidesProgress: true,\\n          spaceBetween: 0,\\n          virtualTranslate: true,\\n        };\\n        Utils.extend(swiper.params, overwriteParams);\\n        Utils.extend(swiper.originalParams, overwriteParams);\\n      },\\n      setTranslate: function setTranslate() {\\n        var swiper = this;\\n        if (swiper.params.effect !== 'flip') { return; }\\n        swiper.flipEffect.setTranslate();\\n      },\\n      setTransition: function setTransition(duration) {\\n        var swiper = this;\\n        if (swiper.params.effect !== 'flip') { return; }\\n        swiper.flipEffect.setTransition(duration);\\n      },\\n    },\\n  };\\n\\n  var Coverflow = {\\n    setTranslate: function setTranslate() {\\n      var swiper = this;\\n      var swiperWidth = swiper.width;\\n      var swiperHeight = swiper.height;\\n      var slides = swiper.slides;\\n      var $wrapperEl = swiper.$wrapperEl;\\n      var slidesSizesGrid = swiper.slidesSizesGrid;\\n      var params = swiper.params.coverflowEffect;\\n      var isHorizontal = swiper.isHorizontal();\\n      var transform = swiper.translate;\\n      var center = isHorizontal ? -transform + (swiperWidth / 2) : -transform + (swiperHeight / 2);\\n      var rotate = isHorizontal ? params.rotate : -params.rotate;\\n      var translate = params.depth;\\n      // Each slide offset from center\\n      for (var i = 0, length = slides.length; i < length; i += 1) {\\n        var $slideEl = slides.eq(i);\\n        var slideSize = slidesSizesGrid[i];\\n        var slideOffset = $slideEl[0].swiperSlideOffset;\\n        var offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;\\n\\n        var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\\n        var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\\n        // var rotateZ = 0\\n        var translateZ = -translate * Math.abs(offsetMultiplier);\\n\\n        var translateY = isHorizontal ? 0 : params.stretch * (offsetMultiplier);\\n        var translateX = isHorizontal ? params.stretch * (offsetMultiplier) : 0;\\n\\n        // Fix for ultra small values\\n        if (Math.abs(translateX) < 0.001) { translateX = 0; }\\n        if (Math.abs(translateY) < 0.001) { translateY = 0; }\\n        if (Math.abs(translateZ) < 0.001) { translateZ = 0; }\\n        if (Math.abs(rotateY) < 0.001) { rotateY = 0; }\\n        if (Math.abs(rotateX) < 0.001) { rotateX = 0; }\\n\\n        var slideTransform = \\\"translate3d(\\\" + translateX + \\\"px,\\\" + translateY + \\\"px,\\\" + translateZ + \\\"px)  rotateX(\\\" + rotateX + \\\"deg) rotateY(\\\" + rotateY + \\\"deg)\\\";\\n\\n        $slideEl.transform(slideTransform);\\n        $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\\n        if (params.slideShadows) {\\n          // Set shadows\\n          var $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');\\n          var $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');\\n          if ($shadowBeforeEl.length === 0) {\\n            $shadowBeforeEl = $((\\\"<div class=\\\\\\\"swiper-slide-shadow-\\\" + (isHorizontal ? 'left' : 'top') + \\\"\\\\\\\"></div>\\\"));\\n            $slideEl.append($shadowBeforeEl);\\n          }\\n          if ($shadowAfterEl.length === 0) {\\n            $shadowAfterEl = $((\\\"<div class=\\\\\\\"swiper-slide-shadow-\\\" + (isHorizontal ? 'right' : 'bottom') + \\\"\\\\\\\"></div>\\\"));\\n            $slideEl.append($shadowAfterEl);\\n          }\\n          if ($shadowBeforeEl.length) { $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0; }\\n          if ($shadowAfterEl.length) { $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0; }\\n        }\\n      }\\n\\n      // Set correct perspective for IE10\\n      if (Support.pointerEvents || Support.prefixedPointerEvents) {\\n        var ws = $wrapperEl[0].style;\\n        ws.perspectiveOrigin = center + \\\"px 50%\\\";\\n      }\\n    },\\n    setTransition: function setTransition(duration) {\\n      var swiper = this;\\n      swiper.slides\\n        .transition(duration)\\n        .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')\\n        .transition(duration);\\n    },\\n  };\\n\\n  var EffectCoverflow = {\\n    name: 'effect-coverflow',\\n    params: {\\n      coverflowEffect: {\\n        rotate: 50,\\n        stretch: 0,\\n        depth: 100,\\n        modifier: 1,\\n        slideShadows: true,\\n      },\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        coverflowEffect: {\\n          setTranslate: Coverflow.setTranslate.bind(swiper),\\n          setTransition: Coverflow.setTransition.bind(swiper),\\n        },\\n      });\\n    },\\n    on: {\\n      beforeInit: function beforeInit() {\\n        var swiper = this;\\n        if (swiper.params.effect !== 'coverflow') { return; }\\n\\n        swiper.classNames.push(((swiper.params.containerModifierClass) + \\\"coverflow\\\"));\\n        swiper.classNames.push(((swiper.params.containerModifierClass) + \\\"3d\\\"));\\n\\n        swiper.params.watchSlidesProgress = true;\\n        swiper.originalParams.watchSlidesProgress = true;\\n      },\\n      setTranslate: function setTranslate() {\\n        var swiper = this;\\n        if (swiper.params.effect !== 'coverflow') { return; }\\n        swiper.coverflowEffect.setTranslate();\\n      },\\n      setTransition: function setTransition(duration) {\\n        var swiper = this;\\n        if (swiper.params.effect !== 'coverflow') { return; }\\n        swiper.coverflowEffect.setTransition(duration);\\n      },\\n    },\\n  };\\n\\n  var Thumbs = {\\n    init: function init() {\\n      var swiper = this;\\n      var ref = swiper.params;\\n      var thumbsParams = ref.thumbs;\\n      var SwiperClass = swiper.constructor;\\n      if (thumbsParams.swiper instanceof SwiperClass) {\\n        swiper.thumbs.swiper = thumbsParams.swiper;\\n        Utils.extend(swiper.thumbs.swiper.originalParams, {\\n          watchSlidesProgress: true,\\n          slideToClickedSlide: false,\\n        });\\n        Utils.extend(swiper.thumbs.swiper.params, {\\n          watchSlidesProgress: true,\\n          slideToClickedSlide: false,\\n        });\\n      } else if (Utils.isObject(thumbsParams.swiper)) {\\n        swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {\\n          watchSlidesVisibility: true,\\n          watchSlidesProgress: true,\\n          slideToClickedSlide: false,\\n        }));\\n        swiper.thumbs.swiperCreated = true;\\n      }\\n      swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);\\n      swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);\\n    },\\n    onThumbClick: function onThumbClick() {\\n      var swiper = this;\\n      var thumbsSwiper = swiper.thumbs.swiper;\\n      if (!thumbsSwiper) { return; }\\n      var clickedIndex = thumbsSwiper.clickedIndex;\\n      var clickedSlide = thumbsSwiper.clickedSlide;\\n      if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) { return; }\\n      if (typeof clickedIndex === 'undefined' || clickedIndex === null) { return; }\\n      var slideToIndex;\\n      if (thumbsSwiper.params.loop) {\\n        slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);\\n      } else {\\n        slideToIndex = clickedIndex;\\n      }\\n      if (swiper.params.loop) {\\n        var currentIndex = swiper.activeIndex;\\n        if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {\\n          swiper.loopFix();\\n          // eslint-disable-next-line\\n          swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\\n          currentIndex = swiper.activeIndex;\\n        }\\n        var prevIndex = swiper.slides.eq(currentIndex).prevAll((\\\"[data-swiper-slide-index=\\\\\\\"\\\" + slideToIndex + \\\"\\\\\\\"]\\\")).eq(0).index();\\n        var nextIndex = swiper.slides.eq(currentIndex).nextAll((\\\"[data-swiper-slide-index=\\\\\\\"\\\" + slideToIndex + \\\"\\\\\\\"]\\\")).eq(0).index();\\n        if (typeof prevIndex === 'undefined') { slideToIndex = nextIndex; }\\n        else if (typeof nextIndex === 'undefined') { slideToIndex = prevIndex; }\\n        else if (nextIndex - currentIndex < currentIndex - prevIndex) { slideToIndex = nextIndex; }\\n        else { slideToIndex = prevIndex; }\\n      }\\n      swiper.slideTo(slideToIndex);\\n    },\\n    update: function update(initial) {\\n      var swiper = this;\\n      var thumbsSwiper = swiper.thumbs.swiper;\\n      if (!thumbsSwiper) { return; }\\n\\n      var slidesPerView = thumbsSwiper.params.slidesPerView === 'auto'\\n        ? thumbsSwiper.slidesPerViewDynamic()\\n        : thumbsSwiper.params.slidesPerView;\\n\\n      if (swiper.realIndex !== thumbsSwiper.realIndex) {\\n        var currentThumbsIndex = thumbsSwiper.activeIndex;\\n        var newThumbsIndex;\\n        if (thumbsSwiper.params.loop) {\\n          if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {\\n            thumbsSwiper.loopFix();\\n            // eslint-disable-next-line\\n            thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;\\n            currentThumbsIndex = thumbsSwiper.activeIndex;\\n          }\\n          // Find actual thumbs index to slide to\\n          var prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll((\\\"[data-swiper-slide-index=\\\\\\\"\\\" + (swiper.realIndex) + \\\"\\\\\\\"]\\\")).eq(0).index();\\n          var nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll((\\\"[data-swiper-slide-index=\\\\\\\"\\\" + (swiper.realIndex) + \\\"\\\\\\\"]\\\")).eq(0).index();\\n          if (typeof prevThumbsIndex === 'undefined') { newThumbsIndex = nextThumbsIndex; }\\n          else if (typeof nextThumbsIndex === 'undefined') { newThumbsIndex = prevThumbsIndex; }\\n          else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) { newThumbsIndex = currentThumbsIndex; }\\n          else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) { newThumbsIndex = nextThumbsIndex; }\\n          else { newThumbsIndex = prevThumbsIndex; }\\n        } else {\\n          newThumbsIndex = swiper.realIndex;\\n        }\\n        if (thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\\n          if (thumbsSwiper.params.centeredSlides) {\\n            if (newThumbsIndex > currentThumbsIndex) {\\n              newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\\n            } else {\\n              newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\\n            }\\n          } else if (newThumbsIndex > currentThumbsIndex) {\\n            newThumbsIndex = newThumbsIndex - slidesPerView + 1;\\n          }\\n          thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\\n        }\\n      }\\n\\n      // Activate thumbs\\n      var thumbsToActivate = 1;\\n      var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\\n\\n      if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\\n        thumbsToActivate = swiper.params.slidesPerView;\\n      }\\n\\n      thumbsSwiper.slides.removeClass(thumbActiveClass);\\n      if (thumbsSwiper.params.loop) {\\n        for (var i = 0; i < thumbsToActivate; i += 1) {\\n          thumbsSwiper.$wrapperEl.children((\\\"[data-swiper-slide-index=\\\\\\\"\\\" + (swiper.realIndex + i) + \\\"\\\\\\\"]\\\")).addClass(thumbActiveClass);\\n        }\\n      } else {\\n        for (var i$1 = 0; i$1 < thumbsToActivate; i$1 += 1) {\\n          thumbsSwiper.slides.eq(swiper.realIndex + i$1).addClass(thumbActiveClass);\\n        }\\n      }\\n    },\\n  };\\n  var Thumbs$1 = {\\n    name: 'thumbs',\\n    params: {\\n      thumbs: {\\n        swiper: null,\\n        slideThumbActiveClass: 'swiper-slide-thumb-active',\\n        thumbsContainerClass: 'swiper-container-thumbs',\\n      },\\n    },\\n    create: function create() {\\n      var swiper = this;\\n      Utils.extend(swiper, {\\n        thumbs: {\\n          swiper: null,\\n          init: Thumbs.init.bind(swiper),\\n          update: Thumbs.update.bind(swiper),\\n          onThumbClick: Thumbs.onThumbClick.bind(swiper),\\n        },\\n      });\\n    },\\n    on: {\\n      beforeInit: function beforeInit() {\\n        var swiper = this;\\n        var ref = swiper.params;\\n        var thumbs = ref.thumbs;\\n        if (!thumbs || !thumbs.swiper) { return; }\\n        swiper.thumbs.init();\\n        swiper.thumbs.update(true);\\n      },\\n      slideChange: function slideChange() {\\n        var swiper = this;\\n        if (!swiper.thumbs.swiper) { return; }\\n        swiper.thumbs.update();\\n      },\\n      update: function update() {\\n        var swiper = this;\\n        if (!swiper.thumbs.swiper) { return; }\\n        swiper.thumbs.update();\\n      },\\n      resize: function resize() {\\n        var swiper = this;\\n        if (!swiper.thumbs.swiper) { return; }\\n        swiper.thumbs.update();\\n      },\\n      observerUpdate: function observerUpdate() {\\n        var swiper = this;\\n        if (!swiper.thumbs.swiper) { return; }\\n        swiper.thumbs.update();\\n      },\\n      setTransition: function setTransition(duration) {\\n        var swiper = this;\\n        var thumbsSwiper = swiper.thumbs.swiper;\\n        if (!thumbsSwiper) { return; }\\n        thumbsSwiper.setTransition(duration);\\n      },\\n      beforeDestroy: function beforeDestroy() {\\n        var swiper = this;\\n        var thumbsSwiper = swiper.thumbs.swiper;\\n        if (!thumbsSwiper) { return; }\\n        if (swiper.thumbs.swiperCreated && thumbsSwiper) {\\n          thumbsSwiper.destroy();\\n        }\\n      },\\n    },\\n  };\\n\\n  // Swiper Class\\n\\n  var components = [\\n    Device$1,\\n    Support$1,\\n    Browser$1,\\n    Resize,\\n    Observer$1,\\n    Virtual$1,\\n    Keyboard$1,\\n    Mousewheel$1,\\n    Navigation$1,\\n    Pagination$1,\\n    Scrollbar$1,\\n    Parallax$1,\\n    Zoom$1,\\n    Lazy$1,\\n    Controller$1,\\n    A11y,\\n    History$1,\\n    HashNavigation$1,\\n    Autoplay$1,\\n    EffectFade,\\n    EffectCube,\\n    EffectFlip,\\n    EffectCoverflow,\\n    Thumbs$1\\n  ];\\n\\n  if (typeof Swiper.use === 'undefined') {\\n    Swiper.use = Swiper.Class.use;\\n    Swiper.installModule = Swiper.Class.installModule;\\n  }\\n\\n  Swiper.use(components);\\n\\n  return Swiper;\\n\\n})));\\n\\n\\n//# sourceURL=webpack:///./node_modules/swiper/dist/js/swiper.js?\")}});"],"file":"bundle.min.js"}